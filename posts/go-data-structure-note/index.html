<!doctype html><html lang=en><head prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article#"><meta charset=UTF-8><meta name=generator content="Hugo 0.135.0"><meta name=theme-color content="#fff"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=format-detection content="telephone=no, date=no, address=no, email=no"><meta http-equiv=Cache-Control content="no-transform"><meta http-equiv=Cache-Control content="no-siteapp"><title>《Go 语言设计与实现》读书笔记：数据结构 | Inspire Hub</title>
<link rel=stylesheet href=/css/meme.min.29f06ccbcbf49b8f420fa6e6976a12c3760e5b7fc62170ba2f32d3e10a36c609.css><script src=https://cdn.jsdelivr.net/npm/lunr@2.3.9/lunr.min.js defer></script><script src=/js/meme.min.0af281c0d99b202885f5b50cf9878fd0d4f3b3e6afe956cecb5e4576d9647970.js></script><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=IBM+Plex+Serif:ital,wght@0,400;0,500;0,700;1,400;1,700&amp;family=Source+Code+Pro:ital,wght@0,400;0,700;1,400;1,700&amp;family=Comfortaa:wght@700&amp;display=swap" media=print onload='this.media="all"'><noscript><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=IBM+Plex+Serif:ital,wght@0,400;0,500;0,700;1,400;1,700&amp;family=Source+Code+Pro:ital,wght@0,400;0,700;1,400;1,700&amp;family=Comfortaa:wght@700&amp;display=swap"></noscript><meta name=author content="koktlzz"><meta name=description content="抽象语法树（Abstract Syntax Tree，AST），是源代码语法的结构的一种抽象表示。它用树状的方式表示编程语言的语法结构，每个节点都表示源代码中的一个元素，每一颗子树都表示一个语法元素 …"><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=mask-icon href=/icons/safari-pinned-tab.svg color=#2a6df4><link rel=apple-touch-icon sizes=180x180 href=/icons/apple-touch-icon.png><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-title content="Inspire Hub"><meta name=apple-mobile-web-app-status-bar-style content="black"><meta name=mobile-web-app-capable content="yes"><meta name=application-name content="Inspire Hub"><meta name=msapplication-starturl content="../../"><meta name=msapplication-TileColor content="#fff"><meta name=msapplication-TileImage content="../../icons/mstile-150x150.png"><link rel=manifest href=/manifest.json><link rel=canonical href=/posts/go-data-structure-note/><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","datePublished":"2024-07-18T13:26:42+01:00","dateModified":"2024-08-18T17:26:41+08:00","url":"/posts/go-data-structure-note/","headline":"《Go 语言设计与实现》读书笔记：数据结构","description":"抽象语法树（Abstract Syntax Tree，AST），是源代码语法的结构的一种抽象表示。它用树状的方式表示编程语言的语法结构，每个节点都表示源代码中的一个元素，每一颗子树都表示一个语法元素 …","inLanguage":"en","articleSection":"posts","wordCount":2882,"image":["https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20240721231002.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20240721231049.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20240721231126.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20240721231215.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20240721231248.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20240721231307.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20240721231338.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20240721231404.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20240721231456.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20240721231524.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20240721231551.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20240721231616.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20240721231645.png"],"author":{"@type":"Person","email":"koktlgwr@gmail.com","image":"/icons/apple-touch-icon.png","url":"/","name":"koktlzz"},"license":"[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)","publisher":{"@type":"Organization","name":"Inspire Hub","logo":{"@type":"ImageObject","url":"/icons/apple-touch-icon.png"},"url":"/"},"mainEntityOfPage":{"@type":"WebSite","@id":"/"}}</script><meta property="og:title" content="《Go 语言设计与实现》读书笔记：数据结构"><meta property="og:description" content="抽象语法树（Abstract Syntax Tree，AST），是源代码语法的结构的一种抽象表示。它用树状的方式表示编程语言的语法结构，每个节点都表示源代码中的一个元素，每一颗子树都表示一个语法元素 …"><meta property="og:url" content="/posts/go-data-structure-note/"><meta property="og:site_name" content="Inspire Hub"><meta property="og:locale" content="en"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20240721231002.png"><meta property="og:type" content="article"><meta property="article:published_time" content="2024-07-18T13:26:42+01:00"><meta property="article:modified_time" content="2024-08-18T17:26:41+08:00"><meta property="article:section" content="posts"><link rel=preconnect href=https://www.google-analytics.com crossorigin><script async src="https://www.googletagmanager.com/gtag/js?id=G-D022F6NT2P"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-D022F6NT2P")</script></head><body><div class=container><header class=header><div class=header-wrapper><div class="header-inner single"><div class=site-brand><a href=/ class=brand>Inspire Hub</a></div><nav class=nav><ul class=menu id=menu><li class=menu-item><a href=/posts/><svg viewBox="0 0 512 512" class="icon archive"><path d="M32 448c0 17.7 14.3 32 32 32h384c17.7.0 32-14.3 32-32V160H32v288zm160-212c0-6.6 5.4-12 12-12h104c6.6.0 12 5.4 12 12v8c0 6.6-5.4 12-12 12H204c-6.6.0-12-5.4-12-12v-8zM480 32H32C14.3 32 0 46.3.0 64v48c0 8.8 7.2 16 16 16h480c8.8.0 16-7.2 16-16V64c0-17.7-14.3-32-32-32z"/></svg><span class=menu-item-name>Posts</span></a></li><li class=menu-item><a href=/series/><svg viewBox="0 0 512 512" class="icon th"><path d="M149.333 56v80c0 13.255-10.745 24-24 24H24c-13.255.0-24-10.745-24-24V56c0-13.255 10.745-24 24-24h101.333c13.255.0 24 10.745 24 24zm181.334 240v-80c0-13.255-10.745-24-24-24H205.333c-13.255.0-24 10.745-24 24v80c0 13.255 10.745 24 24 24h101.333c13.256.0 24.001-10.745 24.001-24zm32-240v80c0 13.255 10.745 24 24 24H488c13.255.0 24-10.745 24-24V56c0-13.255-10.745-24-24-24H386.667c-13.255.0-24 10.745-24 24zm-32 80V56c0-13.255-10.745-24-24-24H205.333c-13.255.0-24 10.745-24 24v80c0 13.255 10.745 24 24 24h101.333c13.256.0 24.001-10.745 24.001-24zm-205.334 56H24c-13.255.0-24 10.745-24 24v80c0 13.255 10.745 24 24 24h101.333c13.255.0 24-10.745 24-24v-80c0-13.255-10.745-24-24-24zM0 376v80c0 13.255 10.745 24 24 24h101.333c13.255.0 24-10.745 24-24v-80c0-13.255-10.745-24-24-24H24c-13.255.0-24 10.745-24 24zm386.667-56H488c13.255.0 24-10.745 24-24v-80c0-13.255-10.745-24-24-24H386.667c-13.255.0-24 10.745-24 24v80c0 13.255 10.745 24 24 24zm0 160H488c13.255.0 24-10.745 24-24v-80c0-13.255-10.745-24-24-24H386.667c-13.255.0-24 10.745-24 24v80c0 13.255 10.745 24 24 24zM181.333 376v80c0 13.255 10.745 24 24 24h101.333c13.255.0 24-10.745 24-24v-80c0-13.255-10.745-24-24-24H205.333c-13.255.0-24 10.745-24 24z"/></svg><span class=menu-item-name>Series</span></a></li><li class=menu-item><a href=/tags/><svg viewBox="0 0 640 512" class="icon tags"><path d="M497.941 225.941 286.059 14.059A48 48 0 00252.118.0H48C21.49.0.0 21.49.0 48v204.118a48 48 0 0014.059 33.941l211.882 211.882c18.744 18.745 49.136 18.746 67.882.0l204.118-204.118c18.745-18.745 18.745-49.137.0-67.882zM112 160c-26.51.0-48-21.49-48-48s21.49-48 48-48 48 21.49 48 48-21.49 48-48 48zm513.941 133.823L421.823 497.941c-18.745 18.745-49.137 18.745-67.882.0l-.36-.36L527.64 323.522c16.999-16.999 26.36-39.6 26.36-63.64s-9.362-46.641-26.36-63.64L331.397.0h48.721a48 48 0 0133.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137.0 67.882z"/></svg><span class=menu-item-name>Tags</span></a></li><li class=menu-item><a href></a></li><li class="menu-item search-item"><form id=search class=search role=search><label for=search-input><svg viewBox="0 0 512 512" class="icon search-icon"><path d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg></label>
<input type=search id=search-input class=search-input></form><template id=search-result hidden><article class="content post"><h2 class=post-title><a class=summary-title-link></a></h2><summary class=summary></summary><div class=read-more-container><a class=read-more-link>Read More »</a></div></article></template></li></ul></nav></div></div><input type=checkbox id=nav-toggle aria-hidden=true>
<label for=nav-toggle class=nav-toggle></label>
<label for=nav-toggle class=nav-curtain></label></header><main class="main single" id=main><nav class=contents><h2 id=contents class=contents-title>On This Page</h2><ol class=toc><li><a id=contents:数组 href=#数组>数组</a><ol><li><a id=contents:初始化 href=#初始化>初始化</a></li><li><a id=contents:访问和赋值 href=#访问和赋值>访问和赋值</a></li></ol></li><li><a id=contents:切片 href=#切片>切片</a><ol><li><a id=contents:初始化-1 href=#初始化-1>初始化</a><ol><li><a id=contents:使用下标 href=#使用下标>使用下标</a></li><li><a id=contents:使用字面量 href=#使用字面量>使用字面量</a></li><li><a id=contents:使用-make href=#使用-make>使用 make</a></li></ol></li><li><a id=contents:访问元素 href=#访问元素>访问元素</a></li><li><a id=contents:追加和扩容 href=#追加和扩容>追加和扩容</a></li><li><a id=contents:复制切片 href=#复制切片>复制切片</a></li></ol></li><li><a id=contents:哈希表 href=#哈希表>哈希表</a><ol><li><a id=contents:设计原理 href=#设计原理>设计原理</a><ol><li><a id=contents:开放寻址法 href=#开放寻址法>开放寻址法</a></li><li><a id=contents:拉链法 href=#拉链法>拉链法</a></li></ol></li><li><a id=contents:数据结构 href=#数据结构>数据结构</a></li><li><a id=contents:初始化-2 href=#初始化-2>初始化</a><ol><li><a id=contents:字面量 href=#字面量>字面量</a></li><li><a id=contents:运行时 href=#运行时>运行时</a></li></ol></li><li><a id=contents:读写操作 href=#读写操作>读写操作</a><ol><li><a id=contents:访问 href=#访问>访问</a></li><li><a id=contents:写入 href=#写入>写入</a></li><li><a id=contents:扩容 href=#扩容>扩容</a></li><li><a id=contents:删除 href=#删除>删除</a></li></ol></li></ol></li><li><a id=contents:字符串 href=#字符串>字符串</a><ol><li><a id=contents:数据结构-1 href=#数据结构-1>数据结构</a></li><li><a id=contents:拼接 href=#拼接>拼接</a></li><li><a id=contents:类型转换 href=#类型转换>类型转换</a></li></ol></li></ol></nav><div class=main-inner><article class="content post h-entry" data-small-caps=true data-align=default data-type=posts><h1 class="post-title p-name">《Go 语言设计与实现》读书笔记：数据结构</h1><div class=post-tags><a href=/tags/go/ rel=tag class=post-tags-link><svg viewBox="0 0 512 512" class="icon tag-icon"><path d="M0 252.118V48C0 21.49 21.49.0 48 0h204.118a48 48 0 0133.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137.0 67.882L293.823 497.941c-18.745 18.745-49.137 18.745-67.882.0L14.059 286.059A48 48 0 010 252.118zM112 64c-26.51.0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48z"/></svg>Go</a>
<a href=/tags/data-structure/ rel=tag class=post-tags-link><svg viewBox="0 0 512 512" class="icon tag-icon"><path d="M0 252.118V48C0 21.49 21.49.0 48 0h204.118a48 48 0 0133.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137.0 67.882L293.823 497.941c-18.745 18.745-49.137 18.745-67.882.0L14.059 286.059A48 48 0 010 252.118zM112 64c-26.51.0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48z"/></svg>Data-Structure</a></div><div class="post-body e-content"><blockquote><p>原书中的代码片段基于 Go 1.15，笔记则根据 Go 1.22 版本的更新进行了相应替换。</p></blockquote><h2 id=数组><a href=#数组 class=anchor-link><svg viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:数组 class=headings>数组</a></h2><p>我们通常会从两个维度描述数组：数组中存储的元素类型（Type）和数组最大能存储的元素个数（Bound）。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Array</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>Elem</span>  <span class=o>*</span><span class=nx>Type</span> <span class=c1>// element type
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>Bound</span> <span class=kt>int64</span> <span class=c1>// number of elements; &lt;0 if unknown yet
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><p>Go 语言数组在初始化之后大小就无法改变。存储元素类型相同、但大小不同的数组类型在 Go 语言看来也是完全不同的，只有两个条件都相同才是同一类型。</p><p>编译期间的数组类型是由 <a href=https://github.com/golang/go/blob/4c50f9162cafaccc1ab1bc26b0dea18f124b536d/src/cmd/compile/internal/types/type.go#L542 target=_blank rel=noopener>cmd/compile/internal/types.NewArray</a> 函数生成的：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>NewArray</span><span class=p>(</span><span class=nx>elem</span> <span class=o>*</span><span class=nx>Type</span><span class=p>,</span> <span class=nx>bound</span> <span class=kt>int64</span><span class=p>)</span> <span class=o>*</span><span class=nx>Type</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>bound</span> <span class=p>&lt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>base</span><span class=p>.</span><span class=nf>Fatalf</span><span class=p>(</span><span class=s>&#34;NewArray: invalid bound %v&#34;</span><span class=p>,</span> <span class=nx>bound</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>t</span> <span class=o>:=</span> <span class=nf>newType</span><span class=p>(</span><span class=nx>TARRAY</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>t</span><span class=p>.</span><span class=nx>extra</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>Array</span><span class=p>{</span><span class=nx>Elem</span><span class=p>:</span> <span class=nx>elem</span><span class=p>,</span> <span class=nx>Bound</span><span class=p>:</span> <span class=nx>bound</span><span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>elem</span><span class=p>.</span><span class=nf>HasShape</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>t</span><span class=p>.</span><span class=nf>SetHasShape</span><span class=p>(</span><span class=kc>true</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>t</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><h3 id=初始化><a href=#初始化 class=anchor-link><svg viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:初始化 class=headings>初始化</a></h3><p>Go 语言的数组有两种不同的创建方式，一种是显式的指定数组大小，另一种是使用<code>[...]T</code>声明数组。如下两种声明方式在运行期间得到的结果是完全相同的：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>arr1</span> <span class=o>:=</span> <span class=p>[</span><span class=mi>3</span><span class=p>]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>arr2</span> <span class=o>:=</span> <span class=p>[</span><span class=o>...</span><span class=p>]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><p>不过第一种方式声明的数组的大小在 <a href=/posts/go-compiler-principle-note/#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5>类型检查</a> 阶段就会被提取出来，而第二种方式则需要编译器通过遍历元素来计算。因此，<code>[...]T</code> 这种初始化方式其实是 Go 语言为我们提供的一种语法糖。</p><p>对于一个由字面量（Literal）组成的数组，根据数组元素数量的不同，编译器会在负责初始化字面量的 <a href=https://github.com/golang/go/blob/4c50f9162cafaccc1ab1bc26b0dea18f124b536d/src/cmd/compile/internal/walk/complit.go#L527 target=_blank rel=noopener>cmd/compile/internal/walk.anylit</a> 函数中做出两种不同的优化：</p><ol><li>当元素数量小于或者等于 4 个时，会直接将数组中的元素放置在栈上；</li><li>当元素数量大于 4 个时，会将数组中的元素放置到静态区并在运行时复制到栈中。</li></ol><p>举例来说，<code>[3]int{1, 2, 3}</code>会被拆分成一个声明变量的表达式和几个赋值表达式：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>arr</span> <span class=p>[</span><span class=mi>3</span><span class=p>]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=nx>arr</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=p>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=nx>arr</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=p>=</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl><span class=nx>arr</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=p>=</span> <span class=mi>3</span>
</span></span></code></pre></td></tr></table></div></div></div><p>而<code>[5]int{1, 2, 3, 4, 5}</code>的初始化过程则等效于如下伪码：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>arr</span> <span class=p>[</span><span class=mi>5</span><span class=p>]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=c1>// 元素存储于静态区
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>statictmp_0</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=p>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=nx>statictmp_0</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=p>=</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl><span class=nx>statictmp_0</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=p>=</span> <span class=mi>3</span>
</span></span><span class=line><span class=cl><span class=nx>statictmp_0</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span> <span class=p>=</span> <span class=mi>4</span>
</span></span><span class=line><span class=cl><span class=nx>statictmp_0</span><span class=p>[</span><span class=mi>4</span><span class=p>]</span> <span class=p>=</span> <span class=mi>5</span>
</span></span><span class=line><span class=cl><span class=nx>arr</span> <span class=p>=</span> <span class=nx>statictmp_0</span>
</span></span></code></pre></td></tr></table></div></div></div><h3 id=访问和赋值><a href=#访问和赋值 class=anchor-link><svg viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:访问和赋值 class=headings>访问和赋值</a></h3><p>无论是在栈上还是静态存储区，数组在内存中都是一连串的内存空间，我们通过指向数组开头的指针、元素的数量以及元素类型占的空间大小表示数组。</p><p>Go 语言中可以在编译期间的静态类型检查判断数组越界，但是如果使用变量去访问数组或者字符串时，我们就需要 Go 语言运行时阻止不合法的访问：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 静态类型检查
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>arr</span><span class=p>[</span><span class=mi>4</span><span class=p>]:</span> <span class=nx>invalid</span> <span class=nx>argument</span><span class=p>:</span> <span class=nx>index</span> <span class=mi>4</span> <span class=nx>out</span> <span class=nx>of</span> <span class=nx>bounds</span> <span class=p>[</span><span class=mi>0</span><span class=p>:</span><span class=mi>3</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=c1>// 运行时 runtime.panicIndex
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>arr</span><span class=p>[</span><span class=nx>i</span><span class=p>]:</span> <span class=nx>panic</span><span class=p>:</span> <span class=nx>runtime</span> <span class=kt>error</span><span class=p>:</span> <span class=nx>index</span> <span class=nx>out</span> <span class=nx>of</span> <span class=k>range</span> <span class=p>[</span><span class=mi>4</span><span class=p>]</span> <span class=nx>with</span> <span class=nx>length</span> <span class=mi>3</span>
</span></span></code></pre></td></tr></table></div></div></div><h2 id=切片><a href=#切片 class=anchor-link><svg viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:切片 class=headings>切片</a></h2><p>切片，即动态数组，其长度并不固定，所以声明时只需要指定切片中的元素类型：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=p>[]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=p>[]</span><span class=kd>interface</span><span class=p>{}</span>
</span></span></code></pre></td></tr></table></div></div></div><p>编译期间的切片是 <a href=https://github.com/golang/go/blob/4c50f9162cafaccc1ab1bc26b0dea18f124b536d/src/cmd/compile/internal/types/type.go#L424 target=_blank rel=noopener>cmd/compile/internal/types.Slice</a> 类型的，只确定了元素的类型：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Slice</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>Elem</span> <span class=o>*</span><span class=nx>Type</span> <span class=c1>// element type
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><p>在运行时则由 <a href=https://github.com/golang/go/blob/071b8d51c1a70fa6b12f0bed2e93370e193333fd/src/internal/unsafeheader/unsafeheader.go#L22 target=_blank rel=noopener>internal/unsafeheader.Slice</a> 结构体表示：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>SliceHeader</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>Data</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span>  <span class=c1>// 指向底层数组的指针
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>Len</span>  <span class=kt>int</span>             <span class=c1>// 当前切片的长度
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>Cap</span>  <span class=kt>int</span>             <span class=c1>// 当前切片的容量，即底层数组的大小
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><blockquote><p>由于大量开发者使用 <a href=https://github.com/golang/go/blob/4c50f9162cafaccc1ab1bc26b0dea18f124b536d/src/reflect/value.go#L2840 target=_blank rel=noopener>reflect.StringHeader</a> 和 <a href=https://github.com/golang/go/blob/4c50f9162cafaccc1ab1bc26b0dea18f124b536d/src/reflect/value.go#L2853 target=_blank rel=noopener>reflect.SliceHeader</a> 实现零复制的字符串/字节数组转换而产生诸多内存泄露问题，两者在 Go 1.20 版本中被弃用，详见：<a href=https://github.com/golang/go/issues/53003 target=_blank rel=noopener>unsafe: add StringData, String, SliceData</a>。切片和字符串的运行时表示目前为：<a href=https://github.com/golang/go/blob/071b8d51c1a70fa6b12f0bed2e93370e193333fd/src/internal/unsafeheader/unsafeheader.go#L22 target=_blank rel=noopener>unsafeheader.Slice</a> 和 <a href=https://github.com/golang/go/blob/071b8d51c1a70fa6b12f0bed2e93370e193333fd/src/internal/unsafeheader/unsafeheader.go#L34 target=_blank rel=noopener>unsafeheader.String</a>，区别在于<code>Data</code>字段的类型由<code>uintptr</code>改为<code>unsafe.Pointer</code>。</p></blockquote><p>因此我们可以将切片理解成一片连续的内存空间（底层数组）以及长度与容量的标识：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20240721231002.png alt=20240721231002></p><h3 id=初始化-1><a href=#初始化-1 class=anchor-link><svg viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:初始化-1 class=headings>初始化</a></h3><p>Go 语言中支持三种初始化切片的方式：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>arr</span><span class=p>[</span><span class=mi>0</span><span class=p>:</span><span class=mi>3</span><span class=p>]</span> <span class=nx>or</span> <span class=nx>slice</span><span class=p>[</span><span class=mi>0</span><span class=p>:</span><span class=mi>3</span><span class=p>]</span>   <span class=c1>// 通过下标获取数组或切片的一部分
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>slice</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>}</span>  <span class=c1>// 使用字面量初始化新切片
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>slice</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>10</span><span class=p>)</span> <span class=c1>// 使用关键字 make 创建切片
</span></span></span></code></pre></td></tr></table></div></div></div><h4 id=使用下标><a href=#使用下标 class=anchor-link><svg viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:使用下标 class=headings>使用下标</a></h4><p>使用下标初始化切片不会复制原数组或者原切片中的数据，它只会创建一个指向原数组的切片结构体，所以修改新切片的数据也会修改原切片。这种操作是所有创建切片的方法中最为底层的。</p><h4 id=使用字面量><a href=#使用字面量 class=anchor-link><svg viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:使用字面量 class=headings>使用字面量</a></h4><p>当我们使用字面量<code>[]int{1, 2, 3}</code>创建新的切片时，<a href=https://github.com/golang/go/blob/4c50f9162cafaccc1ab1bc26b0dea18f124b536d/src/cmd/compile/internal/walk/complit.go#L288 target=_blank rel=noopener>cmd/compile/internal/walk.slicelit</a> 函数会在编译期间将它展开成如下所示的代码片段：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 根据切片元素数量创建底层数组
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>vstat</span> <span class=p>[</span><span class=mi>3</span><span class=p>]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=c1>// 将字面量元素存储到初始化的数组中
</span></span></span><span class=line><span class=cl><span class=c1>// 如 vstat[0] = 1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>vstat</span> <span class=p>=</span> <span class=nx>constpart</span><span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=c1>// 创建一个指向 [3]int 类型的数组指针
</span></span></span><span class=line><span class=cl><span class=c1>// 并在堆上为其分配内存
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>vauto</span> <span class=o>*</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span><span class=kt>int</span> <span class=p>=</span> <span class=nb>new</span><span class=p>([</span><span class=mi>3</span><span class=p>]</span><span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// 将数组 vstat 复制到 vauto 指向的数组
</span></span></span><span class=line><span class=cl><span class=c1>// 注意，Go 语言的数组名是值而非 C 中的隐式指针
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>*</span><span class=nx>vauto</span> <span class=p>=</span> <span class=nx>vstat</span>
</span></span><span class=line><span class=cl><span class=nx>vauto</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nx>dynamic</span> <span class=nx>part</span>
</span></span><span class=line><span class=cl><span class=c1>// 通过 [:] 操作获取一个底层使用 vauto 的切片                          
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>slice</span> <span class=o>:=</span> <span class=nx>vauto</span><span class=p>[:]</span>               
</span></span></code></pre></td></tr></table></div></div></div><p>最后一步实际上就是使用下标创建切片。</p><h4 id=使用-make><a href=#使用-make class=anchor-link><svg viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:使用-make class=headings>使用 make</a></h4><p>与其他两种方法相比，使用<code>make</code>关键字创建切片时，很多工作需要运行时的参与。类型检查期间的 <a href=https://github.com/golang/go/blob/4e548f2c8e489a408033c8aab336077b16bc8cf7/src/cmd/compile/internal/typecheck/typecheck.go#L218 target=_blank rel=noopener>cmd/compile/internal/typecheck.typecheck1</a> 函数会校验<code>len</code>是否传入，以及<code>cap</code>是否大于或等于<code>len</code>。</p><p>随后 <a href=https://github.com/golang/go/blob/4c50f9162cafaccc1ab1bc26b0dea18f124b536d/src/cmd/compile/internal/walk/builtin.go#L400 target=_blank rel=noopener>cmd/compile/internal/walk.walkMakeSlice</a> 会根据切片的大小以及是否发生内存逃逸进行不同的处理：如果当前的切片不会发生逃逸并且切片非常小的时候，<code>make([]int, 3, 4)</code> 会在编译阶段被直接转换成如下所示的代码：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>arr</span> <span class=p>[</span><span class=mi>4</span><span class=p>]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=nx>n</span> <span class=o>:=</span> <span class=nx>arr</span><span class=p>[:</span><span class=mi>3</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div></div><p>而当切片发生逃逸或者非常大时，运行时需要 <a href=https://github.com/golang/go/blob/4c50f9162cafaccc1ab1bc26b0dea18f124b536d/src/runtime/slice.go#L92 target=_blank rel=noopener>runtime.makeslice</a> 在堆上初始化切片：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>makeslice</span><span class=p>(</span><span class=nx>et</span> <span class=o>*</span><span class=nx>_type</span><span class=p>,</span> <span class=nx>len</span><span class=p>,</span> <span class=nx>cap</span> <span class=kt>int</span><span class=p>)</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 计算切片占用的内存空间
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 内存空间 = 元素大小 * 切片容量
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>mem</span><span class=p>,</span> <span class=nx>overflow</span> <span class=o>:=</span> <span class=nx>math</span><span class=p>.</span><span class=nf>MulUintptr</span><span class=p>(</span><span class=nx>et</span><span class=p>.</span><span class=nx>size</span><span class=p>,</span> <span class=nb>uintptr</span><span class=p>(</span><span class=nx>cap</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 检查内存是否发生溢出或超出最大可分配内存
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 长度是否小于 0 或长度是否大于容量
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=nx>overflow</span> <span class=o>||</span> <span class=nx>mem</span> <span class=p>&gt;</span> <span class=nx>maxAlloc</span> <span class=o>||</span> <span class=nx>len</span> <span class=p>&lt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=nx>len</span> <span class=p>&gt;</span> <span class=nx>cap</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>mem</span><span class=p>,</span> <span class=nx>overflow</span> <span class=o>:=</span> <span class=nx>math</span><span class=p>.</span><span class=nf>MulUintptr</span><span class=p>(</span><span class=nx>et</span><span class=p>.</span><span class=nx>size</span><span class=p>,</span> <span class=nb>uintptr</span><span class=p>(</span><span class=nx>len</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>overflow</span> <span class=o>||</span> <span class=nx>mem</span> <span class=p>&gt;</span> <span class=nx>maxAlloc</span> <span class=o>||</span> <span class=nx>len</span> <span class=p>&lt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>panicmakeslicelen</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nf>panicmakeslicecap</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 申请一块连续的内存空间
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=nf>mallocgc</span><span class=p>(</span><span class=nx>mem</span><span class=p>,</span> <span class=nx>et</span><span class=p>,</span> <span class=kc>true</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><p>在之前版本的 Go 语言中，该函数最后会将数组指针、长度和容量合成一个 <a href=https://github.com/golang/go/blob/4c50f9162cafaccc1ab1bc26b0dea18f124b536d/src/runtime/slice.go#L15 target=_blank rel=noopener>runtime.slice</a> 结构体。但是从 <a href=https://github.com/golang/go/commit/020a18c545bf49ffc087ca93cd238195d8dcc411#diff-d9238ca551e72b3a80da9e0da10586a4 target=_blank rel=noopener>cmd/compile: move slice construction to callers of makeslice</a> 提交之后，这项工作就交给了函数的调用方。后者会在编译期间构建切片结构体，而 <a href=https://github.com/golang/go/blob/4c50f9162cafaccc1ab1bc26b0dea18f124b536d/src/runtime/slice.go#L92 target=_blank rel=noopener>runtime.makeslice</a> 仅返回指向底层数组的指针。</p><h3 id=访问元素><a href=#访问元素 class=anchor-link><svg viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:访问元素 class=headings>访问元素</a></h3><p>使用<code>len</code>和<code>cap</code>获取长度或者容量是切片最常见的操作，编译器将这它们看成两种特殊操作，即 <a href=https://github.com/golang/go/blob/4c50f9162cafaccc1ab1bc26b0dea18f124b536d/src/cmd/compile/internal/typecheck/typecheck.go#L393 target=_blank rel=noopener>OLEN 和 OCAP</a>。</p><p>在编译期间，对切片中元素的访问操作 <a href=https://github.com/golang/go/blob/4c50f9162cafaccc1ab1bc26b0dea18f124b536d/src/cmd/compile/internal/typecheck/typecheck.go#L360 target=_blank rel=noopener>OINDEX</a> 会被转换成对地址的直接访问，而包含<code>range</code>关键字的遍历则被转换成形式更简单的循环。</p><h3 id=追加和扩容><a href=#追加和扩容 class=anchor-link><svg viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:追加和扩容 class=headings>追加和扩容</a></h3><p>如果 <a href=https://github.com/golang/go/blob/4c50f9162cafaccc1ab1bc26b0dea18f124b536d/src/cmd/compile/internal/ssagen/ssa.go#L3511 target=_blank rel=noopener>append</a> 返回的新切片不会覆盖原切片：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// new_slice := append(s, 1, 2, 3)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>ptr</span><span class=p>,</span> <span class=nx>len</span><span class=p>,</span> <span class=nx>cap</span> <span class=o>:=</span> <span class=nx>s</span>
</span></span><span class=line><span class=cl><span class=nx>len</span> <span class=o>+=</span> <span class=mi>3</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nb>uint</span><span class=p>(</span><span class=nx>len</span><span class=p>)</span> <span class=p>&gt;</span> <span class=nb>uint</span><span class=p>(</span><span class=nx>cap</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>ptr</span><span class=p>,</span> <span class=nx>len</span><span class=p>,</span> <span class=nx>cap</span> <span class=p>=</span> <span class=nf>growslice</span><span class=p>(</span><span class=nx>ptr</span><span class=p>,</span> <span class=nx>len</span><span class=p>,</span> <span class=nx>cap</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=nx>typ</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Note that len is unmodified by growslice.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// with write barriers, if needed:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>*</span><span class=p>(</span><span class=nx>ptr</span><span class=o>+</span><span class=p>(</span><span class=nx>len</span><span class=o>-</span><span class=mi>3</span><span class=p>))</span> <span class=p>=</span> <span class=nx>e1</span>
</span></span><span class=line><span class=cl><span class=o>*</span><span class=p>(</span><span class=nx>ptr</span><span class=o>+</span><span class=p>(</span><span class=nx>len</span><span class=o>-</span><span class=mi>2</span><span class=p>))</span> <span class=p>=</span> <span class=nx>e2</span>
</span></span><span class=line><span class=cl><span class=o>*</span><span class=p>(</span><span class=nx>ptr</span><span class=o>+</span><span class=p>(</span><span class=nx>len</span><span class=o>-</span><span class=mi>1</span><span class=p>))</span> <span class=p>=</span> <span class=nx>e3</span>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=nf>makeslice</span><span class=p>(</span><span class=nx>ptr</span><span class=p>,</span> <span class=nx>len</span><span class=p>,</span> <span class=nx>cap</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div></div><p>如果 <a href=https://github.com/golang/go/blob/4c50f9162cafaccc1ab1bc26b0dea18f124b536d/src/cmd/compile/internal/ssagen/ssa.go#L3511 target=_blank rel=noopener>append</a> 返回的切片会覆盖原切片：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// s = append(s, 1, 2, 3)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>a</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>s</span>
</span></span><span class=line><span class=cl><span class=nx>ptr</span><span class=p>,</span> <span class=nx>len</span><span class=p>,</span> <span class=nx>cap</span> <span class=o>:=</span> <span class=nx>s</span>
</span></span><span class=line><span class=cl><span class=nx>len</span> <span class=o>+=</span> <span class=mi>3</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nb>uint</span><span class=p>(</span><span class=nx>len</span><span class=p>)</span> <span class=p>&gt;</span> <span class=nb>uint</span><span class=p>(</span><span class=nx>cap</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>ptr</span><span class=p>,</span> <span class=nx>len</span><span class=p>,</span> <span class=nx>cap</span> <span class=p>=</span> <span class=nf>growslice</span><span class=p>(</span><span class=nx>ptr</span><span class=p>,</span> <span class=nx>len</span><span class=p>,</span> <span class=nx>cap</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=nx>typ</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>vardef</span><span class=p>(</span><span class=nx>a</span><span class=p>)</span>    <span class=c1>// if necessary, advise liveness we are writing a new a
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>*</span><span class=nx>a</span><span class=p>.</span><span class=nx>cap</span> <span class=p>=</span> <span class=nx>cap</span> <span class=c1>// write before ptr to avoid a spill
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>*</span><span class=nx>a</span><span class=p>.</span><span class=nx>ptr</span> <span class=p>=</span> <span class=nx>ptr</span> <span class=c1>// with write barrier
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=o>*</span><span class=nx>a</span><span class=p>.</span><span class=nx>len</span> <span class=p>=</span> <span class=nx>len</span>
</span></span><span class=line><span class=cl><span class=c1>// with write barriers, if needed:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>*</span><span class=p>(</span><span class=nx>ptr</span><span class=o>+</span><span class=p>(</span><span class=nx>len</span><span class=o>-</span><span class=mi>3</span><span class=p>))</span> <span class=p>=</span> <span class=nx>e1</span>
</span></span><span class=line><span class=cl><span class=o>*</span><span class=p>(</span><span class=nx>ptr</span><span class=o>+</span><span class=p>(</span><span class=nx>len</span><span class=o>-</span><span class=mi>2</span><span class=p>))</span> <span class=p>=</span> <span class=nx>e2</span>
</span></span><span class=line><span class=cl><span class=o>*</span><span class=p>(</span><span class=nx>ptr</span><span class=o>+</span><span class=p>(</span><span class=nx>len</span><span class=o>-</span><span class=mi>1</span><span class=p>))</span> <span class=p>=</span> <span class=nx>e3</span>
</span></span></code></pre></td></tr></table></div></div></div><p>两者的逻辑其实差不多，最大的区别在于得到的新切片是否会赋值回原变量。</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20240721231049.png alt=20240721231049></p><p>扩容是为切片分配新的内存空间并复制原切片中元素的过程，<a href=https://github.com/golang/go/blob/4c50f9162cafaccc1ab1bc26b0dea18f124b536d/src/runtime/slice.go#L155 target=_blank rel=noopener>runtime.growslice</a> 函数最终会返回一个新的切片，其中包含了新的数组指针、大小和容量。<a href=https://github.com/golang/go/blob/4c50f9162cafaccc1ab1bc26b0dea18f124b536d/src/runtime/slice.go#L267 target=_blank rel=noopener>runtime.nextslicecap</a> 则根据切片的期望容量和当前容量选择不同的策略进行扩容：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// nextslicecap computes the next appropriate slice length.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>nextslicecap</span><span class=p>(</span><span class=nx>newLen</span><span class=p>,</span> <span class=nx>oldCap</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>newcap</span> <span class=o>:=</span> <span class=nx>oldCap</span>
</span></span><span class=line><span class=cl>    <span class=nx>doublecap</span> <span class=o>:=</span> <span class=nx>newcap</span> <span class=o>+</span> <span class=nx>newcap</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>newLen</span> <span class=p>&gt;</span> <span class=nx>doublecap</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>newLen</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kd>const</span> <span class=nx>threshold</span> <span class=p>=</span> <span class=mi>256</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>oldCap</span> <span class=p>&lt;</span> <span class=nx>threshold</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>doublecap</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Transition from growing 2x for small slices
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// to growing 1.25x for large slices. This formula
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// gives a smooth-ish transition between the two.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>newcap</span> <span class=o>+=</span> <span class=p>(</span><span class=nx>newcap</span> <span class=o>+</span> <span class=mi>3</span><span class=o>*</span><span class=nx>threshold</span><span class=p>)</span> <span class=o>&gt;&gt;</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// We need to check `newcap &gt;= newLen` and whether `newcap` overflowed.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// newLen is guaranteed to be larger than zero, hence
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// when newcap overflows then `uint(newcap) &gt; uint(newLen)`.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// This allows to check for both with the same comparison.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=nb>uint</span><span class=p>(</span><span class=nx>newcap</span><span class=p>)</span> <span class=o>&gt;=</span> <span class=nb>uint</span><span class=p>(</span><span class=nx>newLen</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Set newcap to the requested cap when
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// the newcap calculation overflowed.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=nx>newcap</span> <span class=o>&lt;=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>newLen</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>newcap</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><p>当我们执行如下代码时，会触发 <a href=https://github.com/golang/go/blob/4c50f9162cafaccc1ab1bc26b0dea18f124b536d/src/runtime/slice.go#L155 target=_blank rel=noopener>runtime.growslice</a> 函数扩容<code>arr</code>切片并传入期望的新容量 5，此时期望分配的内存大小为 40 字节。不过运行时会调用 <a href=https://github.com/golang/go/blob/4c50f9162cafaccc1ab1bc26b0dea18f124b536d/src/runtime/msize_noallocheaders.go#L17 target=_blank rel=noopener>runtime.roundupsize</a> 将切片占用的内存大小对齐到 48 字节，因此新切片的容量为 48 / 8 = 6：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>arr</span> <span class=p>[]</span><span class=kt>int64</span>
</span></span><span class=line><span class=cl><span class=nx>arr</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>arr</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div></div><h3 id=复制切片><a href=#复制切片 class=anchor-link><svg viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:复制切片 class=headings>复制切片</a></h3><p>无论是编译期间复制还是运行时复制，两种复制方式都会通过 <a href=https://github.com/golang/go/blob/4c50f9162cafaccc1ab1bc26b0dea18f124b536d/src/runtime/memmove_386.s#L34 target=_blank rel=noopener>runtime.memmove</a> 将整块内存的内容复制到目标的内存区域中：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20240721231126.png alt=20240721231126></p><p>相比于依次复制元素，这种方式能够提供更好的性能。不过，整块复制内存仍然会占用非常多的资源，对大切片执行复制操作时一定要注意对性能的影响。</p><h2 id=哈希表><a href=#哈希表 class=anchor-link><svg viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:哈希表 class=headings>哈希表</a></h2><h3 id=设计原理><a href=#设计原理 class=anchor-link><svg viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:设计原理 class=headings>设计原理</a></h3><p>哈希表是计算机科学中的最重要数据结构之一，这不仅因为它 𝑂(1) 的读写性能非常优秀，还因为它提供了键值之间的映射。想要实现一个性能优异的哈希表，需要注意两个关键点 —— 哈希函数和冲突解决方法。</p><p>哈希函数映射的结果一定要尽可能均匀，结果不均匀的哈希函数会带来更多的哈希冲突以及更差的读写性能。</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20240721231215.png alt=20240721231215></p><p>解决哈希冲突的常见方法有开放寻址法和拉链法。</p><h4 id=开放寻址法><a href=#开放寻址法 class=anchor-link><svg viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:开放寻址法 class=headings>开放寻址法</a></h4><p>这种方法的核心思想是依次探测和比较数组中的元素以判断目标键值对是否存在于哈希表中，此时实现哈希表底层的数据结构是数组。不过因为数组的长度有限，向哈希表写入键值对时会从如下的索引开始遍历：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>index</span> <span class=o>:=</span> <span class=nf>hash</span><span class=p>(</span><span class=s>&#34;Key3&#34;</span><span class=p>)</span> <span class=o>%</span> <span class=nx>array</span><span class=p>.</span><span class=nx>len</span>
</span></span></code></pre></td></tr></table></div></div></div><p>如下图所示，当 Key3 与已经存入哈希表中的两个键值对 Key1 和 Key2 发生冲突时，Key3 会被写入 Key2 后面的空闲位置。当我们再去读取 Key3 对应的值时就会先获取键的哈希并取模，这会先帮助我们找到 Key1，找到 Key1 后发现它与 Key 3 不相等，所以会继续查找后面的元素，直到内存为空或者找到目标元素。</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20240721231248.png alt=20240721231248></p><p>开放寻址法中对性能影响最大的是装载因子，它是数组中元素的数量与数组大小的比值。随着装载因子的增加，线性探测的平均用时就会逐渐增加，这会影响哈希表的读写性能。当装载率超过 70% 之后，哈希表的性能就会急剧下降，而一旦装载率达到 100%，整个哈希表就会完全失效，这时查找和插入任意元素的时间复杂度都是 𝑂(𝑛) 的，即需要遍历数组中的全部元素。</p><h4 id=拉链法><a href=#拉链法 class=anchor-link><svg viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:拉链法 class=headings>拉链法</a></h4><p>大多数编程语言都采用拉链法，它的平均查找时间较短且可以动态申请内存以减少内存占用。实现拉链法一般会使用数组加上链表，我们可以将它看成可以扩展的二维数组：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20240721231307.png alt=20240721231307></p><p>和开放地址法一样，选择桶的方式是直接对哈希函数返回的结果取模：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>index</span> <span class=o>:=</span> <span class=nf>hash</span><span class=p>(</span><span class=s>&#34;Key6&#34;</span><span class=p>)</span> <span class=o>%</span> <span class=nx>array</span><span class=p>.</span><span class=nx>len</span>
</span></span></code></pre></td></tr></table></div></div></div><p>如上图所示，Key 6 的索引为 2，此时遍历 2 号桶中的链表时可能会遇到两种情况：</p><ul><li>找到键相同的键值对，则读取/写入键对应的值；</li><li>未找到键相同的键值对，则返回该键不存在（读取）/在链表的末尾追加新的键值对（写入）；</li></ul><p>拉链法的装载因子等于元素数量除以桶的数量，装载因子越大（一般不会超过 1），读写性能就越差。当装载因子较大时会触发哈希的扩容，即创建更多的桶来存储哈希中的元素，保证性能不会出现严重的下降。</p><h3 id=数据结构><a href=#数据结构 class=anchor-link><svg viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:数据结构 class=headings>数据结构</a></h3><p>Go 语言运行时同时使用了多个数据结构组合表示哈希表，其中 <a href=https://github.com/golang/go/blob/4c50f9162cafaccc1ab1bc26b0dea18f124b536d/src/runtime/map.go#L117 target=_blank rel=noopener>runtime.hmap</a> 是最核心的结构体：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>hmap</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>count</span>     <span class=kt>int</span>              <span class=c1>// 当前哈希表中的元素数量
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>flags</span>     <span class=kt>uint8</span>
</span></span><span class=line><span class=cl>    <span class=nx>B</span>         <span class=kt>uint8</span>            <span class=c1>// 当前哈希表的桶数量为 2 ^ B
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>noverflow</span> <span class=kt>uint16</span>           <span class=c1>// 使用的溢出桶数量
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>hash0</span>     <span class=kt>uint32</span>           <span class=c1>// 为哈希函数引入随机性种子
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=nx>buckets</span>    <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span>  <span class=c1>// 指向 bmap 数组的指针
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>oldbuckets</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span>  <span class=c1>// 扩容时保存的旧桶，大小为当前的一半
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>nevacuate</span>  <span class=kt>uintptr</span>         <span class=c1>// 标识扩容进度，小于此地址的桶已迁移完成
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=nx>extra</span> <span class=o>*</span><span class=nx>mapextra</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>mapextra</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>overflow</span>    <span class=o>*</span><span class=p>[]</span><span class=o>*</span><span class=nx>bmap</span>       <span class=c1>// 已使用的溢出桶地址
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>oldoverflow</span> <span class=o>*</span><span class=p>[]</span><span class=o>*</span><span class=nx>bmap</span>       <span class=c1>// 扩容时旧桶使用的溢出桶地址
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>nextOverflow</span> <span class=o>*</span><span class=nx>bmap</span>         <span class=c1>// 指向下一个空闲的溢出桶
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20240721231338.png alt=20240721231338></p><p>如上图所示哈希表 <a href=https://github.com/golang/go/blob/4c50f9162cafaccc1ab1bc26b0dea18f124b536d/src/runtime/map.go#L117 target=_blank rel=noopener>runtime.hmap</a> 的桶是 <a href=https://github.com/golang/go/blob/4c50f9162cafaccc1ab1bc26b0dea18f124b536d/src/runtime/map.go#L151 target=_blank rel=noopener>runtime.bmap</a>，后者能存储 8 个键值对。当哈希表中存储的数据过多，单个桶已经装满时就会使用<code>extra.nextOverflow</code>中的桶存储溢出的数据。</p><p>上述两种不同的桶在内存中是连续存储的，我们在这里将它们分别称为正常桶和溢出桶，上图中黄色的 <a href=https://github.com/golang/go/blob/4c50f9162cafaccc1ab1bc26b0dea18f124b536d/src/runtime/map.go#L151 target=_blank rel=noopener>runtime.bmap</a> 就是正常桶，绿色的 <a href=https://github.com/golang/go/blob/4c50f9162cafaccc1ab1bc26b0dea18f124b536d/src/runtime/map.go#L151 target=_blank rel=noopener>runtime.bmap</a> 是溢出桶。</p><blockquote><p>当 map 中找不到可用的溢出桶时，<a href=https://github.com/golang/go/blob/4c50f9162cafaccc1ab1bc26b0dea18f124b536d/src/runtime/map.go#L247 target=_blank rel=noopener>runtime.newoverflow</a> 会通过 <a href=https://github.com/golang/go/blob/4c50f9162cafaccc1ab1bc26b0dea18f124b536d/src/runtime/malloc.go#L1389 target=_blank rel=noopener>newobject</a> 新建溢出桶，此时正常桶和溢出桶在内存中的存储空间就不再连续了。</p></blockquote><p>桶的结构体 <a href=https://github.com/golang/go/blob/4c50f9162cafaccc1ab1bc26b0dea18f124b536d/src/runtime/map.go#L151 target=_blank rel=noopener>runtime.bmap</a> 在 Go 语言源代码中的定义只包含一个简单的<code>tophash</code>字段，它存储了键的哈希值的高 8 位。通过比较<code>tophash</code>可以减少访问键值对的次数以提高性能。</p><p>在运行期间，该结构体其实不止包含<code>tophash</code>字段，我们可以根据编译期间的 <a href=https://github.com/golang/go/blob/4c50f9162cafaccc1ab1bc26b0dea18f124b536d/src/cmd/compile/internal/reflectdata/reflect.go#L91 target=_blank rel=noopener>cmd/compile/internal/reflectdata.MapBucketType</a> 函数重建它的结构：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>bmap</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>topbits</span>  <span class=p>[</span><span class=mi>8</span><span class=p>]</span><span class=kt>uint8</span>
</span></span><span class=line><span class=cl>    <span class=nx>keys</span>     <span class=p>[</span><span class=mi>8</span><span class=p>]</span><span class=nx>keytype</span>
</span></span><span class=line><span class=cl>    <span class=nx>values</span>   <span class=p>[</span><span class=mi>8</span><span class=p>]</span><span class=nx>valuetype</span>
</span></span><span class=line><span class=cl>    <span class=nx>overflow</span> <span class=kt>uintptr</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20240721231404.png alt=20240721231404></p><h3 id=初始化-2><a href=#初始化-2 class=anchor-link><svg viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:初始化-2 class=headings>初始化</a></h3><h4 id=字面量><a href=#字面量 class=anchor-link><svg viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:字面量 class=headings>字面量</a></h4><p>当哈希表中的元素数量少于或者等于 25 个时，编译器会将字面量初始化的结构体转换成以下的代码，将所有的键值对一次加入到哈希表中：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>hash</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>hash</span><span class=p>[</span><span class=s>&#34;1&#34;</span><span class=p>]</span> <span class=p>=</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl><span class=nx>hash</span><span class=p>[</span><span class=s>&#34;3&#34;</span><span class=p>]</span> <span class=p>=</span> <span class=mi>4</span>
</span></span><span class=line><span class=cl><span class=nx>hash</span><span class=p>[</span><span class=s>&#34;5&#34;</span><span class=p>]</span> <span class=p>=</span> <span class=mi>6</span>
</span></span></code></pre></td></tr></table></div></div></div><p>一旦哈希表中元素的数量超过了 25 个，编译器会创建两个数组分别存储键和值，这些键值对会通过如下所示的<code>for</code>循环加入哈希：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>hash</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>26</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>vstatk</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;1&#34;</span><span class=p>,</span> <span class=s>&#34;2&#34;</span><span class=p>,</span> <span class=s>&#34;3&#34;</span><span class=p>,</span> <span class=o>...</span> <span class=err>，</span> <span class=s>&#34;26&#34;</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>vstatv</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=o>...</span> <span class=p>,</span> <span class=mi>26</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>vstak</span><span class=p>);</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>hash</span><span class=p>[</span><span class=nx>vstatk</span><span class=p>[</span><span class=nx>i</span><span class=p>]]</span> <span class=p>=</span> <span class=nx>vstatv</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><p>无论使用哪种方法，使用字面量初始化的过程都会使用 Go 语言中的关键字<code>make</code>来创建新的哈希并通过最原始的<code>[]</code>语法向哈希追加元素。</p><h4 id=运行时><a href=#运行时 class=anchor-link><svg viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:运行时 class=headings>运行时</a></h4><p>当创建的哈希被分配到栈上并且其容量小于<code>BUCKETSIZE = 8</code>时，<a href=https://github.com/golang/go/blob/4c50f9162cafaccc1ab1bc26b0dea18f124b536d/src/cmd/compile/internal/walk/builtin.go#L304 target=_blank rel=noopener>cmd/compile/internal/walk.walkMakeSlice</a> 函数会在编译阶段快速初始化哈希，这是编译器对小容量的哈希所做的优化：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>h</span> <span class=o>*</span><span class=nx>hmap</span>
</span></span><span class=line><span class=cl><span class=c1>// Allocate hmap on stack
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>hv</span> <span class=nx>hmap</span>
</span></span><span class=line><span class=cl><span class=nx>h</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>hv</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nx>hint</span> <span class=o>&lt;=</span> <span class=nx>BUCKETSIZE</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>bv</span> <span class=nx>bmap</span>
</span></span><span class=line><span class=cl>    <span class=nx>b</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>bv</span>
</span></span><span class=line><span class=cl>    <span class=nx>h</span><span class=p>.</span><span class=nx>buckets</span> <span class=p>=</span> <span class=nx>b</span>
</span></span><span class=line><span class=cl>    <span class=nx>h</span><span class=p>.</span><span class=nx>hash0</span> <span class=p>=</span> <span class=nf>rand32</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><p>除此之外，所有初始化<code>map</code>的语句都会被转换成 <a href=https://github.com/golang/go/blob/4c50f9162cafaccc1ab1bc26b0dea18f124b536d/src/runtime/map.go#L305 target=_blank rel=noopener>runtime.makemap</a>：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>makemap</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>maptype</span><span class=p>,</span> <span class=nx>hint</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>h</span> <span class=o>*</span><span class=nx>hmap</span><span class=p>)</span> <span class=o>*</span><span class=nx>hmap</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 计算哈希占用的内存是否溢出或者超出能分配的最大值
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>mem</span><span class=p>,</span> <span class=nx>overflow</span> <span class=o>:=</span> <span class=nx>math</span><span class=p>.</span><span class=nf>MulUintptr</span><span class=p>(</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>hint</span><span class=p>),</span> <span class=nx>t</span><span class=p>.</span><span class=nx>Bucket</span><span class=p>.</span><span class=nx>Size_</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>overflow</span> <span class=o>||</span> <span class=nx>mem</span> <span class=p>&gt;</span> <span class=nx>maxAlloc</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>hint</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>h</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>h</span> <span class=p>=</span> <span class=nb>new</span><span class=p>(</span><span class=nx>hmap</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 获取一个随机的哈希种子
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>h</span><span class=p>.</span><span class=nx>hash0</span> <span class=p>=</span> <span class=nb>uint32</span><span class=p>(</span><span class=nf>rand</span><span class=p>())</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>B</span> <span class=o>:=</span> <span class=nb>uint8</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 根据传入的 hint（make(map[k]v, hint)）计算出至少需要的桶数量；
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=nf>overLoadFactor</span><span class=p>(</span><span class=nx>hint</span><span class=p>,</span> <span class=nx>B</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>B</span><span class=o>++</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>h</span><span class=p>.</span><span class=nx>B</span> <span class=p>=</span> <span class=nx>B</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>h</span><span class=p>.</span><span class=nx>B</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kd>var</span> <span class=nx>nextOverflow</span> <span class=o>*</span><span class=nx>bmap</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 使用 runtime.makeBucketArray 创建用于保存桶的数组
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>h</span><span class=p>.</span><span class=nx>buckets</span><span class=p>,</span> <span class=nx>nextOverflow</span> <span class=p>=</span> <span class=nf>makeBucketArray</span><span class=p>(</span><span class=nx>t</span><span class=p>,</span> <span class=nx>h</span><span class=p>.</span><span class=nx>B</span><span class=p>,</span> <span class=kc>nil</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>nextOverflow</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>h</span><span class=p>.</span><span class=nx>extra</span> <span class=p>=</span> <span class=nb>new</span><span class=p>(</span><span class=nx>mapextra</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=nx>h</span><span class=p>.</span><span class=nx>extra</span><span class=p>.</span><span class=nx>nextOverflow</span> <span class=p>=</span> <span class=nx>nextOverflow</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>h</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><p><a href=https://github.com/golang/go/blob/4c50f9162cafaccc1ab1bc26b0dea18f124b536d/src/runtime/map.go#L346 target=_blank rel=noopener>runtime.makeBucketArray</a> 会根据<code>B</code>计算出需要创建的桶数并在内存中分配一片连续的空间用于存储数据：</p><ul><li>当桶的数量小于 $2^4$ 时，由于数据较少、使用溢出桶的可能性较低，会省略创建的过程以减少额外开销；</li><li>当桶的数量大于 $2^4$  时，会额外创建 $2^{B-4}$ 个溢出桶。</li></ul><h3 id=读写操作><a href=#读写操作 class=anchor-link><svg viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:读写操作 class=headings>读写操作</a></h3><h4 id=访问><a href=#访问 class=anchor-link><svg viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:访问 class=headings>访问</a></h4><p><code>v := hash[key]</code> 操作会先被转化为 <a href=https://github.com/golang/go/blob/4c50f9162cafaccc1ab1bc26b0dea18f124b536d/src/runtime/map.go#L396 target=_blank rel=noopener>runtime.mapaccess1</a>：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>mapaccess1</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>maptype</span><span class=p>,</span> <span class=nx>h</span> <span class=o>*</span><span class=nx>hmap</span><span class=p>,</span> <span class=nx>key</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>)</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl>    <span class=c1>// map 不支持并发读写
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=nx>h</span><span class=p>.</span><span class=nx>flags</span><span class=o>&amp;</span><span class=nx>hashWriting</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>fatal</span><span class=p>(</span><span class=s>&#34;concurrent map read and map write&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 通过哈希函数和种子获取 key 对应的哈希值
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>hash</span> <span class=o>:=</span> <span class=nx>t</span><span class=p>.</span><span class=nf>Hasher</span><span class=p>(</span><span class=nx>key</span><span class=p>,</span> <span class=nb>uintptr</span><span class=p>(</span><span class=nx>h</span><span class=p>.</span><span class=nx>hash0</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=c1>// m 为桶掩码，等于 1&lt;&lt;B - 1
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>m</span> <span class=o>:=</span> <span class=nf>bucketMask</span><span class=p>(</span><span class=nx>h</span><span class=p>.</span><span class=nx>B</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>// hash&amp;m 为 key 所在桶的编号
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 通过指针计算目标桶的位置
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>b</span> <span class=o>:=</span> <span class=p>(</span><span class=o>*</span><span class=nx>bmap</span><span class=p>)(</span><span class=nf>add</span><span class=p>(</span><span class=nx>h</span><span class=p>.</span><span class=nx>buckets</span><span class=p>,</span> <span class=p>(</span><span class=nx>hash</span><span class=o>&amp;</span><span class=nx>m</span><span class=p>)</span><span class=o>*</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>BucketSize</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 获取 key 对应的哈希值的高八位
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>top</span> <span class=o>:=</span> <span class=nf>tophash</span><span class=p>(</span><span class=nx>hash</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>bucketloop</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 依次遍历正常桶和溢出桶中的数据
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>;</span> <span class=nx>b</span> <span class=o>!=</span> <span class=kc>nil</span><span class=p>;</span> <span class=nx>b</span> <span class=p>=</span> <span class=nx>b</span><span class=p>.</span><span class=nf>overflow</span><span class=p>(</span><span class=nx>t</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=nb>uintptr</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>bucketCnt</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 将 key 对应的哈希值的高八位与桶中存储的 tophash 进行比较
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>if</span> <span class=nx>b</span><span class=p>.</span><span class=nx>tophash</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>!=</span> <span class=nx>top</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=nx>b</span><span class=p>.</span><span class=nx>tophash</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>==</span> <span class=nx>emptyRest</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=k>break</span> <span class=nx>bucketloop</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=k>continue</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 若 tophash 相等，则移动指针得到桶中存储的键 k
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>// 其中，dataOffset 是桶中第一个键相对于 bmap 起始地址的偏移量
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nx>k</span> <span class=o>:=</span> <span class=nf>add</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>b</span><span class=p>),</span> <span class=nx>dataOffset</span><span class=o>+</span><span class=nx>i</span><span class=o>*</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>KeySize</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 再将 key 与 k 进行比较，若相等则读取指向目标值的指针并返回
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>if</span> <span class=nx>t</span><span class=p>.</span><span class=nx>Key</span><span class=p>.</span><span class=nf>Equal</span><span class=p>(</span><span class=nx>key</span><span class=p>,</span> <span class=nx>k</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nx>e</span> <span class=o>:=</span> <span class=nf>add</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>b</span><span class=p>),</span> <span class=nx>dataOffset</span><span class=o>+</span><span class=nx>bucketCnt</span><span class=o>*</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>KeySize</span><span class=p>)</span><span class=o>+</span><span class=nx>i</span><span class=o>*</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>t</span><span class=p>.</span><span class=nx>ValueSize</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=nx>e</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>zeroVal</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><p>如下图所示，正是因为每个桶都是一片连续的内存空间，我们才能通过 <a href=https://github.com/golang/go/blob/4c50f9162cafaccc1ab1bc26b0dea18f124b536d/src/runtime/stubs.go#L15 target=_blank rel=noopener>runtime.add</a> 操作指针以访问桶中存储的键。</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20240721231456.png alt=20240721231456></p><p>另外，选择桶序号时用的是键的哈希值的最低几位（<code>hash&amp;m</code>），而加速访问用的是键的哈希值的高 8 位，这种设计能够减少同一个桶中有大量相等<code>tophash</code>的概率以免影响性能。</p><p><code>v, ok := hash[key]</code>操作则会被转化为 <a href=https://github.com/golang/go/blob/4c50f9162cafaccc1ab1bc26b0dea18f124b536d/src/runtime/map.go#L457 target=_blank rel=noopener>runtime.mapaccess2</a>，它在此基础之上多返回了一个标识键值对是否存在的布尔值。我们能够通过这个布尔值更准确地知道：当<code>v == nil</code>时，<code>v</code> 到底是哈希中存储的元素还是表示该键对应的元素不存在。因此我们在访问哈希表时更推荐使用这种方式判断元素是否存在。</p><h4 id=写入><a href=#写入 class=anchor-link><svg viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:写入 class=headings>写入</a></h4><p><code>hash[k] = v</code>操作会在编译期间被转换成 <a href=https://github.com/golang/go/blob/4c50f9162cafaccc1ab1bc26b0dea18f124b536d/src/runtime/map.go#L579 target=_blank rel=noopener>runtime.mapassign</a>，该函数需要兼顾以下三种情况：</p><ul><li><code>k</code>在桶中存在，返回<code>v</code>在桶中的地址；</li><li><code>k</code>在桶中不存在且桶中有空位，返回<code>k</code>和<code>v</code>应当插入的地址；</li><li><code>k</code>在桶中不存在且桶已满，对当前桶进行扩容然后再返回<code>k</code>和<code>v</code>应当插入的地址。</li></ul><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span><span class=lnt>75
</span><span class=lnt>76
</span><span class=lnt>77
</span><span class=lnt>78
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>mapassign</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>maptype</span><span class=p>,</span> <span class=nx>h</span> <span class=o>*</span><span class=nx>hmap</span><span class=p>,</span> <span class=nx>key</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>)</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 根据 key 计算哈希值
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>hash</span> <span class=o>:=</span> <span class=nx>t</span><span class=p>.</span><span class=nf>hasher</span><span class=p>(</span><span class=nx>key</span><span class=p>,</span> <span class=nb>uintptr</span><span class=p>(</span><span class=nx>h</span><span class=p>.</span><span class=nx>hash0</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>again</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 获取 key 所在的桶序号
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>bucket</span> <span class=o>:=</span> <span class=nx>hash</span> <span class=o>&amp;</span> <span class=nf>bucketMask</span><span class=p>(</span><span class=nx>h</span><span class=p>.</span><span class=nx>B</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>b</span> <span class=o>:=</span> <span class=p>(</span><span class=o>*</span><span class=nx>bmap</span><span class=p>)(</span><span class=nf>add</span><span class=p>(</span><span class=nx>h</span><span class=p>.</span><span class=nx>buckets</span><span class=p>,</span> <span class=nx>bucket</span><span class=o>*</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>BucketSize</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 获取 key 对应的哈希值的高八位
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>top</span> <span class=o>:=</span> <span class=nf>tophash</span><span class=p>(</span><span class=nx>hash</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>inserti</span> <span class=o>*</span><span class=kt>uint8</span>          <span class=c1>// key 的哈希值在 tophash 数组中的索引
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>var</span> <span class=nx>insertk</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span>  <span class=c1>// key 插入的地址
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>var</span> <span class=nx>elem</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span>     <span class=c1>// elem 插入的地址
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>bucketloop</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 遍历所有正常桶和溢出桶
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=nb>uintptr</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>bucketCnt</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 将 key 对应的哈希值的高八位与桶中存储的 tophash 进行比较
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>if</span> <span class=nx>b</span><span class=p>.</span><span class=nx>tophash</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>!=</span> <span class=nx>top</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=c1>// 若不相等，则判断是否为空位
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>if</span> <span class=nf>isEmpty</span><span class=p>(</span><span class=nx>b</span><span class=p>.</span><span class=nx>tophash</span><span class=p>[</span><span class=nx>i</span><span class=p>])</span> <span class=o>&amp;&amp;</span> <span class=nx>inserti</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=c1>// 若为空位，则将其标记为键值对插入的位置
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=nx>inserti</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>b</span><span class=p>.</span><span class=nx>tophash</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>                    <span class=nx>insertk</span> <span class=p>=</span> <span class=nf>add</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>b</span><span class=p>),</span> <span class=nx>dataOffset</span><span class=o>+</span><span class=nx>i</span><span class=o>*</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>KeySize</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                    <span class=nx>elem</span> <span class=p>=</span> <span class=nf>add</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>b</span><span class=p>),</span> <span class=nx>dataOffset</span><span class=o>+</span><span class=nx>bucketCnt</span><span class=o>*</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>KeySize</span><span class=p>)</span><span class=o>+</span><span class=nx>i</span><span class=o>*</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>ValueSize</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=nx>b</span><span class=p>.</span><span class=nx>tophash</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>==</span> <span class=nx>emptyRest</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=k>break</span> <span class=nx>bucketloop</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=c1>// 若 tophash 均不匹配，则跳出内循环
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>continue</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 若 tophash 相等，则移动指针得到桶中存储的键 k
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nx>k</span> <span class=o>:=</span> <span class=nf>add</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>b</span><span class=p>),</span> <span class=nx>dataOffset</span><span class=o>+</span><span class=nx>i</span><span class=o>*</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>KeySize</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 再将 key 与 k 进行比较
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>if</span> <span class=p>!</span><span class=nx>t</span><span class=p>.</span><span class=nx>Key</span><span class=p>.</span><span class=nf>Equal</span><span class=p>(</span><span class=nx>key</span><span class=p>,</span> <span class=nx>k</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>continue</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 通过指针移动得到值的地址并直接返回
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nx>elem</span> <span class=p>=</span> <span class=nf>add</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>b</span><span class=p>),</span> <span class=nx>dataOffset</span><span class=o>+</span><span class=nx>bucketCnt</span><span class=o>*</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>KeySize</span><span class=p>)</span><span class=o>+</span><span class=nx>i</span><span class=o>*</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>ValueSize</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=k>goto</span> <span class=nx>done</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 遍历完正常桶后，将在下一个内循环中遍历溢出桶
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>ovf</span> <span class=o>:=</span> <span class=nx>b</span><span class=p>.</span><span class=nf>overflow</span><span class=p>(</span><span class=nx>t</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>ovf</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nx>b</span> <span class=p>=</span> <span class=nx>ovf</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// inserti 为 nil，说明当前桶和溢出桶已满
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=nx>inserti</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 调用 runtime.newoverflow 创建新桶
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>newb</span> <span class=o>:=</span> <span class=nx>h</span><span class=p>.</span><span class=nf>newoverflow</span><span class=p>(</span><span class=nx>t</span><span class=p>,</span> <span class=nx>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>inserti</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>newb</span><span class=p>.</span><span class=nx>tophash</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=nx>insertk</span> <span class=p>=</span> <span class=nf>add</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>newb</span><span class=p>),</span> <span class=nx>dataOffset</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>elem</span> <span class=p>=</span> <span class=nf>add</span><span class=p>(</span><span class=nx>insertk</span><span class=p>,</span> <span class=nx>bucketCnt</span><span class=o>*</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>KeySize</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 若 key 在哈希表中不存在，则为新键值对规划内存
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=nx>t</span><span class=p>.</span><span class=nf>indirectkey</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>kmem</span> <span class=o>:=</span> <span class=nf>newobject</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>Key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>)(</span><span class=nx>insertk</span><span class=p>)</span> <span class=p>=</span> <span class=nx>kmem</span>
</span></span><span class=line><span class=cl>        <span class=nx>insertk</span> <span class=p>=</span> <span class=nx>kmem</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>t</span><span class=p>.</span><span class=nf>indirectelem</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>vmem</span> <span class=o>:=</span> <span class=nf>newobject</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>Elem</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>)(</span><span class=nx>elem</span><span class=p>)</span> <span class=p>=</span> <span class=nx>vmem</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 通过 runtime.typedmemmove 将 key 移动到对应的内存空间中
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>typedmemmove</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>Key</span><span class=p>,</span> <span class=nx>insertk</span><span class=p>,</span> <span class=nx>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=nx>inserti</span> <span class=p>=</span> <span class=nx>top</span>
</span></span><span class=line><span class=cl>    <span class=nx>h</span><span class=p>.</span><span class=nx>count</span><span class=o>++</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>done</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 返回 key 对应的 elem 地址
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=nx>elem</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><p>由此可见，<a href=https://github.com/golang/go/blob/4c50f9162cafaccc1ab1bc26b0dea18f124b536d/src/runtime/map.go#L579 target=_blank rel=noopener>runtime.mapassign</a> 并不会将值复制到桶中，真正的赋值操作是在编译期间插入的：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=mo>0001</span><span class=mi>8</span> <span class=p>(</span><span class=o>+</span><span class=mi>5</span><span class=p>)</span> <span class=nx>CALL</span> <span class=nx>runtime</span><span class=p>.</span><span class=nf>mapassign_fast64</span><span class=p>(</span><span class=nx>SB</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=mo>00020</span> <span class=p>(</span><span class=mi>5</span><span class=p>)</span> <span class=nx>MOVQ</span> <span class=mi>24</span><span class=p>(</span><span class=nx>SP</span><span class=p>),</span> <span class=nx>DI</span>               <span class=p>;;</span> <span class=nx>DI</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>value</span>
</span></span><span class=line><span class=cl><span class=mo>00026</span> <span class=p>(</span><span class=mi>5</span><span class=p>)</span> <span class=nx>LEAQ</span> <span class=k>go</span><span class=p>.</span><span class=kt>string</span><span class=p>.</span><span class=s>&#34;88&#34;</span><span class=p>(</span><span class=nx>SB</span><span class=p>),</span> <span class=nx>AX</span>   <span class=p>;;</span> <span class=nx>AX</span> <span class=p>=</span> <span class=o>&amp;</span><span class=s>&#34;88&#34;</span>
</span></span><span class=line><span class=cl><span class=mo>00027</span> <span class=p>(</span><span class=mi>5</span><span class=p>)</span> <span class=nx>MOVQ</span> <span class=nx>AX</span><span class=p>,</span> <span class=p>(</span><span class=nx>DI</span><span class=p>)</span>                 <span class=p>;;</span> <span class=o>*</span><span class=nx>DI</span> <span class=p>=</span> <span class=nx>AX</span>
</span></span></code></pre></td></tr></table></div></div></div><p><a href=https://github.com/golang/go/blob/4c50f9162cafaccc1ab1bc26b0dea18f124b536d/src/runtime/map_fast64.go#L93 target=_blank rel=noopener>runtime.mapassign_fast64</a> 与 <a href=https://github.com/golang/go/blob/ac0ba6707c1655ea4316b41d06571a0303cc60eb/src/runtime/map.go#L571 target=_blank rel=noopener>runtime.mapassign</a> 函数的逻辑差不多，我们需要关注的是后面的三行代码。其中<code>24(SP)</code>是该函数返回的值地址，我们通过<code>LEAQ</code>指令将字符串的地址存储到寄存器<code>AX</code>中，<code>MOVQ</code> 指令将字符串<code>"88"</code>存储到了目标地址上从而完成了这次哈希的写入。</p><h4 id=扩容><a href=#扩容 class=anchor-link><svg viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:扩容 class=headings>扩容</a></h4><p>上一节在介绍<code>mapassign</code>时其实省略了其中的扩容操作：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>mapassign</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>maptype</span><span class=p>,</span> <span class=nx>h</span> <span class=o>*</span><span class=nx>hmap</span><span class=p>,</span> <span class=nx>key</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>)</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 哈希的扩容不是一个原子的过程，需要判断当前是否处于扩容状态
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 判断 h.growing() 返回的 oldbuckets 是否非空
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 若 oldbuckets 非空，则说明正在扩容
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 装载因子超过 6.5 或溢出桶过多时触发扩容 hashgrow
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>!</span><span class=nx>h</span><span class=p>.</span><span class=nf>growing</span><span class=p>()</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=nf>overLoadFactor</span><span class=p>(</span><span class=nx>h</span><span class=p>.</span><span class=nx>count</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=nx>h</span><span class=p>.</span><span class=nx>B</span><span class=p>)</span> <span class=o>||</span> <span class=nf>tooManyOverflowBuckets</span><span class=p>(</span><span class=nx>h</span><span class=p>.</span><span class=nx>noverflow</span><span class=p>,</span> <span class=nx>h</span><span class=p>.</span><span class=nx>B</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>hashGrow</span><span class=p>(</span><span class=nx>t</span><span class=p>,</span> <span class=nx>h</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Growing the table invalidates everything, so try again
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>goto</span> <span class=nx>again</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><p>我们可以发现有以下两种情况将触发扩容：</p><ul><li>装载因子超过 6.5：哈希的空间使用率过高，哈希冲突的概率较大；</li><li>溢出桶过多：如果我们持续向哈希中插入数据并将它们全部删除，那么即使哈希表中的装载因子没有超过阈值，溢出桶的数量也会越来越多从而造成缓慢的 <a href=https://github.com/golang/go/issues/16070 target=_blank rel=noopener>内存泄漏</a>。</li></ul><p><a href=https://github.com/golang/go/blob/4c50f9162cafaccc1ab1bc26b0dea18f124b536d/src/runtime/map.go#L1053 target=_blank rel=noopener>runtime.hashGrow</a> 会根据具体情况采取不同的扩容策略：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>hashGrow</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>maptype</span><span class=p>,</span> <span class=nx>h</span> <span class=o>*</span><span class=nx>hmap</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>bigger</span> <span class=o>:=</span> <span class=nb>uint8</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 若装载因子未超过阈值，则说明溢出桶过多触发了扩容
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>!</span><span class=nf>overLoadFactor</span><span class=p>(</span><span class=nx>h</span><span class=p>.</span><span class=nx>count</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=nx>h</span><span class=p>.</span><span class=nx>B</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>bigger</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 扩容规则将是 sameSizeGrow，即等量扩容，h.B 不变
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>h</span><span class=p>.</span><span class=nx>flags</span> <span class=o>|=</span> <span class=nx>sameSizeGrow</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>oldbuckets</span> <span class=o>:=</span> <span class=nx>h</span><span class=p>.</span><span class=nx>buckets</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 创建一组新桶和预创建的溢出桶
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 若装载因子超过阈值，h.b 加一，桶的数量翻倍
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>newbuckets</span><span class=p>,</span> <span class=nx>nextOverflow</span> <span class=o>:=</span> <span class=nf>makeBucketArray</span><span class=p>(</span><span class=nx>t</span><span class=p>,</span> <span class=nx>h</span><span class=p>.</span><span class=nx>B</span><span class=o>+</span><span class=nx>bigger</span><span class=p>,</span> <span class=kc>nil</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>h</span><span class=p>.</span><span class=nx>B</span> <span class=o>+=</span> <span class=nx>bigger</span>
</span></span><span class=line><span class=cl>    <span class=nx>h</span><span class=p>.</span><span class=nx>flags</span> <span class=p>=</span> <span class=nx>flags</span>
</span></span><span class=line><span class=cl>    <span class=c1>//将 oldbucket 设为原有的桶
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>h</span><span class=p>.</span><span class=nx>oldbuckets</span> <span class=p>=</span> <span class=nx>oldbuckets</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 将 bucket 设为新的新的空桶
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>h</span><span class=p>.</span><span class=nx>buckets</span> <span class=p>=</span> <span class=nx>newbuckets</span>
</span></span><span class=line><span class=cl>    <span class=nx>h</span><span class=p>.</span><span class=nx>nevacuate</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=nx>h</span><span class=p>.</span><span class=nx>noverflow</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 溢出桶采用相同的逻辑
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=nx>h</span><span class=p>.</span><span class=nx>extra</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=o>&amp;&amp;</span> <span class=nx>h</span><span class=p>.</span><span class=nx>extra</span><span class=p>.</span><span class=nx>overflow</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Promote current overflow buckets to the old generation.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=nx>h</span><span class=p>.</span><span class=nx>extra</span><span class=p>.</span><span class=nx>oldoverflow</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>throw</span><span class=p>(</span><span class=s>&#34;oldoverflow is not nil&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nx>h</span><span class=p>.</span><span class=nx>extra</span><span class=p>.</span><span class=nx>oldoverflow</span> <span class=p>=</span> <span class=nx>h</span><span class=p>.</span><span class=nx>extra</span><span class=p>.</span><span class=nx>overflow</span>
</span></span><span class=line><span class=cl>        <span class=nx>h</span><span class=p>.</span><span class=nx>extra</span><span class=p>.</span><span class=nx>overflow</span> <span class=p>=</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>nextOverflow</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>h</span><span class=p>.</span><span class=nx>extra</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>h</span><span class=p>.</span><span class=nx>extra</span> <span class=p>=</span> <span class=nb>new</span><span class=p>(</span><span class=nx>mapextra</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nx>h</span><span class=p>.</span><span class=nx>extra</span><span class=p>.</span><span class=nx>nextOverflow</span> <span class=p>=</span> <span class=nx>nextOverflow</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// the actual copying of the hash table data is done incrementally
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// by growWork() and evacuate().
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20240721231524.png alt=20240721231524></p><p>我们可以看出，等量扩容创建的新桶数量和旧桶一样，而增量扩容创建的新桶则为原来的两倍。<code>hashGrow</code>只是创建了新桶，并没有对数据进行复制和转移。哈希表的数据迁移是由 <a href=https://github.com/golang/go/blob/4c50f9162cafaccc1ab1bc26b0dea18f124b536d/src/runtime/map.go#L1140 target=_blank rel=noopener>runtime.growWork</a> 和 <a href=https://github.com/golang/go/blob/4c50f9162cafaccc1ab1bc26b0dea18f124b536d/src/runtime/map.go#L1164 target=_blank rel=noopener>runtime.evacuate</a> 共同完成的，后者会对桶中的元素分流：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span><span class=lnt>75
</span><span class=lnt>76
</span><span class=lnt>77
</span><span class=lnt>78
</span><span class=lnt>79
</span><span class=lnt>80
</span><span class=lnt>81
</span><span class=lnt>82
</span><span class=lnt>83
</span><span class=lnt>84
</span><span class=lnt>85
</span><span class=lnt>86
</span><span class=lnt>87
</span><span class=lnt>88
</span><span class=lnt>89
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>evacuate</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>maptype</span><span class=p>,</span> <span class=nx>h</span> <span class=o>*</span><span class=nx>hmap</span><span class=p>,</span> <span class=nx>oldbucket</span> <span class=kt>uintptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 计算要迁移的旧桶 b 的地址
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>b</span> <span class=o>:=</span> <span class=p>(</span><span class=o>*</span><span class=nx>bmap</span><span class=p>)(</span><span class=nf>add</span><span class=p>(</span><span class=nx>h</span><span class=p>.</span><span class=nx>oldbuckets</span><span class=p>,</span> <span class=nx>oldbucket</span><span class=o>*</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>BucketSize</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 计算扩容前桶的数量
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>newbit</span> <span class=o>:=</span> <span class=nx>h</span><span class=p>.</span><span class=nf>noldbuckets</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 若 b 没有被迁移
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>!</span><span class=nf>evacuated</span><span class=p>(</span><span class=nx>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 创建两个 evacDst 结构体用于保存分配上下文
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// 它们分别指向一个新桶
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kd>var</span> <span class=nx>xy</span> <span class=p>[</span><span class=mi>2</span><span class=p>]</span><span class=nx>evacDst</span>
</span></span><span class=line><span class=cl>        <span class=nx>x</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>xy</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 迁移到 x 的桶序号不变
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>x</span><span class=p>.</span><span class=nx>b</span> <span class=p>=</span> <span class=p>(</span><span class=o>*</span><span class=nx>bmap</span><span class=p>)(</span><span class=nf>add</span><span class=p>(</span><span class=nx>h</span><span class=p>.</span><span class=nx>buckets</span><span class=p>,</span> <span class=nx>oldbucket</span><span class=o>*</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>BucketSize</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>        <span class=nx>x</span><span class=p>.</span><span class=nx>k</span> <span class=p>=</span> <span class=nf>add</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>x</span><span class=p>.</span><span class=nx>b</span><span class=p>),</span> <span class=nx>dataOffset</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>x</span><span class=p>.</span><span class=nx>e</span> <span class=p>=</span> <span class=nf>add</span><span class=p>(</span><span class=nx>x</span><span class=p>.</span><span class=nx>k</span><span class=p>,</span> <span class=nx>bucketCnt</span><span class=o>*</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>KeySize</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>!</span><span class=nx>h</span><span class=p>.</span><span class=nf>sameSizeGrow</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 只有在翻倍扩容的情况下才计算 y
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nx>y</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>xy</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 迁移到 y 的桶序号增加扩容前桶的数量
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nx>y</span><span class=p>.</span><span class=nx>b</span> <span class=p>=</span> <span class=p>(</span><span class=o>*</span><span class=nx>bmap</span><span class=p>)(</span><span class=nf>add</span><span class=p>(</span><span class=nx>h</span><span class=p>.</span><span class=nx>buckets</span><span class=p>,</span> <span class=p>(</span><span class=nx>oldbucket</span><span class=o>+</span><span class=nx>newbit</span><span class=p>)</span><span class=o>*</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>BucketSize</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>            <span class=nx>y</span><span class=p>.</span><span class=nx>k</span> <span class=p>=</span> <span class=nf>add</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>y</span><span class=p>.</span><span class=nx>b</span><span class=p>),</span> <span class=nx>dataOffset</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=nx>y</span><span class=p>.</span><span class=nx>e</span> <span class=p>=</span> <span class=nf>add</span><span class=p>(</span><span class=nx>y</span><span class=p>.</span><span class=nx>k</span><span class=p>,</span> <span class=nx>bucketCnt</span><span class=o>*</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>KeySize</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 遍历所有的正常桶和溢出桶
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>for</span> <span class=p>;</span> <span class=nx>b</span> <span class=o>!=</span> <span class=kc>nil</span><span class=p>;</span> <span class=nx>b</span> <span class=p>=</span> <span class=nx>b</span><span class=p>.</span><span class=nf>overflow</span><span class=p>(</span><span class=nx>t</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>k</span> <span class=o>:=</span> <span class=nf>add</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>b</span><span class=p>),</span> <span class=nx>dataOffset</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=nx>e</span> <span class=o>:=</span> <span class=nf>add</span><span class=p>(</span><span class=nx>k</span><span class=p>,</span> <span class=nx>bucketCnt</span><span class=o>*</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>KeySize</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=c1>// // 遍历桶 b 中的所有元素
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>bucketCnt</span><span class=p>;</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>k</span><span class=p>,</span> <span class=nx>e</span> <span class=p>=</span> <span class=nx>i</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=nf>add</span><span class=p>(</span><span class=nx>k</span><span class=p>,</span> <span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>KeySize</span><span class=p>)),</span> <span class=nf>add</span><span class=p>(</span><span class=nx>e</span><span class=p>,</span> <span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>ValueSize</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nx>top</span> <span class=o>:=</span> <span class=nx>b</span><span class=p>.</span><span class=nx>tophash</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>                <span class=c1>// 若为空位，则直接跳过
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>if</span> <span class=nf>isEmpty</span><span class=p>(</span><span class=nx>top</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=nx>b</span><span class=p>.</span><span class=nx>tophash</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nx>evacuatedEmpty</span>
</span></span><span class=line><span class=cl>                    <span class=k>continue</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=nx>k2</span> <span class=o>:=</span> <span class=nx>k</span>
</span></span><span class=line><span class=cl>                <span class=kd>var</span> <span class=nx>useY</span> <span class=kt>uint8</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>!</span><span class=nx>h</span><span class=p>.</span><span class=nf>sameSizeGrow</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=c1>// 计算哈希值确定该元素应当迁移到 x 指向的桶还是 y 指向的桶
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=nx>hash</span> <span class=o>:=</span> <span class=nx>t</span><span class=p>.</span><span class=nf>Hasher</span><span class=p>(</span><span class=nx>k2</span><span class=p>,</span> <span class=nb>uintptr</span><span class=p>(</span><span class=nx>h</span><span class=p>.</span><span class=nx>hash0</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                    <span class=c1>// k2 为特殊值时的处理
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=k>if</span> <span class=nx>h</span><span class=p>.</span><span class=nx>flags</span><span class=o>&amp;</span><span class=nx>iterator</span> <span class=o>!=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=p>!</span><span class=nx>t</span><span class=p>.</span><span class=nf>ReflexiveKey</span><span class=p>()</span> <span class=o>&amp;&amp;</span> <span class=p>!</span><span class=nx>t</span><span class=p>.</span><span class=nx>Key</span><span class=p>.</span><span class=nf>Equal</span><span class=p>(</span><span class=nx>k2</span><span class=p>,</span> <span class=nx>k2</span><span class=p>)</span> <span class=p>{.</span>
</span></span><span class=line><span class=cl>                        <span class=nx>useY</span> <span class=p>=</span> <span class=nx>top</span> <span class=o>&amp;</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>                        <span class=nx>top</span> <span class=p>=</span> <span class=nf>tophash</span><span class=p>(</span><span class=nx>hash</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                        <span class=c1>// 常规情况下的处理
</span></span></span><span class=line><span class=cl><span class=c1></span>                        <span class=k>if</span> <span class=nx>hash</span><span class=o>&amp;</span><span class=nx>newbit</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                            <span class=c1>// 元素应当迁移到 y 指向的桶
</span></span></span><span class=line><span class=cl><span class=c1></span>                            <span class=nx>useY</span> <span class=p>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>                        <span class=p>}</span>
</span></span><span class=line><span class=cl>                    <span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=o>...</span>
</span></span><span class=line><span class=cl>                <span class=c1>// 更新 tophash 以标记对应的元素已经被迁移
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=nx>b</span><span class=p>.</span><span class=nx>tophash</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nx>evacuatedX</span> <span class=o>+</span> <span class=nx>useY</span>
</span></span><span class=line><span class=cl>                <span class=c1>// 确定元素最终的迁移位置
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=nx>dst</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>xy</span><span class=p>[</span><span class=nx>useY</span><span class=p>]</span>     
</span></span><span class=line><span class=cl>                <span class=c1>// 若新桶已满，则创建溢出桶
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>if</span> <span class=nx>dst</span><span class=p>.</span><span class=nx>i</span> <span class=o>==</span> <span class=nx>bucketCnt</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=nx>dst</span><span class=p>.</span><span class=nx>b</span> <span class=p>=</span> <span class=nx>h</span><span class=p>.</span><span class=nf>newoverflow</span><span class=p>(</span><span class=nx>t</span><span class=p>,</span> <span class=nx>dst</span><span class=p>.</span><span class=nx>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                    <span class=nx>dst</span><span class=p>.</span><span class=nx>i</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>                    <span class=nx>dst</span><span class=p>.</span><span class=nx>k</span> <span class=p>=</span> <span class=nf>add</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>dst</span><span class=p>.</span><span class=nx>b</span><span class=p>),</span> <span class=nx>dataOffset</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                    <span class=nx>dst</span><span class=p>.</span><span class=nx>e</span> <span class=p>=</span> <span class=nf>add</span><span class=p>(</span><span class=nx>dst</span><span class=p>.</span><span class=nx>k</span><span class=p>,</span> <span class=nx>bucketCnt</span><span class=o>*</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>KeySize</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=c1>// 复制键值对到新 bucket
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=nx>dst</span><span class=p>.</span><span class=nx>b</span><span class=p>.</span><span class=nx>tophash</span><span class=p>[</span><span class=nx>dst</span><span class=p>.</span><span class=nx>i</span><span class=o>&amp;</span><span class=p>(</span><span class=nx>bucketCnt</span><span class=o>-</span><span class=mi>1</span><span class=p>)]</span> <span class=p>=</span> <span class=nx>top</span> <span class=c1>// mask dst.i as an optimization, to avoid a bounds check
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>if</span> <span class=nx>t</span><span class=p>.</span><span class=nf>IndirectKey</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>)(</span><span class=nx>dst</span><span class=p>.</span><span class=nx>k</span><span class=p>)</span> <span class=p>=</span> <span class=nx>k2</span> <span class=c1>// copy pointer
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=nf>typedmemmove</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>Key</span><span class=p>,</span> <span class=nx>dst</span><span class=p>.</span><span class=nx>k</span><span class=p>,</span> <span class=nx>k</span><span class=p>)</span> <span class=c1>// copy elem
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=nx>t</span><span class=p>.</span><span class=nf>IndirectElem</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>)(</span><span class=nx>dst</span><span class=p>.</span><span class=nx>e</span><span class=p>)</span> <span class=p>=</span> <span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>)(</span><span class=nx>e</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=nf>typedmemmove</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>Elem</span><span class=p>,</span> <span class=nx>dst</span><span class=p>.</span><span class=nx>e</span><span class=p>,</span> <span class=nx>e</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=nx>dst</span><span class=p>.</span><span class=nx>i</span><span class=o>++</span>
</span></span><span class=line><span class=cl>                <span class=nx>dst</span><span class=p>.</span><span class=nx>k</span> <span class=p>=</span> <span class=nf>add</span><span class=p>(</span><span class=nx>dst</span><span class=p>.</span><span class=nx>k</span><span class=p>,</span> <span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>KeySize</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                <span class=nx>dst</span><span class=p>.</span><span class=nx>e</span> <span class=p>=</span> <span class=nf>add</span><span class=p>(</span><span class=nx>dst</span><span class=p>.</span><span class=nx>e</span><span class=p>,</span> <span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>ValueSize</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=o>...</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 若所有旧桶迁移完成，则清空 oldbuckets 和 oldoverflow
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=nx>oldbucket</span> <span class=o>==</span> <span class=nx>h</span><span class=p>.</span><span class=nx>nevacuate</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>advanceEvacuationMark</span><span class=p>(</span><span class=nx>h</span><span class=p>,</span> <span class=nx>t</span><span class=p>,</span> <span class=nx>newbit</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><p>举例来说，旧桶数量是 4，新桶数量是 8。则旧桶的掩码是 $11_2$，新桶的掩码是 $111_2$。那么旧桶中 3 号桶的元素（哈希值后两位为 $11$）就会被分流到新桶中的 3 号桶（哈希值后三位为 $011$）和 7 号桶（哈希值后三位为 $111$）：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20240721231551.png alt=20240721231551></p><p>之前在分析访问哈希表时其实省略了扩容期间获取键值对的逻辑，当哈希表的<code>oldbuckets</code>存在时，会先定位到旧桶并在该桶没有被迁移时从中获取键值对。</p><p>而当哈希表正在处于扩容状态时，只有向哈希表写入值时才会触发 <a href=https://github.com/golang/go/blob/4c50f9162cafaccc1ab1bc26b0dea18f124b536d/src/runtime/map.go#L1140 target=_blank rel=noopener>runtime.growWork</a> 增量复制哈希表中的内容。先迁移旧桶，再完成写入：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>mapassign</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>maptype</span><span class=p>,</span> <span class=nx>h</span> <span class=o>*</span><span class=nx>hmap</span><span class=p>,</span> <span class=nx>key</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>)</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl><span class=nx>again</span><span class=p>:</span>  
</span></span><span class=line><span class=cl>    <span class=nx>bucket</span> <span class=o>:=</span> <span class=nx>hash</span> <span class=o>&amp;</span> <span class=nf>bucketMask</span><span class=p>(</span><span class=nx>h</span><span class=p>.</span><span class=nx>B</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>h</span><span class=p>.</span><span class=nf>growing</span><span class=p>()</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>        <span class=nf>growWork</span><span class=p>(</span><span class=nx>t</span><span class=p>,</span> <span class=nx>h</span><span class=p>,</span> <span class=nx>bucket</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>   <span class=p>}</span>
</span></span><span class=line><span class=cl>   <span class=o>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>growWork</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>maptype</span><span class=p>,</span> <span class=nx>h</span> <span class=o>*</span><span class=nx>hmap</span><span class=p>,</span> <span class=nx>bucket</span> <span class=kt>uintptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// evacuate 将旧桶中的元素迁移到扩容后的新桶
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>evacuate</span><span class=p>(</span><span class=nx>t</span><span class=p>,</span> <span class=nx>h</span><span class=p>,</span> <span class=nx>bucket</span><span class=o>&amp;</span><span class=nx>h</span><span class=p>.</span><span class=nf>oldbucketmask</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 如果已处于扩容阶段，则再迁移第一个未迁移的旧桶
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 防止某些旧桶没有被写入导致扩容长时间无法完成
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=nx>h</span><span class=p>.</span><span class=nf>growing</span><span class=p>()</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>        <span class=nf>evacuate</span><span class=p>(</span><span class=nx>t</span><span class=p>,</span> <span class=nx>h</span><span class=p>,</span> <span class=nx>h</span><span class=p>.</span><span class=nx>nevacuate</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>   <span class=p>}</span>  
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><p>传入该函数的<code>bucket</code>参数是我们即将访问的某一个新桶，<code>bucket&amp;h.oldbucketmask()</code>是与之对应的旧桶地址。举例来说，旧桶数量是 4，新桶数量是 8，旧桶的掩码是 $11_2$。如果<code>bucket</code>指向新桶中的 5 号桶，那么它在旧桶中的序号就应当是 $0101_2 \And 0011_2$，即 1 号。该函数仅操作单个桶而非整个<code>bmap</code>数组，因此 Go 语言中哈希的扩容是渐进式的，每次最多迁移两个桶。</p><h4 id=删除><a href=#删除 class=anchor-link><svg viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:删除 class=headings>删除</a></h4><p><code>delete</code>关键字可以删除哈希表中某一个键对应的元素，它会在编译时被转换为 <a href=https://github.com/golang/go/blob/4c50f9162cafaccc1ab1bc26b0dea18f124b536d/src/runtime/map.go#L696 target=_blank rel=noopener>runtime.mapdelete</a> 函数簇中的一个。用于处理删除逻辑的函数与 <a href=https://github.com/golang/go/blob/4c50f9162cafaccc1ab1bc26b0dea18f124b536d/src/runtime/map.go#L579 target=_blank rel=noopener>runtime.mapassign</a> 几乎完全相同，不太需要刻意关注。</p><h2 id=字符串><a href=#字符串 class=anchor-link><svg viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:字符串 class=headings>字符串</a></h2><p>Go 语言中的字符串是一个只读的字节数组：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20240721231616.png alt=20240721231616></p><p>不过我们仍然可以通过在<code>string</code>和<code>[]byte</code>类型之间反复转换实现修改这一目的：</p><ol><li>先将这段内存复制到堆或者栈上；</li><li>将变量的类型转换成<code>[]byte</code>后并修改字节数据；</li><li>将修改后的字节数组转换回<code>string</code>；</li></ol><p>使用双引号声明的字符串只能用于单行字符串的初始化，如果字符串内部出现双引号，则需要使用<code>\</code>符号避免编译器的解析错误。而反引号声明的字符串可以摆脱单行的限制，并且可以在字符串内部直接使用<code>"</code>，在遇到需要手写 JSON 或者其他复杂数据格式的场景下非常方便：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>str1</span> <span class=o>:=</span> <span class=s>&#34;this is a string&#34;</span>
</span></span><span class=line><span class=cl><span class=nx>str2</span> <span class=o>:=</span> <span class=s>`this is another
</span></span></span><span class=line><span class=cl><span class=s>string`</span>
</span></span><span class=line><span class=cl><span class=nx>json</span> <span class=o>:=</span> <span class=s>`{&#34;author&#34;: &#34;draven&#34;, &#34;tags&#34;: [&#34;golang&#34;]}`</span>
</span></span></code></pre></td></tr></table></div></div></div><h3 id=数据结构-1><a href=#数据结构-1 class=anchor-link><svg viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:数据结构-1 class=headings>数据结构</a></h3><p>每一个字符串在运行时都会使用如下的 <a href=https://github.com/golang/go/blob/071b8d51c1a70fa6b12f0bed2e93370e193333fd/src/internal/unsafeheader/unsafeheader.go#L34 target=_blank rel=noopener>internal/unsafeheader.String</a> 表示，其中包含指向字节数组的指针和数组的大小：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>String</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>Data</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span>
</span></span><span class=line><span class=cl>    <span class=nx>Len</span>  <span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><p>因此我们常说字符串是只读的切片类型，所有在字符串上的写入操作都是通过复制实现的。</p><h3 id=拼接><a href=#拼接 class=anchor-link><svg viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:拼接 class=headings>拼接</a></h3><p>正常情况下，运行时会调用<code>copy</code>将输入的多个字符串复制到目标字符串所在的内存空间。新的字符串是一片新的内存空间，与原来的字符串也没有任何关联，一旦需要拼接的字符串非常大，复制带来的性能损失是无法忽略的。</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20240721231645.png alt=20240721231645></p><blockquote><p>如果需要拼接多次，应使用<code>strings.Builder</code>，最小化内存复制次数。</p></blockquote><h3 id=类型转换><a href=#类型转换 class=anchor-link><svg viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:类型转换 class=headings>类型转换</a></h3><p>从字节数组<code>[]byte</code>到字符串的转换需要使用 <a href=https://github.com/golang/go/blob/4c50f9162cafaccc1ab1bc26b0dea18f124b536d/src/runtime/string.go#L81 target=_blank rel=noopener>runtime.slicebytetostring</a> 函数：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// ptr 是指向切片第一个元素的指针
</span></span></span><span class=line><span class=cl><span class=c1>// n 是切片的长度，buf 是用于保存结果的固定长度缓冲区
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>slicebytetostring</span><span class=p>(</span><span class=nx>buf</span> <span class=o>*</span><span class=nx>tmpBuf</span><span class=p>,</span> <span class=nx>ptr</span> <span class=o>*</span><span class=kt>byte</span><span class=p>,</span> <span class=nx>n</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>string</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>n</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=s>&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>n</span> <span class=o>==</span> <span class=mi>1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>p</span> <span class=o>:=</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>staticuint64s</span><span class=p>[</span><span class=o>*</span><span class=nx>ptr</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=c1>// unfase.String 根据传入的指针和长度
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// 返回实际的 string
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>return</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>String</span><span class=p>((</span><span class=o>*</span><span class=kt>byte</span><span class=p>)(</span><span class=nx>p</span><span class=p>),</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>p</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 根据缓冲区大小决定是否需要为新字符串分配一片内存空间
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=nx>buf</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=o>&amp;&amp;</span> <span class=nx>n</span> <span class=o>&lt;=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>buf</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>p</span> <span class=p>=</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>buf</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>p</span> <span class=p>=</span> <span class=nf>mallocgc</span><span class=p>(</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>n</span><span class=p>),</span> <span class=kc>nil</span><span class=p>,</span> <span class=kc>false</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 将字节数组中的元素复制到新的内存空间中
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>memmove</span><span class=p>(</span><span class=nx>p</span><span class=p>,</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>ptr</span><span class=p>),</span> <span class=nb>uintptr</span><span class=p>(</span><span class=nx>n</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>String</span><span class=p>((</span><span class=o>*</span><span class=kt>byte</span><span class=p>)(</span><span class=nx>p</span><span class=p>),</span> <span class=nx>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><p>当我们想要将字符串转换成<code>[]byte</code>类型时，需要使用 <a href=https://github.com/golang/go/blob/4c50f9162cafaccc1ab1bc26b0dea18f124b536d/src/runtime/string.go#L166 target=_blank rel=noopener>runtime.stringtoslicebyte</a> 函数：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>stringtoslicebyte</span><span class=p>(</span><span class=nx>buf</span> <span class=o>*</span><span class=nx>tmpBuf</span><span class=p>,</span> <span class=nx>s</span> <span class=kt>string</span><span class=p>)</span> <span class=p>[]</span><span class=kt>byte</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>b</span> <span class=p>[]</span><span class=kt>byte</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>buf</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=o>&amp;&amp;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span> <span class=o>&lt;=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>buf</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=nx>buf</span> <span class=p>=</span> <span class=nx>tmpBuf</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 传入缓冲区时，用缓冲区存储字节切片
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>b</span> <span class=p>=</span> <span class=nx>buf</span><span class=p>[:</span><span class=nb>len</span><span class=p>(</span><span class=nx>s</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 无缓冲区时，创建新的字节切片
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>b</span> <span class=p>=</span> <span class=nf>rawbyteslice</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>s</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 将字符串中的内容复制到字节切片
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nb>copy</span><span class=p>(</span><span class=nx>b</span><span class=p>,</span> <span class=nx>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>b</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><p>因此不过无论从哪种类型转换到另一种都需要复制数据，而内存复制的性能损耗会随着字符串和<code>[]byte</code>长度的增长而增长。</p></div><p class=edit-page><a href=https://github.com/koktlzz/koktlzz.github.io/blob/main/content/posts/go-data-structure-note.md><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-edit-2"><path d="M17 3a2.828 2.828.0 114 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>Edit this page on GitHub</a></p></article><script src=https://giscus.app/client.js data-repo=koktlzz/koktlzz.github.io data-repo-id=R_kgDOGRJFtw data-category=Announcements data-category-id=DIC_kwDOGRJFt84CTCRR data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></div></main><div id=back-to-top class=back-to-top><a href=#><svg viewBox="0 0 448 512" class="icon arrow-up"><path d="M34.9 289.5l-22.2-22.2c-9.4-9.4-9.4-24.6.0-33.9L207 39c9.4-9.4 24.6-9.4 33.9.0l194.3 194.3c9.4 9.4 9.4 24.6.0 33.9L413 289.4c-9.5 9.5-25 9.3-34.3-.4L264 168.6V456c0 13.3-10.7 24-24 24h-32c-13.3.0-24-10.7-24-24V168.6L69.2 289.1c-9.3 9.8-24.8 10-34.3.4z"/></svg></a></div><footer id=footer class=footer><div class=footer-inner><div class=site-info>©&nbsp;2020–2024&nbsp;<svg viewBox="0 0 512 512" class="icon footer-icon"><path d="M462.3 62.6C407.5 15.9 326 24.3 275.7 76.2L256 96.5l-19.7-20.3C186.1 24.3 104.5 15.9 49.7 62.6c-62.8 53.6-66.1 149.8-9.9 207.9l193.5 199.8c12.5 12.9 32.8 12.9 45.3.0l193.5-199.8c56.3-58.1 53-154.3-9.8-207.9z"/></svg>&nbsp;koktlzz</div><div class=powered-by>Powered by <a href=https://github.com/gohugoio/hugo target=_blank rel=noopener>Hugo</a> | Theme is <a href=https://github.com/reuixiy/hugo-theme-meme target=_blank rel=noopener>MemE</a></div><div class=site-copyright><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en target=_blank rel=noopener>CC BY-NC-SA 4.0</a></div><ul class=socials><li class=socials-item><a href=/rss.xml target=_blank rel="external noopener" title=RSS><svg viewBox="0 0 24 24" class="icon social-icon"><path d="M19.199 24C19.199 13.467 10.533 4.8.0 4.8V0c13.165.0 24 10.835 24 24h-4.801zM3.291 17.415c1.814.0 3.293 1.479 3.293 3.295.0 1.813-1.485 3.29-3.301 3.29C1.47 24 0 22.526.0 20.71s1.475-3.294 3.291-3.295zM15.909 24h-4.665c0-6.169-5.075-11.245-11.244-11.245V8.09c8.727.0 15.909 7.184 15.909 15.91z"/></svg></a></li><li class=socials-item><a href=mailto:gwrhnu@163.com target=_blank rel="external noopener" title=Email><svg viewBox="0 0 512 512" class="icon social-icon"><path d="M464 64H48C21.49 64 0 85.49.0 112v288c0 26.51 21.49 48 48 48h416c26.51.0 48-21.49 48-48V112c0-26.51-21.49-48-48-48zm0 48v40.805c-22.422 18.259-58.168 46.651-134.587 106.49-16.841 13.247-50.201 45.072-73.413 44.701-23.208.375-56.579-31.459-73.413-44.701C106.18 199.465 70.425 171.067 48 152.805V112h416zM48 4e2V214.398c22.914 18.251 55.409 43.862 104.938 82.646 21.857 17.205 60.134 55.186 103.062 54.955 42.717.231 80.509-37.199 103.053-54.947 49.528-38.783 82.032-64.401 104.947-82.653V4e2H48z"/></svg></a></li><li class=socials-item><a href=https://github.com/koktlzz target=_blank rel="external noopener" title=GitHub><svg viewBox="0 0 24 24" class="icon social-icon"><path d="M12 .297c-6.63.0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577.0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93.0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176.0.0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22.0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22.0 1.606-.015 2.896-.015 3.286.0.315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg></a></li></ul></div></footer></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.css integrity="sha256-gPJfuwTULrEAAcI3X4bALVU/2qBU+QY/TpoD3GO+Exw=" crossorigin=anonymous><script>if(typeof renderMathInElement=="undefined"){var getScript=e=>{var t=document.createElement("script");t.defer=!0,t.crossOrigin="anonymous",Object.keys(e).forEach(n=>{t[n]=e[n]}),document.body.appendChild(t)};getScript({src:"https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.js",integrity:"sha256-YTW9cMncW/ZQMhY69KaUxIa2cPTxV87Uh627Gf5ODUw=",onload:()=>{getScript({src:"https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/contrib/mhchem.min.js",integrity:"sha256-yzSfYeVsWJ1x+2g8CYHsB/Mn7PcSp8122k5BM4T3Vxw=",onload:()=>{getScript({src:"https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/contrib/auto-render.min.js",integrity:"sha256-fxJzNV6hpc8tgW8tF0zVobKa71eTCRGTgxFXt1ZpJNM=",onload:()=>{renderKaTex()}})}})}})}else renderKaTex();function renderKaTex(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1}]})}</script><script src=https://cdn.jsdelivr.net/npm/medium-zoom@latest/dist/medium-zoom.min.js></script><script>let imgNodes=document.querySelectorAll("div.post-body img");imgNodes=Array.from(imgNodes).filter(e=>e.parentNode.tagName!=="A"),mediumZoom(imgNodes,{background:"hsla(var(--color-bg-h), var(--color-bg-s), var(--color-bg-l), 0.95)"})</script><script src=https://cdn.jsdelivr.net/npm/instant.page@5.1.0/instantpage.min.js type=module defer></script></body></html>