<!doctype html><html lang=en><head prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article#"><meta charset=utf-8><meta name=generator content="Hugo 0.93.0"><meta name=theme-color content="#fff"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=format-detection content="telephone=no, date=no, address=no, email=no"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><title>CSAPP 读书笔记：程序的机器级表示 | Inspire Hub</title><link rel=stylesheet href=/css/meme.min.0d3c199b4f1178f90faed5ac9b3dae32ac2c697cc817bd37ceb35225626344a5.css><script src=https://cdn.jsdelivr.net/npm/lunr@2.3.9/lunr.min.js defer></script><script src=/js/meme.min.8a41013c1ff95861d6b1bdd3e29d4a2635ad197925640e317d4208001aa153ac.js></script>
<link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=IBM+Plex+Serif:ital,wght@0,400;0,500;0,700;1,400;1,700&family=Source+Code+Pro:ital,wght@0,400;0,700;1,400;1,700&family=Comfortaa:wght@700&display=swap" media=print onload='this.media="all"'><noscript><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=IBM+Plex+Serif:ital,wght@0,400;0,500;0,700;1,400;1,700&family=Source+Code+Pro:ital,wght@0,400;0,700;1,400;1,700&family=Comfortaa:wght@700&display=swap"></noscript><meta name=author content="koktlzz"><meta name=description content="在使用高级语言，如 C、Java 编程时，我们无法了解程序具体的机器级实现。相比之下，使用汇编语言编写程序时，程序员必须指定程序使用的低级指令来执行计算。编译器提供的类型检查有助于检测许多程序错误，确保我们以一致的方式来引用和操作数据 …"><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=mask-icon href=/icons/safari-pinned-tab.svg color=#2a6df4><link rel=apple-touch-icon sizes=180x180 href=/icons/apple-touch-icon.png><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-title content="Inspire Hub"><meta name=apple-mobile-web-app-status-bar-style content="black"><meta name=mobile-web-app-capable content="yes"><meta name=application-name content="Inspire Hub"><meta name=msapplication-starturl content="../../"><meta name=msapplication-TileColor content="#fff"><meta name=msapplication-TileImage content="../../icons/mstile-150x150.png"><link rel=manifest href=/manifest.json><link rel=canonical href=/posts/machine-level-representation-of-programs-note/><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","datePublished":"2021-09-23T09:19:42+01:00","dateModified":"2021-11-30T13:18:11+08:00","url":"/posts/machine-level-representation-of-programs-note/","headline":"CSAPP 读书笔记：程序的机器级表示","description":"在使用高级语言，如 C、Java 编程时，我们无法了解程序具体的机器级实现。相比之下，使用汇编语言编写程序时，程序员必须指定程序使用的低级指令来执行计算。编译器提供的类型检查有助于检测许多程序错误，确保我们以一致的方式来引用和操作数据 …","inLanguage":"en","articleSection":"posts","wordCount":3459,"image":["https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20210722220646.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20210728231423.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20210726192644.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211007151414.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20210728231051.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20210728232301.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211007152556.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211007160353.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211007174422.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211007174503.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211007211436.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211007212847.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211008215219.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211008224011.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211011224454.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211011225955.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211013222734.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211014012100.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211014012501.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211031214307.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211103000139.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211103221350.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211104221557.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211104222239.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211104224830.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211109231344.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211109231455.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211110223306.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211110223714.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211111224620.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211115220443.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211117223136.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211123220533.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211123223334.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211123224435.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211125224206.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211128173012.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211128212129.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211128224621.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211129222149.png"],"author":{"@type":"Person","email":"koktlgwr@gmail.com","image":"/icons/apple-touch-icon.png","url":"/","name":"koktlzz"},"license":"[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)","publisher":{"@type":"Organization","name":"Inspire Hub","logo":{"@type":"ImageObject","url":"/icons/apple-touch-icon.png"},"url":"/"},"mainEntityOfPage":{"@type":"WebSite","@id":"/"}}</script><meta property="og:title" content="CSAPP 读书笔记：程序的机器级表示"><meta property="og:description" content="在使用高级语言，如 C、Java 编程时，我们无法了解程序具体的机器级实现。相比之下，使用汇编语言编写程序时，程序员必须指定程序使用的低级指令来执行计算。编译器提供的类型检查有助于检测许多程序错误，确保我们以一致的方式来引用和操作数据 …"><meta property="og:url" content="/posts/machine-level-representation-of-programs-note/"><meta property="og:site_name" content="Inspire Hub"><meta property="og:locale" content="en"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20210722220646.png"><meta property="og:type" content="article"><meta property="article:published_time" content="2021-09-23T09:19:42+01:00"><meta property="article:modified_time" content="2021-11-30T13:18:11+08:00"><meta property="article:section" content="posts"><link rel=preconnect href=https://www.google-analytics.com crossorigin><script async src="https://www.googletagmanager.com/gtag/js?id=G-D022F6NT2P"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-D022F6NT2P")</script></head><body><div class=container><header class=header><div class=header-wrapper><div class="header-inner single"><div class=site-brand><a href=/ class=brand>Inspire Hub</a></div><nav class=nav><ul class=menu id=menu><li class=menu-item><a href=/posts/><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon archive"><path d="M32 448c0 17.7 14.3 32 32 32h384c17.7.0 32-14.3 32-32V160H32v288zm160-212c0-6.6 5.4-12 12-12h104c6.6.0 12 5.4 12 12v8c0 6.6-5.4 12-12 12H204c-6.6.0-12-5.4-12-12v-8zM480 32H32C14.3 32 0 46.3.0 64v48c0 8.8 7.2 16 16 16h480c8.8.0 16-7.2 16-16V64c0-17.7-14.3-32-32-32z"/></svg><span class=menu-item-name>Posts</span></a></li><li class=menu-item><a href=/tags/><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512" class="icon tags"><path d="M497.941 225.941 286.059 14.059A48 48 0 00252.118.0H48C21.49.0.0 21.49.0 48v204.118a48 48 0 0014.059 33.941l211.882 211.882c18.744 18.745 49.136 18.746 67.882.0l204.118-204.118c18.745-18.745 18.745-49.137.0-67.882zM112 160c-26.51.0-48-21.49-48-48s21.49-48 48-48 48 21.49 48 48-21.49 48-48 48zm513.941 133.823L421.823 497.941c-18.745 18.745-49.137 18.745-67.882.0l-.36-.36L527.64 323.522c16.999-16.999 26.36-39.6 26.36-63.64s-9.362-46.641-26.36-63.64L331.397.0h48.721a48 48 0 0133.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137.0 67.882z"/></svg><span class=menu-item-name>Tags</span></a></li><li class=menu-item><a href></a></li><li class="menu-item search-item"><form id=search class=search role=search><label for=search-input><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon search-icon"><path d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg></label><input type=search id=search-input class=search-input></form><template id=search-result hidden><article class="content post"><h2 class=post-title><a class=summary-title-link></a></h2><summary class=summary></summary><div class=read-more-container><a class=read-more-link>Read More »</a></div></article></template></li></ul></nav></div></div><input type=checkbox id=nav-toggle aria-hidden=true>
<label for=nav-toggle class=nav-toggle></label>
<label for=nav-toggle class=nav-curtain></label></header><main class="main single" id=main><nav class=contents><h2 id=contents class=contents-title>On This Page</h2><ol class=toc><li><a id=contents:intel-处理器历史 href=#intel-处理器历史>Intel 处理器历史</a></li><li><a id=contents:程序编码 href=#程序编码>程序编码</a><ol><li><a id=contents:机器级代码 href=#机器级代码>机器级代码</a></li><li><a id=contents:代码示例 href=#代码示例>代码示例</a></li></ol></li><li><a id=contents:数据格式 href=#数据格式>数据格式</a></li><li><a id=contents:访问信息 href=#访问信息>访问信息</a><ol><li><a id=contents:操作数 href=#操作数>操作数</a></li><li><a id=contents:数据移动指令 href=#数据移动指令>数据移动指令</a></li></ol></li><li><a id=contents:算术和逻辑操作 href=#算术和逻辑操作>算术和逻辑操作</a><ol><li><a id=contents:加载有效地址 href=#加载有效地址>加载有效地址</a></li><li><a id=contents:一元和二元操作 href=#一元和二元操作>一元和二元操作</a></li><li><a id=contents:移位操作 href=#移位操作>移位操作</a></li><li><a id=contents:特殊算数操作 href=#特殊算数操作>特殊算数操作</a></li></ol></li><li><a id=contents:控制 href=#控制>控制</a><ol><li><a id=contents:条件码 href=#条件码>条件码</a></li><li><a id=contents:跳转指令 href=#跳转指令>跳转指令</a></li><li><a id=contents:使用条件控制实现条件分支 href=#使用条件控制实现条件分支>使用条件控制实现条件分支</a></li><li><a id=contents:使用条件移动实现条件分支 href=#使用条件移动实现条件分支>使用条件移动实现条件分支</a></li><li><a id=contents:循环 href=#循环>循环</a><ol><li><a id=contents:do-while href=#do-while>Do-While</a></li><li><a id=contents:while href=#while>While</a></li><li><a id=contents:for href=#for>For</a></li></ol></li><li><a id=contents:switch href=#switch>Switch</a></li></ol></li><li><a id=contents:过程 href=#过程>过程</a><ol><li><a id=contents:运行时栈 href=#运行时栈>运行时栈</a></li><li><a id=contents:传递控制 href=#传递控制>传递控制</a></li><li><a id=contents:传递参数 href=#传递参数>传递参数</a></li><li><a id=contents:局部变量 href=#局部变量>局部变量</a></li><li><a id=contents:被保存的寄存器 href=#被保存的寄存器>被保存的寄存器</a></li><li><a id=contents:递归recursive href=#递归recursive>递归（Recursive）</a></li></ol></li><li><a id=contents:数组 href=#数组>数组</a><ol><li><a id=contents:多维数组 href=#多维数组>多维数组</a></li><li><a id=contents:定长数组 href=#定长数组>定长数组</a></li><li><a id=contents:变长数组 href=#变长数组>变长数组</a></li></ol></li><li><a id=contents:异构数据结构 href=#异构数据结构>异构数据结构</a><ol><li><a id=contents:结构体 href=#结构体>结构体</a></li><li><a id=contents:联合体 href=#联合体>联合体</a></li><li><a id=contents:数据对齐 href=#数据对齐>数据对齐</a></li></ol></li><li><a id=contents:机器级代码中控制和数据的组合 href=#机器级代码中控制和数据的组合>机器级代码中控制和数据的组合</a><ol><li><a id=contents:理解指针 href=#理解指针>理解指针</a></li><li><a id=contents:内存引用越界和缓冲区溢出 href=#内存引用越界和缓冲区溢出>内存引用越界和缓冲区溢出</a></li><li><a id=contents:阻止缓冲区溢出攻击 href=#阻止缓冲区溢出攻击>阻止缓冲区溢出攻击</a><ol><li><a id=contents:随机化栈 href=#随机化栈>随机化栈</a></li><li><a id=contents:栈损坏检测 href=#栈损坏检测>栈损坏检测</a></li><li><a id=contents:限制可执行代码区域 href=#限制可执行代码区域>限制可执行代码区域</a></li></ol></li><li><a id=contents:支持可变大小的栈帧 href=#支持可变大小的栈帧>支持可变大小的栈帧</a></li></ol></li><li><a id=contents:浮点代码 href=#浮点代码>浮点代码</a><ol><li><a id=contents:浮点数的移动和转换操作 href=#浮点数的移动和转换操作>浮点数的移动和转换操作</a></li><li><a id=contents:过程中的浮点代码 href=#过程中的浮点代码>过程中的浮点代码</a></li><li><a id=contents:浮点数的算数操作 href=#浮点数的算数操作>浮点数的算数操作</a></li><li><a id=contents:浮点常量的定义和使用 href=#浮点常量的定义和使用>浮点常量的定义和使用</a></li><li><a id=contents:浮点代码中的位级运算 href=#浮点代码中的位级运算>浮点代码中的位级运算</a></li><li><a id=contents:浮点数的比较操作 href=#浮点数的比较操作>浮点数的比较操作</a></li></ol></li></ol></nav><div class=main-inner><article class="content post h-entry" data-small-caps=true data-align=default data-type=posts><h1 class="post-title p-name">CSAPP 读书笔记：程序的机器级表示</h1><div class=post-tags><a href=/tags/csapp/ rel=tag class=post-tags-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon tag-icon"><path d="M0 252.118V48C0 21.49 21.49.0 48 0h204.118a48 48 0 0133.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137.0 67.882L293.823 497.941c-18.745 18.745-49.137 18.745-67.882.0L14.059 286.059A48 48 0 010 252.118zM112 64c-26.51.0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48z"/></svg>CSAPP</a>
<a href=/tags/os/ rel=tag class=post-tags-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon tag-icon"><path d="M0 252.118V48C0 21.49 21.49.0 48 0h204.118a48 48 0 0133.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137.0 67.882L293.823 497.941c-18.745 18.745-49.137 18.745-67.882.0L14.059 286.059A48 48 0 010 252.118zM112 64c-26.51.0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48z"/></svg>OS</a></div><div class="post-body e-content"><p>在使用高级语言，如 C、Java 编程时，我们无法了解程序具体的机器级实现。相比之下，使用汇编语言编写程序时，程序员必须指定程序使用的低级指令来执行计算。编译器提供的类型检查有助于检测许多程序错误，确保我们以一致的方式来引用和操作数据。最重要的是，用高级语言编写的程序可以在多种不同的机器上编译运行，而汇编语言则与机器特性高度相关。</p><p>尽管编译器完成了生成汇编代码的大部分工作，但阅读和理解汇编语言对于程序员来说是一项重要的技能：</p><blockquote><p>Those who say “I understand the general principles, I don’t want to bother learning the details” are deluding themselves.</p></blockquote><h2 id=intel-处理器历史><a href=#intel-处理器历史 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:intel-处理器历史 class=headings>Intel 处理器历史</a></h2><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20210722220646.png alt=20210722220646></p><h2 id=程序编码><a href=#程序编码 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:程序编码 class=headings>程序编码</a></h2><h3 id=机器级代码><a href=#机器级代码 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:机器级代码 class=headings>机器级代码</a></h3><p>首先，机器级程序的格式和行为是由指令集架构（instruction set architecture，ISA）定义的，包括处理器状态、指令格式以及每条指令对状态的影响。大多数 ISA，包括 x86-64，都将程序的行为描述为每条指令按顺序执行，且一条指令在下一条指令开始之前完成。虽然处理器硬件要复杂得多，可以同时执行许多指令，但它采用了安全措施来确保其整体行为与 ISA 规定的操作顺序相匹配。其次，机器级程序使用的内存地址是虚拟地址，提供了一个看似非常大的字节数组的内存模型。</p><p>汇编代码表示非常接近机器代码，与机器代码的二进制格式相比，它采用更具可读性的文本格式。一些对程序员隐藏的处理器状态在汇编代码中是可见的：</p><ul><li>程序计数器（PC）：在 x86-64 中称为 %rip，代表即将执行的下一条指令在存储器中的地址；</li><li>包含 16 个位置（location）的整数寄存器文件（register file）：这些位置均被命名，每个都能存储 64 位的值。该寄存器可以保存地址（与 C 中的指针对应）和整数数据。一些寄存器用于记录程序状态的关键部分，而其他寄存器则用于保存临时数据，例如过程中的参数、局部变量和函数返回值；</li><li>条件码寄存器（condition code registers）：保存了最新执行的算术或逻辑指令的状态信息，用于实现控制流或数据流中条件的改变，例如 if 语句和 while 语句；</li><li>一组向量寄存器（vector registers）：每个都可以保存一个或多个整数或浮点数值。</li></ul><p>虽然 C 提供了一个模型，让我们可以在内存中声明和分配不同数据类型的对象。但机器级代码只会简单地将内存视为一个按字节寻址的数组，因此 C 中的聚合数据类型（如数组和结构体）在机器级代码中会表示为连续的字节集合。甚至对于标量数据类型（如 int、char、float 和 bool 等），汇编代码也不会区分有符号和无符号整数、不同类型的指针以及指针和整数。</p><p>程序的可执行机器级代码、操作系统所需的一些信息、用于管理过程调用和返回（procedure calls and returns）的运行时栈以及用户分配的内存块（如使用库函数<code>malloc</code>）共同构成了程序内存，它使用虚拟地址寻址，不过只有部分虚拟地址的范围有效。例如，x86-64 机器的虚拟地址必须将前 16 位设置为 0，因此其有效范围包含 $2^{48}$ （64 TB）字节。操作系统负责管理该虚拟地址空间，并将其转换为实际处理器内存（processer memory）中的物理地址。</p><p>单个机器指令仅执行一些基本的操作，如将存储在寄存器中的两个数字相加、在内存和寄存器之间传输数据以及有条件地跳转到新的指令地址。编译器必须生成这样的指令序列来实现程序结构，例如算术表达式求值、循环或过程调用和返回。</p><h3 id=代码示例><a href=#代码示例 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:代码示例 class=headings>代码示例</a></h3><p>C 程序文件 mstore.c 中包含如下代码：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>long</span> <span class=nf>mult2</span><span class=p>(</span><span class=kt>long</span><span class=p>,</span> <span class=kt>long</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>multstore</span><span class=p>(</span><span class=kt>long</span> <span class=n>x</span><span class=p>,</span> <span class=kt>long</span> <span class=n>y</span><span class=p>,</span> <span class=kt>long</span> <span class=o>*</span><span class=n>dest</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>long</span> <span class=n>t</span> <span class=o>=</span> <span class=n>mult2</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=o>*</span><span class=n>dest</span> <span class=o>=</span> <span class=n>t</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><p>使用<code>gcc -Og -S mstore.c</code>命令即可生成汇编代码文件 mstore.s，其中的<code>-Og</code>代表对代码进行优化。汇编代码中有多种声明，包括：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20210728231423.png alt=20210728231423></p><p>每一行缩进的代码都对应着一条机器指令，图中的蓝色注解则标示了指令的作用，如<code>pushq</code>代表将寄存器 <code>%rbx</code> 的内容压入程序栈中。原程序中局部变量名称以及数据类型的所有信息都已被删除，随后我们可以在 Linux 系统中执行下列命令：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>gcc -Og -c mstore.c
</span></span><span class=line><span class=cl>objdump -d mstore.o
</span></span></code></pre></td></tr></table></div></div></div><p>第一条命令将生成二进制格式的目标代码文件（object-code file）mstore.o，第二条命令则是进行反汇编，即将机器级代码转换为一种与汇编语言格式类似的代码。图中的行号和斜体注释是为了方便说明加入的，左侧有 6 组十六进制字节序列，每个都是一条指令，右侧则显示了等效的汇编代码：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20210726192644.png alt=20210726192644></p><ul><li>x86-64 指令的长度范围为 1 到 15 个字节，常用的和操作数较少的指令比不太常用或操作数较多的指令需要更少的字节数；</li><li>从给定的起始位置开始，将字节唯一地解码为机器指令。例如，只有指令 <code>pushq %rbx</code> 以字节值 53 开头；</li><li>反汇编程序只是根据机器级代码文件中的字节序列来确定汇编代码，不需要访问源代码或汇编代码；</li><li>反汇编程序使用的指令命名规则与 gcc 生成的汇编代码略有不同，如许多指令中的后缀<code>q</code>被省略了。这些后缀是尺寸指示符，在大多数情况下可以省略。而反汇编器在<code>call</code>和<code>ret</code>指令中添加了后缀<code>q</code>，它们同样是可以省略的。</li></ul><p>想要生成实际的可执行代码还需要在一组包含<code>main</code>函数的目标代码文件上运行链接器（linker），假设 main.c 文件如下：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>void</span> <span class=nf>multstore</span><span class=p>(</span><span class=kt>long</span><span class=p>,</span> <span class=kt>long</span><span class=p>,</span> <span class=kt>long</span> <span class=o>*</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>long</span> <span class=n>d</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>multstore</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>d</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>  <span class=n>printf</span><span class=p>(</span><span class=s>&#34;2 * 3 --&gt; %ld</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>d</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>long</span> <span class=nf>mult2</span><span class=p>(</span><span class=kt>long</span> <span class=n>a</span><span class=p>,</span> <span class=kt>long</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>long</span> <span class=n>s</span> <span class=o>=</span> <span class=n>a</span> <span class=o>*</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>s</span><span class=p>;</span> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><p>那么通过<code>gcc -Og -o prog main.c mstore.c</code>命令生成的可执行文件 prog 的大小就超过了 mstore.o，因为它还包含了用于启动和终止程序以及与操作系统交互的代码。同样对 prog 文件使用<code>objdump</code>命令进行反汇编，其输出结果包含如下代码：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211007151414.png alt=20211007151414></p><p>与第一次反汇编的结果相比，区别主要在：</p><ul><li>链接器将代码的地址（Offset）移动到了不同的地址范围内，因此左侧的地址不同；</li><li>链接器的一项任务是将函数调用与这些函数的可执行代码的位置进行匹配。因此在结果第 4 行，链接器填充了<code>callq</code>指令在调用函数<code>mult2</code>时应该使用的地址；</li><li>结果第 8，9 行填充的代码对结果没有任何影响，nop 意为 no operation。插入它们是为了将函数的代码增加到 16 字节，这样可以更好地放置下一个代码块，从而提升存储器的系统性能。</li></ul><h2 id=数据格式><a href=#数据格式 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:数据格式 class=headings>数据格式</a></h2><p>Intel 用术语“字”（word）来表示 16 位数据类型，因此 32 位数称为“双字”（double words），64 位数称为“四字”（quad words）。在 x86-64 机器上 C 的原始数据类型大小如下：</p><div class=table-container><table><thead><tr><th>C declaration</th><th>Intel data type</th><th>Assembly-code suffix</th><th>Size(bytes)</th></tr></thead><tbody><tr><td>char</td><td>Byte</td><td>b</td><td>1</td></tr><tr><td>short</td><td>Word</td><td>w</td><td>2</td></tr><tr><td>int</td><td>Double word</td><td>l</td><td>4</td></tr><tr><td>long</td><td>Quad word</td><td>q</td><td>8</td></tr><tr><td>char *</td><td>Quad word</td><td>q</td><td>8</td></tr><tr><td>float</td><td>Single precision</td><td>s</td><td>4</td></tr><tr><td>double</td><td>Double precision</td><td>l</td><td>8</td></tr></tbody></table></div><p>大多数由 gcc 生成的汇编代码都有一个表示操作数大小的单字符后缀，如数据移动指令有四种变体：<code>movb</code>（移动字节）、<code>movw</code>（移动字）、<code>movl</code>（移动双字）和<code>movq</code>（移动四字）。值得一提是，后缀“l”即可以表示 4 字节整数又表示 8 字节双精度浮点数。这并不会引起歧义，因为涉及到浮点数的代码使用一组与整数完全不同的指令和寄存器。</p><h2 id=访问信息><a href=#访问信息 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:访问信息 class=headings>访问信息</a></h2><p>上文提到，x86-64 机器的 CPU 中包含 16 个通用寄存器（general-purpose registers），均可以存储 64 位的整数或指针数据：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20210728231051.png alt=20210728231051></p><p>图中所有寄存器的名称均以 %r 开头，它们的演变顺序是从右往左的。前 8 个寄存器，即 %ax 到 %sp，是最初的 8086 机器使用的 8 个 16 位寄存器。随着 IA32 的出现，它们被扩展位 32 位，即 %eax 到 %esp。目前的 x86-64 机器将其进一步地扩展为 64 位，即 %rax 到 %rsp。同时还新添加了 8 个寄存器，即 %r8 到 %r15。图中右侧的注释说明了各个寄存器在典型程序中扮演的角色，其中最独特的是栈指针 %rsp，它用于指示运行时栈的结束位置。</p><p>指令可以对存储在寄存器低位字节中的不同大小的数据进行操作。字节级操作可以访问最低有效字节，16 位操作可以访问最低有效 2 个字节，32 位操作可以访问最低有效 4 个字节，64 位操作则可以访问整个寄存器。</p><h3 id=操作数><a href=#操作数 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:操作数 class=headings>操作数</a></h3><p>大多数指令都有一个或多个操作数（operand），指定了执行操作时使用的源数据和结果放置的位置。x86-64 机器支持的操作数格式如下：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20210728232301.png alt=20210728232301></p><p>源数据既可以以常数形式给出，也可以从寄存器或内存中读取，结果则存储在寄存器或内存中。因此操作数有三种可能的类型：</p><ul><li>立即数（immediate）：即常数值，书写方式为 $ 符号后面跟一个整数；</li><li>寄存器（register）：寄存器中的内容。我们使用 $r_a$ 表示任意寄存器 $a$，使用 $R[r_a]$ 来表示它的值；</li><li>内存（memory）引用：根据计算出的地址（称为有效地址）来访问某个内存位置。使用 $M_b[Addr]$ 表示在内存中从地址 $Addr$ 开始 $b$ 字节的引用，下角标 $b$ 可以省略。</li></ul><p>最通用的内存引用方式在上表底部：$M[Imm + R[r_b] + R[r_i]\times s]$，常用于引用数组元素。</p><p>假设下列值存储在内存或寄存器中指定的地址处：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211007152556.png alt=20211007152556></p><p>那么以下操作数存储的值分别为：</p><ul><li><code>%rax</code>：0x100</li><li><code>0x104</code>：地址为 0x104，值为 0xAB</li><li><code>$0x108</code>：0x108（立即数）</li><li><code>(%rax)</code>：地址为 0x100，值为 0xFF</li><li><code>9(%rax,%rdx)</code>：地址为 9 + 0x100 + 0x3 = 0x10C，值为 0x11</li><li><code>260(%rcx,%rdx)</code>：260 即十六进制数 0x104，因此地址为 0x104 + 0x1 + 0x3 = 0x108，值为 0x13</li><li><code>0xFC(,%rcx,4)</code>：地址为 0xFC + 0x1 * 4 = 0x100，值为 0xFF</li><li><code>%rax,%rdx,4</code>：地址为：0x100 + 0x3 * 4 = 0x10C，值为 0x11</li></ul><h3 id=数据移动指令><a href=#数据移动指令 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:数据移动指令 class=headings>数据移动指令</a></h3><p>在所有机器指令中使用最为频繁的便是数据移动指令，它们负责将数据从一处移动到另一处。我们将操作相同但操作数尺寸不同的指令划分为同一个指令类（instruction classes），下表列出的便是 MOV 指令类中的各种操作：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211007160353.png alt=20211007160353></p><p>上表中的 S 代表 源地址（Source），D 代表目的地址（Destination），I 代表立即数（Immediate），R 代表寄存器（Register）。其中，移动指令不能将一个位于内存中的数据直接移动到内存中的另一个位置，必须经过一个寄存器中转。另外，当<code>movl</code>指令的目的地址为一个寄存器时，它不仅会把目的寄存器的较低四位更新为源数据，还会将较高四位的字节全部置 0。最后，<code>movabsq</code>指令只能将寄存器作为数据的目的地址（R &lt;- I）。下面的例子中，左边为顺序执行的移动指令，右边为寄存器 %rax 中字节的变化情况：</p><pre tabindex=0><code class=language-assembly data-lang=assembly>movabsq $0x0011223344556677, %rax            %rax = 0011223344556677
movb $-1, %al                                %rax = 00112233445566FF
movw $-1, %ax                                %rax = 001122334455FFFF
movl $-1, %eax                               %rax = 00000000FFFFFFFF
movq $-1, %rax                               %rax = FFFFFFFFFFFFFFFF
</code></pre><p>还有两类数据移动指令可以将较小尺寸的源数据移动到较大尺寸的目的寄存器，如下表所示：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211007174422.png alt=20211007174422></p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211007174503.png alt=20211007174503></p><p>两者不同的是，<code>movz</code>指令将目的寄存器的剩余字节均填充为 0（零扩展），<code>movs</code>指令则将其填充为源操作数的最高有效位（符号扩展）。相比于符号扩展，零扩展缺少了指令<code>movzlq</code>。这是因为上文提到，使用<code>movl</code>指令移动数据到寄存器时，会将高位全部置为 0，其效果与零扩展无异。另外，符号扩展还多了一个指令<code>cltq</code>。它没有操作数，且实际上等效于<code>movslq %eax, %rax</code>。</p><p>在 C 中，引用指针（dereference pointer，*p）会将指针拷贝到寄存器中，然后将该寄存器作为内存地址的引用。如下面的一个简单的 C 程序：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>long</span> <span class=nf>exchange</span><span class=p>(</span><span class=kt>long</span> <span class=o>*</span><span class=n>xp</span><span class=p>,</span> <span class=kt>long</span> <span class=n>y</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>long</span> <span class=n>x</span> <span class=o>=</span> <span class=o>*</span><span class=n>xp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=o>*</span><span class=n>xp</span> <span class=o>=</span> <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><p>与之等效的汇编代码如下：</p><pre tabindex=0><code class=language-assembly data-lang=assembly>; xp in %rdi, y in %rsi
exchange:
  movq (%rdi), %rax
  movq %rsi, (%rdi)
  ret
</code></pre><p>最后两个数据移动指令分别是将数据压入程序栈（Stack）的<code>push</code>和将数据从程序栈中弹出的<code>pop</code>，如下表所示：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211007211436.png alt=20211007211436></p><p>在 x86-64 中，程序栈存储在内存中的某些区域中，其特性为后进先出（last-in, first-out）。习惯上我们将栈顶画在底端，而栈顶元素的地址（由栈指针 %rsp 保存）是整个栈中最小的：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211007212847.png alt=20211007212847></p><p>如上图所示，想要将一个四字数据压入栈中，首先要把栈指针减 8，然后令源数据值成为新的栈顶元素。因此指令<code>pushq %rax</code>就等效于：</p><pre tabindex=0><code class=language-assembly data-lang=assembly>; subq 为减法运算，下一节会进行介绍
subq $8, &amp;rsp
movq %rax, (%rsp)
</code></pre><p>同样，若想将栈顶的四字数据弹出栈，首先要把栈顶元素的值拷贝到寄存器中，然后再把栈指针加 8。因此指令<code>popq %rdx</code>就等效于：</p><pre tabindex=0><code class=language-assembly data-lang=assembly>movq (%rsp), %rdx
; addq 为加法运算，下一节会进行介绍
addq $8, %rsp
</code></pre><h2 id=算术和逻辑操作><a href=#算术和逻辑操作 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:算术和逻辑操作 class=headings>算术和逻辑操作</a></h2><p>下图列出了一些 x86-64 中的整数算数和逻辑操作，其中除了<code>leaq</code>外给出的都是指令类：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211008215219.png alt=20211008215219></p><p>上述操作可分为四类：加载有效地址（load effective address）、一元（unary）、二元（binary）和移位（shifts）。一元操作只有一个操作数，而二元操作则有两个。接下来我们将分别介绍它们。</p><h3 id=加载有效地址><a href=#加载有效地址 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:加载有效地址 class=headings>加载有效地址</a></h3><p>加载有效地址的指令名为<code>leaq</code>，其实质是<code>movq</code>指令的一种变体。它会从内存中读取源操作数的地址拷贝到寄存器中，有时候也实现一些简单的运算。如寄存器 %rdx 中存储的值为 x，那么指令<code>leaq 7(%rdx, %rdx, 4), %rax</code>的作用便是将寄存器 %rax 的值设为 5x+7。虽然<code>leaq</code>指令在执行运算方面的能力是有限的，但是与加法（<code>ADD</code>）或乘法（<code>IMUL</code>）指令相比，它的性能更加出色。</p><h3 id=一元和二元操作><a href=#一元和二元操作 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:一元和二元操作 class=headings>一元和二元操作</a></h3><p>一元操作只有一个操作数，因此源地址和目的地址相同。如操作<code>incq (%rsp)</code>可以将程序栈顶增加 8 个字节的元素，类似于 C 中的自增运算符<code>++</code>。</p><p>二元操作类似于 C 中的赋值运算符（assignment operator），如 <code>x -= y</code>。举例来说，操作<code>subq %rax, %rdx</code>会将寄存器 %rdx 中的值减去寄存器 %rax 中的值。第一个操作数可以是立即数、寄存器或内存中的位置，第二个操作数则只能是寄存器或内存中的位置。参考<code>MOV</code>类指令，二元操作的两个操作数不能同时为内存中的位置。</p><h3 id=移位操作><a href=#移位操作 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:移位操作 class=headings>移位操作</a></h3><p>移位操作的第一个操作符为位数，可以是立即数，也可以是单字节的寄存器（通常使用寄存器 %cl）。第二个操作数为移位的值。可以是寄存器或内存中的位置。对于右移运算来说，<code>sar</code>代表算术右移，<code>shr</code>则代表逻辑右移。</p><h3 id=特殊算数操作><a href=#特殊算数操作 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:特殊算数操作 class=headings>特殊算数操作</a></h3><p>两个 64 位整型的积需要用 128 位来表示，因此 Intel 引入了 16 字节单位“八字”（ oct word）来解决这一问题。下表展示了一些支持运算结果为“八字”的操作：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211008224011.png alt=20211008224011></p><p>我们在普通算数操作和特殊算数操作中均发现了<code>imulq</code>指令。第一种属于 <code>IMUL</code>类，有两个操作数。其计算结果为 64 位（若超过 64 位，则截断高位），等效于第二章介绍的 <a href=/posts/representing-and-manipulating-information-note/#%E6%97%A0%E7%AC%A6%E5%8F%B7%E4%B9%98%E6%B3%95>无符号乘法</a> 和 <a href=/posts/representing-and-manipulating-information-note/#%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A5%E7%A0%81%E4%B9%98%E6%B3%95>二进制补码乘法</a>。第二种即是上表中的特殊算数操作，只有一个操作数，因此编译器可以根据操作数的数量区分它们。</p><p>用于有符号乘法的操作称为<code>imulq</code>，用于无符号乘法的为<code>mulq</code>。两者的第一个参数为寄存器 %rax，第二个参数为源操作数。计算结果中较高 64 位将存储在寄存器 %rdx 中，较低 64 位则存储在寄存器 %rax 中。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;inttypes.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>typedef</span> <span class=kt>unsigned</span> <span class=n>__int128</span> <span class=n>uint128_t</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>store_uprod</span><span class=p>(</span><span class=n>uint128_t</span> <span class=o>*</span><span class=n>dest</span><span class=p>,</span> <span class=kt>uint64_t</span> <span class=n>x</span><span class=p>,</span> <span class=kt>uint64_t</span> <span class=n>y</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=n>dest</span> <span class=o>=</span> <span class=n>x</span> <span class=o>*</span> <span class=p>(</span><span class=n>uint128_t</span><span class=p>)</span><span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><p>所示的 C 程序在小端（little-endian）机器上可转化为如下的汇编代码，结果中的较高位存储在高地址处 8(%rdi)：</p><pre tabindex=0><code class=language-x86asm data-lang=x86asm>; dest in %rdi, x in %rsi, y in %rdx
store_uprod
  movq %rsi, %rax
  mulq %rdx
  movq %rax, (%rdi)
  movq %rdx, 8(%rdi)
</code></pre><p>普通算数操作中没有提供除法或余数运算，因此需要使用特殊算数操作<code>idivq</code>和<code>divq</code>。与乘法类似，被除数的较高 64 位将存储在寄存器 %rdx 中，较低 64 位存储在寄存器 %rax 中。除数为操作数，商保存在寄存器 %rax 中，余数则保存在寄存器 %rdx 中。如果被除数只有 64 位，那么就应当将寄存器 %rdx 全部置为 0（无符号运算）或符号位（有符号运算）。后者可以使用<code>cqto</code>操作实现，它会从寄存器 %rax 中读取符号位，然后将其拷贝到寄存器 %rdx 的每一位中。</p><h2 id=控制><a href=#控制 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:控制 class=headings>控制</a></h2><p>上文中介绍的操作只考虑了顺序执行的代码，对于 C 中的 if、for、while 和 switch 语句，它们需要根据数据检验的结果来决定代码执行的顺序。机器级代码提供了两种基本机制来实现这种条件行为（conditional behavior），一种根据检验结果改变控制流（control flow），另一种则改变数据流（data flow）</p><h3 id=条件码><a href=#条件码 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:条件码 class=headings>条件码</a></h3><p>CPU 维护了一组单字节的条件码（condition code）寄存器，它们记录了最近一次算数或逻辑操作结果的某些属性：</p><ul><li>CF（carry flag）：进位标识，记录最高有效位是否发生进位，用于检测无符号数操作的溢出；</li><li>ZF（zero flag）：零标识，记录结果是否为 0；</li><li>SF（sign flag）：符号标识，记录结果是否为负值；</li><li>OF（overflow flag）：溢出标识，记录是否发生二进制补码溢出。</li></ul><p>下列两个指令类可以在不改变任何其他寄存器的情况下设置条件码，如指令<code>testq %rax, %rax</code>可以检测寄存器 %rax 存储的值是正数、负数还是零：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211011224454.png alt=20211011224454></p><p>相比于直接读取，我们更常用以下三种方式使用条件码：</p><ul><li>根据条件码的组合将单个字节设置为 0 或 1；</li><li>有条件地跳转到程序的其他部分；</li><li>有条件地传输数据。</li></ul><p>下列操作指令便可以实现上述第一种方式。注意，此处的指令后缀代表的并非是不同的操作数大小，而是不同的条件判断。如指令<code>setl</code>和<code>setb</code>分别代表 set less 和 set below：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211011225955.png alt=20211011225955></p><p>下面示例的 C 程序中，首先比较了变量 a 和 b 的大小，然后根据结果把寄存器 %eax 的最低字节（即寄存器 %al）置为 0 或 1。最后一条指令的作用是将寄存器 %eax 的高位三个字节以及寄存器 %rax 的高位四个字节全部清零：</p><pre tabindex=0><code class=language-x86asm data-lang=x86asm>; int comp(data_t a, data_t b)
; a in rdi%, b in rsi%
comp:
  cmpq %rsi, %rdi
  setl %al
  movzbl %al, %eax
  ret
</code></pre><h3 id=跳转指令><a href=#跳转指令 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:跳转指令 class=headings>跳转指令</a></h3><p>跳转指令可以让程序转到一个全新的位置继续执行，该位置在汇编代码中使用标签（label）来指定。</p><pre tabindex=0><code class=language-x86asm data-lang=x86asm>  movq $0, %rax
  jmp .L1
  movq (rax%), %rdx
.L1:
  popq %rdx
</code></pre><p>指令<code>jmp .L1</code>将使程序跳过<code>movq</code>指令，开始执行<code>popq</code>操作。 下图展示了不同的跳转指令：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211013222734.png alt=20211013222734>​</p><p><code>jmp</code>指令既可以是直接跳转，也可以是间接跳转。直接跳转的目标使用标签指定，而间接跳转的目标则需要从寄存器或内存中读取。其余的指令均为条件跳转，它们根据条件判断的结果来决定是否执行跳转操作。注意，条件跳转均为直接跳转。</p><p>在生成机器代码的过程中，汇编器和链接器（linker）会确定跳转目标（即目标指令的地址），并编码为跳转指令的一部分。其使用的编码方式有多种，但大多数与程序计数器（PC）相关，即比较目标指令的地址和紧挨着跳转指令的下一条指令的地址之间的差异。这样的说法有些绕口，我们以一个简单的例子来说明：</p><pre tabindex=0><code class=language-x86asm data-lang=x86asm>  movq %rdi%, %rax
  jmp .L2
.L3
  sarq %rax
.L2
  testq %rax, %rax
  jq .L3
  rep; ret
</code></pre><p>该汇编代码包含了两个跳转指令，第一个跳转到了更高的地址处，第二个则相反。而下图是对上述代码汇编然后再进行反汇编后的结果：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211014012100.png alt=20211014012100></p><p>在右侧注释中，第一个跳转指令为 +0x8，第二个跳转指令为 +0x5。再看左侧指令的字节编码，第一个指令的目标被编码为 0x03，将其加上下一条指令的地址 0x5，就得到了跳转目标指令的地址，即第四行指令的地址 0x8。同样，第二个指令的目标被编码为 0xf8，将其加上下一条指令的地址 0xd，就得到了第三行指令的地址 0x3。</p><p>当目标代码文件经过链接器处理后，这些指令会被重新分配地址。不过第二行和第五行跳转目标的编码依然不变，这种方式能够让指令编码更加紧凑：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211014012501.png alt=20211014012501></p><h3 id=使用条件控制实现条件分支><a href=#使用条件控制实现条件分支 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:使用条件控制实现条件分支 class=headings>使用条件控制实现条件分支</a></h3><p>若想将 C 中的条件表达式转化为机器代码，通常使用条件跳转和无条件跳转的组合。一个简单的 C 程序及其编译得到的汇编代码分别如下：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>long</span> <span class=nf>absdiff</span><span class=p>(</span><span class=kt>long</span> <span class=n>x</span><span class=p>,</span> <span class=kt>long</span> <span class=n>y</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>long</span> <span class=n>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>x</span> <span class=o>&lt;</span> <span class=n>y</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>result</span> <span class=o>=</span> <span class=n>y</span> <span class=o>-</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=n>result</span> <span class=o>=</span> <span class=n>x</span> <span class=o>-</span> <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><pre tabindex=0><code class=language-x86asm data-lang=x86asm>; long absdiff(long x, long y) 
; x in %rdi, y in %rsi 
absdiff:
  cmpq %rsi, %rdi
  jge .L2
  movq %rsi, %rax
  subq %rdi, %rax
  ret
.L2
  movq %rdi, %rax
  subq %rsi, %rax
  ret
</code></pre><p>实际上该汇编代码的控制流（control flow）更像是使用 goto 语句将示例 C 程序改写后得到的结果，即先比较两数大小，然后根据结果决定是否跳转：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>long</span> <span class=nf>gotodiff</span><span class=p>(</span><span class=kt>long</span> <span class=n>x</span><span class=p>,</span> <span class=kt>long</span> <span class=n>y</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>long</span> <span class=n>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>x</span> <span class=o>&gt;=</span> <span class=n>y</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>goto</span> <span class=n>x_ge_y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=n>y</span> <span class=o>-</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nl>x_ge_y</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=n>x</span> <span class=o>-</span> <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><p>让我们推广到一般情况。假设 C 中的 if-else 语句模板为：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>test</span><span class=o>-</span><span class=n>expr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>then</span><span class=o>-</span><span class=n>statement</span>
</span></span><span class=line><span class=cl><span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=o>-</span><span class=n>statement</span>
</span></span></code></pre></td></tr></table></div></div></div><p>那么编译生成的汇编代码的控制流便可以用如下 C 程序描述：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>    <span class=n>t</span> <span class=o>=</span> <span class=n>test</span><span class=o>-</span><span class=n>expr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>t</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>goto</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>then</span><span class=o>-</span><span class=n>statement</span>
</span></span><span class=line><span class=cl>    <span class=k>goto</span> <span class=n>done</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nb>false</span><span class=o>:</span>
</span></span><span class=line><span class=cl><span class=k>else</span><span class=o>-</span><span class=n>statement</span>
</span></span><span class=line><span class=cl><span class=nl>done</span><span class=p>:</span>
</span></span></code></pre></td></tr></table></div></div></div><h3 id=使用条件移动实现条件分支><a href=#使用条件移动实现条件分支 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:使用条件移动实现条件分支 class=headings>使用条件移动实现条件分支</a></h3><p>使用条件控制实现条件分支虽然简单有效，但在现代处理器上使用可能十分低效，我们更倾向于使用一些简单的条件移动指令。上一节中的 C 程序可以改写为：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>long</span> <span class=nf>cmovdiff</span><span class=p>(</span><span class=kt>long</span> <span class=n>x</span><span class=p>,</span> <span class=kt>long</span> <span class=n>y</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>long</span> <span class=n>rval</span> <span class=o>=</span> <span class=n>y</span> <span class=o>-</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>long</span> <span class=n>eval</span> <span class=o>=</span> <span class=n>x</span> <span class=o>-</span> <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>long</span> <span class=n>ntest</span> <span class=o>=</span> <span class=n>x</span> <span class=o>&gt;=</span> <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* Line below requires
</span></span></span><span class=line><span class=cl><span class=cm>    single instruction: */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>ntest</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>rval</span> <span class=o>=</span> <span class=n>eval</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>rval</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><p>这段代码首先计算 y-x 和 x-y，分别命名为变量 rval 和变量 eval。然后测试 x 是否大于或等于 y，如果是，则在返回 rval 之前将 eval 赋值给 rval。编译器可以参考这种控制流生成汇编代码：</p><pre tabindex=0><code class=language-x86asm data-lang=x86asm>; long absdiff(long x, long y)
; x in %rdi, y in %rsi
absdiff:
  movq %rsi, %rax
  subq %rdi, %rax
  movq %rdi, %rdx
  subq %rsi, %rdx
  cmpq %rsi, %rdi
  cmovge %rdx, %rax
  ret
</code></pre><p>上述代码中的<code>comovge</code>就是一个条件移动指令，只有 <code>cmpq</code> 指令判断一个值大于或等于（如后缀 ge 所示）另一个值时，它才会将数据从源寄存器传输到目标寄存器。</p><p>想要理解为什么基于条件移动的代码效率胜过条件控制，我们必须了解现代处理器的运行方式。一条指令需要处理器通过一系列的步骤进行处理，每个步骤只执行所该指令的一小部分（例如，从内存中获取指令，确定指令类型、从内存读取、执行算术运算、写入内存和更新程序计数器等）。为了实现高性能，这条流水线（pipelining）需要将指令的步骤重叠。例如，在执行前一条指令的算术运算的同时提取下一条指令。想要做到这一点，处理器需要能够提前确定即将执行的指令序列，以保证流水线上充满指令。</p><p>当处理器遇到条件跳转（即分支）时，它将采用复杂的逻辑来预测跳转指令是否触发。如果预测结果足够可靠（现代微处理器试图达到 90% 的成功率），流水线就可以保持指令充满。但是，错误的预测将导致处理器不得不丢弃它在未来指令上已经完成的大部分工作，使程序性能严重下降。</p><p>示例代码中 x >= y 的判断结果显然是难以预测的，这种情况下使用条件控制代码的效率很低。而条件移动代码先计算出所有可能的结果，再根据条件判断决定返回值。这样控制流便不再依赖数据，处理器也就更容易保持其流水线的完整性，从而提升执行效率。全部的条件移动指令如下：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211031214307.png alt=20211031214307></p><p>编译器可以从目标寄存器的名称推断条件移动指令的操作数长度，因此相同的指令名称可用于不同的操作数长度。我们同样把条件分支推广到一般情况，使用 C 程序来描述条件移动的控制流：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>v</span> <span class=o>=</span> <span class=n>then</span> <span class=o>-</span> <span class=n>expr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>ve</span> <span class=o>=</span> <span class=k>else</span> <span class=o>-</span> <span class=n>expr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>t</span> <span class=o>=</span> <span class=n>test</span> <span class=o>-</span> <span class=n>expr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>t</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>v</span> <span class=o>=</span> <span class=n>ve</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div></div><p>当然，使用条件移动来实现条件分支是也有一些弊端的。因为无论判断结果如何，我们都会全部执行 then-expr 和 else-expr。一旦某一个分支中的指令发生错误，将影响整个程序的可用性。另外，如果 then-expr 或 else-expr 需要大量计算，而对应的条件又不成立时，处理器所做的工作就完全白费了。不过总体来说，条件移动的性能还是高于条件控制的，这也是 GCC 编译器使用它的原因。</p><h3 id=循环><a href=#循环 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:循环 class=headings>循环</a></h3><h4 id=do-while><a href=#do-while class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:do-while class=headings>Do-While</a></h4><p>假设 C 中的 Do-While 语句模板为：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>do</span>
</span></span><span class=line><span class=cl>    <span class=n>body</span><span class=o>-</span><span class=n>statement</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>text</span><span class=o>-</span><span class=n>expr</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div></div><p>我们可以将其转化为 goto 语句和 if-else 语句的组合：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=nl>loop</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>body</span><span class=o>-</span><span class=n>statement</span>
</span></span><span class=line><span class=cl>    <span class=n>t</span> <span class=o>=</span> <span class=n>text</span><span class=o>-</span><span class=n>expr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>t</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>goto</span> <span class=n>loop</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div></div><p>实际上汇编代码正是用这种方式来实现 Do-While 语句的控制流 。示例函数<code>fact_do</code>及其编译得到的汇编代码分别如下：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>long</span> <span class=nf>fact_do</span><span class=p>(</span><span class=kt>long</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>long</span> <span class=n>result</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>do</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>result</span> <span class=o>*=</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>n</span> <span class=o>=</span> <span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>while</span> <span class=p>(</span><span class=n>n</span> <span class=o>&gt;</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><pre tabindex=0><code class=language-x86asm data-lang=x86asm>; long fact_do(long n)
; n in %rdi
fact_do:
  movl $1, %eax
.L2:
  imulq %rdi, %rax
  subq $1, %rdi
  cmpq $1, %rdi
  jq .L2
  rep; ret
</code></pre><h4 id=while><a href=#while class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:while class=headings>While</a></h4><p>假设 C 中的 While 语句模板为：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=n>text</span><span class=o>-</span><span class=n>expr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>body</span><span class=o>-</span><span class=n>statement</span>
</span></span></code></pre></td></tr></table></div></div></div><p>我们有两种方法将其转化为 goto 语句和 if-else 语句的组合。第一种称为 jump-to-middle，通过一个非条件跳转在循环的结束执行条件判断：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>    <span class=k>goto</span> <span class=n>test</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nl>loop</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>body</span><span class=o>-</span><span class=n>statement</span>
</span></span><span class=line><span class=cl><span class=nl>test</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>t</span> <span class=o>=</span> <span class=n>text</span><span class=o>-</span><span class=n>expr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>t</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>goto</span> <span class=n>loop</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div></div><p>当 GCC 的优化参数指定为 -Og 时，汇编代码就会用这种方法来实现 While 语句的控制流 。示例函数<code>fact_while</code>及其编译得到的汇编代码分别如下：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>long</span> <span class=nf>fact_while</span><span class=p>(</span><span class=kt>long</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>long</span> <span class=n>result</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>n</span> <span class=o>&gt;</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>result</span> <span class=o>*=</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>n</span> <span class=o>=</span> <span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><pre tabindex=0><code class=language-x86asm data-lang=x86asm>; long fact_while(long n)
; n in %rdi
fact_while:
  movl $1, %eax 
  jmp .L5
.L6:
  imulq %rdi, %rax 
  subq $1, %rdi
.L5: 
  cmpq $1, %rdi
  jg .L6
  rep; ret
</code></pre><p>第二种方法称为 guarded-do，即首先将代码转化为 Do-While 循环，如果条件判断失败则通过条件移动指令跳过循环：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>    <span class=n>t</span> <span class=o>=</span> <span class=n>test</span><span class=o>-</span><span class=n>expr</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>t</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>goto</span> <span class=n>done</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nl>loop</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>body</span><span class=o>-</span><span class=n>statement</span> 
</span></span><span class=line><span class=cl>    <span class=n>t</span> <span class=o>=</span> <span class=n>test</span><span class=o>-</span><span class=n>expr</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>t</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>goto</span> <span class=n>loop</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nl>done</span><span class=p>:</span>
</span></span></code></pre></td></tr></table></div></div></div><p>当 GCC 的优化参数指定为更高级别的 -O1 时，汇编代码就会用这种方法来实现 While 语句的控制流 。上面提到的函数<code>fact_while</code>使用 guarded-do 编译得到的汇编代码如下：</p><pre tabindex=0><code class=language-x86asm data-lang=x86asm>; long fact_while(long n) 
; n in %rdi
fact_while
  cmpq $1, %rdi
  jle .L7
  movl $1, %eax
.L6:
  imulq %rdi, %rax
  subq $1, %rdi
  cmpq $1, %rdi
  jne .L6
  rep; ret
.L7
  movl $1, %eax
  ret
</code></pre><h4 id=for><a href=#for class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:for class=headings>For</a></h4><p>假设 C 中的 For 语句模板为：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=n>init</span><span class=o>-</span><span class=n>expr</span><span class=p>;</span> <span class=n>test</span><span class=o>-</span><span class=n>expr</span><span class=p>;</span> <span class=n>update</span><span class=o>-</span><span class=n>expr</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=n>body</span><span class=o>-</span><span class=n>statement</span>
</span></span></code></pre></td></tr></table></div></div></div><p>显然可以将其转化为等效的 While 语句：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>init</span><span class=o>-</span><span class=n>expr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=n>test</span><span class=o>-</span><span class=n>expr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>body</span><span class=o>-</span><span class=n>statement</span>
</span></span><span class=line><span class=cl>    <span class=n>update</span><span class=o>-</span><span class=n>expr</span><span class=p>;</span> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><p>因此，我们依然可以使用两种方法来将其转化为 goto 语句和 if-else 语句的组合。</p><p>jump-to-middle：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>    <span class=n>init</span><span class=o>-</span><span class=n>expr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>goto</span> <span class=n>test</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nl>loop</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>body</span><span class=o>-</span><span class=n>statement</span>
</span></span><span class=line><span class=cl>    <span class=n>update</span><span class=o>-</span><span class=n>expr</span><span class=p>;</span> 
</span></span><span class=line><span class=cl><span class=nl>test</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>t</span> <span class=o>=</span> <span class=n>test</span><span class=o>-</span><span class=n>expr</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>t</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>goto</span> <span class=n>loop</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div></div><p>guarded-do：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>    <span class=n>init</span><span class=o>-</span><span class=n>expr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>t</span> <span class=o>=</span> <span class=n>test</span><span class=o>-</span><span class=n>expr</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>t</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>goto</span> <span class=n>done</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nl>loop</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>body</span><span class=o>-</span><span class=n>statement</span> 
</span></span><span class=line><span class=cl>    <span class=n>update</span><span class=o>-</span><span class=n>expr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>t</span> <span class=o>=</span> <span class=n>test</span><span class=o>-</span><span class=n>expr</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>t</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>goto</span> <span class=n>loop</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nl>done</span><span class=p>:</span>
</span></span></code></pre></td></tr></table></div></div></div><p>同样地，编译器会根据给定的优化参数使用对应的控制流来生成汇编代码。</p><h3 id=switch><a href=#switch class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:switch class=headings>Switch</a></h3><p>GCC 会根据 Switch 语句中 Case 的数量和 Case 值的稀疏性（sparsity）决定编译方法。当存在多种 Case（例如四个或更多），且它们跨越的值范围较小时会使用一种名为跳转表（jump table）的数据结构来实现。跳转表是一个数组，数组元素分别是 Switch 语句中每个 Case 对应的代码块地址。</p><p>一个简单的 C 程序及其通过 GCC 编译后得到的汇编代码分别如下：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>switch_eg</span><span class=p>(</span><span class=kt>long</span> <span class=n>x</span><span class=p>,</span> <span class=kt>long</span> <span class=n>n</span><span class=p>,</span> <span class=kt>long</span> <span class=o>*</span><span class=n>dest</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>long</span> <span class=n>val</span> <span class=o>=</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>switch</span> <span class=p>(</span><span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=mi>100</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=n>val</span> <span class=o>*=</span> <span class=mi>13</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=mi>102</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=n>val</span> <span class=o>+=</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* Fall through */</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=mi>103</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=n>val</span> <span class=o>+=</span> <span class=mi>11</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=mi>104</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=mi>106</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=n>val</span> <span class=o>*=</span> <span class=n>val</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>default</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=n>val</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=n>dest</span> <span class=o>=</span> <span class=n>val</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><pre tabindex=0><code class=language-x86asm data-lang=x86asm>; void switch_eg(long x, long n, long *dest) 
; x in %rdi, n in %rsi, dest in %rdx 
switch_eg:
  subq $100, %rsi
  cmpq $6, %rsi
  ja .L8
  jmp *.L4(,%rsi,8)
.L3:
  leaq (%rdi,%rdi,2), %rax
  leaq (%rdi,%rax,4), %rdi
  jmp .L2
.L5:
  addq $10, %rdi
.L6:
  addq $11, %rdi
  jmp .L2
.L7:
  imulq %rdi, %rdi
  jmp .L2
.L8:
  movl $0, %edi
.L2:
  movq %rdi, (%rdx)
  ret
</code></pre><p>为了便于理解，我们用 C 来描述其实现（运算符<code>&&</code>会为代码块的位置创建指针）：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>switch_eg_impl</span><span class=p>(</span><span class=kt>long</span> <span class=n>x</span><span class=p>,</span> <span class=kt>long</span> <span class=n>n</span><span class=p>,</span> <span class=kt>long</span> <span class=o>*</span><span class=n>dest</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* Table of code pointers */</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=kt>void</span> <span class=o>*</span><span class=n>jt</span><span class=p>[</span><span class=mi>7</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=o>&amp;&amp;</span><span class=n>loc_A</span><span class=p>,</span> <span class=o>&amp;&amp;</span><span class=n>loc_def</span><span class=p>,</span> <span class=o>&amp;&amp;</span><span class=n>loc_B</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=o>&amp;&amp;</span><span class=n>loc_C</span><span class=p>,</span> <span class=o>&amp;&amp;</span><span class=n>loc_D</span><span class=p>,</span> <span class=o>&amp;&amp;</span><span class=n>loc_def</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=o>&amp;&amp;</span><span class=n>loc_D</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>index</span> <span class=o>=</span> <span class=n>n</span> <span class=o>-</span> <span class=mi>100</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>long</span> <span class=n>val</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>index</span> <span class=o>&gt;</span> <span class=mi>6</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>goto</span> <span class=n>loc_def</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* Multiway branch */</span>
</span></span><span class=line><span class=cl>    <span class=k>goto</span> <span class=o>*</span><span class=n>jt</span><span class=p>[</span><span class=n>index</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=nl>loc_A</span><span class=p>:</span> <span class=cm>/* Case 100 */</span>
</span></span><span class=line><span class=cl>    <span class=n>val</span> <span class=o>=</span> <span class=n>x</span> <span class=o>*</span> <span class=mi>13</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>goto</span> <span class=n>done</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nl>loc_B</span><span class=p>:</span> <span class=cm>/* Case 102 */</span>
</span></span><span class=line><span class=cl>    <span class=n>val</span> <span class=o>=</span> <span class=n>x</span> <span class=o>+</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nl>loc_C</span><span class=p>:</span> <span class=cm>/* Case 103 */</span>
</span></span><span class=line><span class=cl>    <span class=n>val</span> <span class=o>=</span> <span class=n>x</span> <span class=o>+</span> <span class=mi>11</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>goto</span> <span class=n>done</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nl>loc_D</span><span class=p>:</span> <span class=cm>/* Case 104, 106 */</span>
</span></span><span class=line><span class=cl>    <span class=n>val</span> <span class=o>=</span> <span class=n>x</span> <span class=o>*</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>goto</span> <span class=n>done</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nl>loc_def</span><span class=p>:</span> <span class=cm>/* Default case */</span>
</span></span><span class=line><span class=cl>    <span class=n>val</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nl>done</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=n>dest</span> <span class=o>=</span> <span class=n>val</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><p>其中的<code>goto *jt[index]</code>就相当于汇编代码中第五行的<code>jmp *.L4(,%rsi,8)</code>。它是一个间接跳转指令，其操作数<code>.L4(,%rsi,8)</code>指定了由寄存器 %rsi 索引的内存地址（我们将在后续章节讨论数组是如何转化为机器代码的）。</p><p>在汇编代码中，跳转表将被表示为：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211103000139.png alt=20211103000139></p><p>在名为<code>.rodata</code>的只读目标代码段中，包含了由七个<code>quad</code>（八字节）组成的序列，每个<code>quad</code>的值为汇编代码标签（如<code>.L3</code>）所对应的指令地址。</p><h2 id=过程><a href=#过程 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:过程 class=headings>过程</a></h2><p>过程（Procedure）在不同的编程语言中有不同的叫法，如函数（Function）、方法（Method）、子程序（Subroutine）和 Handler 等。不过它们都提供了一种打包代码的方法，该代码使用一组参数和可选的返回值来实现某些功能，并可以在程序的不同位置调用。</p><p>假设过程 P 调用了过程 Q，Q 执行完毕后返回 P。那么：</p><ul><li>传递控制：在调用 Q 时程序计数器必须设置为其代码地址，同时在返回 P 时也要置为 P 的代码地址；</li><li>传递参数：P 必须能向 Q 提供一个或多个参数，反之 Q 必须能将值返回给 P；</li><li>分配和释放内存：在调用 Q 之前可能需要为其局部变量分配内存空间，并在返回时释放。</li></ul><h3 id=运行时栈><a href=#运行时栈 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:运行时栈 class=headings>运行时栈</a></h3><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211103221350.png alt=20211103221350></p><p>当过程所需的存储空间超过寄存器所能容纳的范围时，它便会在运行时栈上分配空间。上图为运行时栈的一般结构，主要由执行过程 Q 和调用过程 P 所需的帧（Frame）组成。每个过程可以在其栈帧内保存寄存器的值（图中的 Saved registers），为局部变量分配空间（图中的 Local Variables），以及为其调用的过程设置参数（图中的 Argument）等。当 P 调用 Q 时，它会将返回地址（图中 Return Address）压入栈中。这样当 Q 返回时，程序便知道应该在哪里恢复执行 P。</p><p>不过出于对时间和空间效率的考虑，程序只会为过程分配它们必须的栈帧。例如某个过程的参数不足 6 个，那么它们将全部存储在寄存器中而非运行时栈（图中的参数区是从 Argument 7 开始的）。许多过程的局部变量很少且不调用其他过程，那么就不需要运行时栈。</p><p>接下来我们会对运行时栈中的各个区域进行更为深入地讨论。</p><h3 id=传递控制><a href=#传递控制 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:传递控制 class=headings>传递控制</a></h3><p>在汇编代码中，过程间调用是通过指令<code>call</code>和<code>ret</code>来实现的。其中，指令<code>call Q</code>会将程序计数器设置为过程 Q 的代码起始地址，并将返回地址 A 压入栈中。指令<code>ret</code>则会将地址 A 从栈中弹出，然后将程序计数器设置为 A。实际上，地址 A 就是紧跟在<code>call</code>指令之后的指令地址。</p><p>下图说明了 <a href=/posts/machine-level-representation-of-programs-note/#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B>代码示例</a> 中主函数调用 multstore 后返回的过程中运行时栈的变化情况：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211104221557.png alt=20211104221557></p><p>其对应的反汇编代码如下：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211104222239.png alt=20211104222239></p><p>当主函数调用函数 multstore 时，程序计数器 %rip 中的值为<code>call</code>指令的地址 0x400563。该指令将返回地址 0x400568 压入栈中并跳转到函数 multstore 中的第一条指令，其地址为 0x0400540。 随后函数 multstore 继续执行，直到遇到地址 0x40054d 处的<code>ret</code>指令。 该指令将返回地址 0x400568 从栈中弹出并跳转到该地址对应的指令，主函数得以继续执行。</p><h3 id=传递参数><a href=#传递参数 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:传递参数 class=headings>传递参数</a></h3><p>在 x86-64 机器上，最多可以通过寄存器传递六个参数：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211104224830.png alt=20211104224830></p><p>参数从第七个开始将存储在运行时栈中。一个简单的 C 程序及其通过 GCC 编译后得到的汇编代码分别如下：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>proc</span><span class=p>(</span><span class=kt>long</span> <span class=n>a1</span><span class=p>,</span> <span class=kt>long</span> <span class=o>*</span><span class=n>a1p</span><span class=p>,</span>
</span></span><span class=line><span class=cl>          <span class=kt>int</span> <span class=n>a2</span><span class=p>,</span> <span class=kt>int</span> <span class=o>*</span><span class=n>a2p</span><span class=p>,</span>
</span></span><span class=line><span class=cl>          <span class=kt>short</span> <span class=n>a3</span><span class=p>,</span> <span class=kt>short</span> <span class=o>*</span><span class=n>a3p</span><span class=p>,</span>
</span></span><span class=line><span class=cl>          <span class=kt>char</span> <span class=n>a4</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>a4p</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=n>a1p</span> <span class=o>+=</span> <span class=n>a1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=n>a2p</span> <span class=o>+=</span> <span class=n>a2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=n>a3p</span> <span class=o>+=</span> <span class=n>a3</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=n>a4p</span> <span class=o>+=</span> <span class=n>a4</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211109231344.png alt=20211109231344></p><p>虽然参数<code>a4</code>的类型为 char，但程序分别通过<code>8(%rsp)</code>和<code>16(%rsp)</code>来对它和指针类型的<code>a4p</code>进行寻址，说明两者均占用了栈中 8 个字节的空间。参数的栈帧结构如下图所示：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211109231455.png alt=20211109231455></p><h3 id=局部变量><a href=#局部变量 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:局部变量 class=headings>局部变量</a></h3><p>某些情况下，局部变量必须存储在运行时栈中：</p><ul><li>没有足够的寄存器来存储局部变量；</li><li>程序需要对局部变量进行取地址（<code>&</code>）操作；</li><li>局部变量的类型为数组或结构体（我们将在后续的章节中讨论这种情况）。</li></ul><p>示例函数<code>call_proc</code>的代码如下，其中调用的函数<code>proc</code>在上一节中已有介绍：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>long</span> <span class=nf>call_proc</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>long</span> <span class=n>x1</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>x2</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>short</span> <span class=n>x3</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>x4</span> <span class=o>=</span> <span class=mi>4</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>proc</span><span class=p>(</span><span class=n>x1</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>x1</span><span class=p>,</span> <span class=n>x2</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>x2</span><span class=p>,</span> <span class=n>x3</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>x3</span><span class=p>,</span> <span class=n>x4</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>x4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=n>x1</span> <span class=o>+</span> <span class=n>x2</span><span class=p>)</span> <span class=o>*</span> <span class=p>(</span><span class=n>x3</span> <span class=o>-</span> <span class=n>x4</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><p>该 C 程序生成的汇编代码十分冗长，但值得我们认真阅读和研究：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211110223306.png alt=20211110223306></p><p>图中<code>Set up arguments to proc</code>阶段对应的栈帧结构如下图所示：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211110223714.png alt=20211110223714></p><p>我们可以看到，局部变量<code>x1</code>到<code>x4</code>存储在栈中且有着不同的大小，分别占用字节 24-31、20-23、18-19 和 17。指向这些参数的指针均通过指令<code>leaq</code>生成，分别对应汇编代码中的第 7、10、12 和 14 行。前六个参数通过寄存器传递，而第七个和第八个参数则存储在栈中，相对于栈指针 %rsp 的偏移量为 0 和 8。</p><p>当程序执行到<code>Call proc</code>阶段时，由于调用了函数<code>proc</code>，因此返回地址需要被压入到栈顶。此时的栈帧结构和上一节展示的相同，第七个参数和第八个参数相对于栈指针 %rsp 的偏移量分别变为了 8 和 16。</p><h3 id=被保存的寄存器><a href=#被保存的寄存器 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:被保存的寄存器 class=headings>被保存的寄存器</a></h3><p>当一个过程（调用者）在调用另一个过程（被调用者）时，我们必须保证被调用者的执行不会影响到调用者后续计划使用的寄存器值。因此，x86-64 规定寄存器 %rbx、%rbp 和 %r12–%r15 为被调用者保存（callee-saved）寄存器。被调用者通过将上述寄存器中的值压入栈中，然后在返回时将原始值弹出以实现调用前后寄存器的值不变。除栈指针 %rsp 以外的其他寄存器则为调用者保存（caller-saved）寄存器，由于被调用者可以随意修改其中的值，因此调用者有责任保存调用之前的数据。</p><h3 id=递归recursive><a href=#递归recursive class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:递归recursive class=headings>递归（Recursive）</a></h3><p>x86-64 允许过程以递归的方式调用自身，这是因为每个过程在运行时栈上的空间是私有的，因此多个未完成调用的局部变量不会互相干扰。递归调用实质上和调用一个其他过程没有区别。</p><h2 id=数组><a href=#数组 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:数组 class=headings>数组</a></h2><p>对于长度为 L 的数据类型 T 和整型常量 N，声明<code>T A[N]</code>代表：</p><ul><li>内存中将为其分配 L * N 大小的空间；</li><li>数组名称 A 为指向数组头部（设为$x_A$）的指针，任意数组元素 i 的地址为 $x_A$ + L * i。</li></ul><p>在 x86-64 中，内存引用指令的设计旨在简化对数组元素的访问。例如 int 类型的数组 E[i]，E 的地址存储在寄存器 %rdx 中，i 则存储在寄存器 %rcx 中。那么我们就可以通过指令<code>movl(%rdx, %rcx, 4), %eax</code>来将目标数组元素拷贝到寄存器 %eax 中。</p><p>C 允许我们对指针进行计算。例如 p 是一个指向长度为 L 的数据类型为 T 的指针且 p 的值为 $x_p$，则表达式 p
+ i 的值为 $x_p$ + L * i。进一步地，任意数组元素 A[i] 就等效于表达式 *(A + i)。</p><p>还是以数组 E[i] 为例，一些指针算数表达式的结果和对应的汇编指令如下：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211111224620.png alt=20211111224620></p><p>最后一个例子表明，我们可以计算同一数据结构中两个指针的差值。其结果的数据类型为 long， 值为两个地址的差值除以数据类型的长度。</p><h3 id=多维数组><a href=#多维数组 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:多维数组 class=headings>多维数组</a></h3><p>多维数组可以转化为一般数组的形式，例如声明<code>int A[5][3]</code>就等效为：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=kt>int</span> <span class=n>row3_t</span><span class=p>[</span><span class=mi>3</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=n>row3_t</span> <span class=n>A</span><span class=p>[</span><span class=mi>5</span><span class=p>];</span>
</span></span></code></pre></td></tr></table></div></div></div><p>数据类型 row3_t 是一个包含三个整型的数组，而数组 A 则包含五个这样的元素。我们将其推广到一般情况，若一个数组声明为<code>T D[R][C]</code>，则数组元素<code>D[i][j]</code>在内存中的地址为：</p><p>$$\tag{3.1} \And D[i][j] = x_D + L(C * i + j)$$</p><p>其中，$x_D$ 为数组地址，L 为数组元素的长度。</p><p>一个 5 X 3 的整型数组 A，其任意数组元素 A[i][j] 的地址用汇编代码的表示结果为：</p><pre tabindex=0><code class=language-x86asm data-lang=x86asm>; A in %rdi, i in % rsi and j in %rdx
; Compute 3i
leaq (%rsi, %rsi, 2), %rax
; Compute A + 12i
leaq (%rdi, %rax, 4), %rax
; Read from M[A + 12i + 4j]
movl (%rax, %rdx, 4), %rax
</code></pre><h3 id=定长数组><a href=#定长数组 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:定长数组 class=headings>定长数组</a></h3><p>编译器可以对一些操作定长多维数组的代码进行优化。例如一个进行矩阵运算的 C 程序：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#define N 16
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>typedef</span> <span class=kt>int</span> <span class=n>fix_matrix</span><span class=p>[</span><span class=n>N</span><span class=p>][</span><span class=n>N</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=cm>/* Compute i,k of fixed matrix product */</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>fix_prod_ele</span><span class=p>(</span><span class=n>fix_matrix</span> <span class=n>A</span><span class=p>,</span> <span class=n>fix_matrix</span> <span class=n>B</span><span class=p>,</span> <span class=kt>long</span> <span class=n>i</span><span class=p>,</span> <span class=kt>long</span> <span class=n>k</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>long</span> <span class=n>j</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>result</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>N</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>result</span> <span class=o>+=</span> <span class=n>A</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>*</span> <span class=n>B</span><span class=p>[</span><span class=n>j</span><span class=p>][</span><span class=n>k</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><p>它可以被优化为下列代码：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#define N 16
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>typedef</span> <span class=kt>int</span> <span class=n>fix_matrix</span><span class=p>[</span><span class=n>N</span><span class=p>][</span><span class=n>N</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=cm>/* Compute i,k of fixed matrix product */</span>
</span></span><span class=line><span class=cl><span class=n>fix_prod_ele_opt</span><span class=p>(</span><span class=n>fix_matrix</span> <span class=n>A</span><span class=p>,</span> <span class=n>fix_matrix</span> <span class=n>B</span><span class=p>,</span> <span class=kt>long</span> <span class=n>i</span><span class=p>,</span> <span class=kt>long</span> <span class=n>k</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=o>*</span><span class=n>Aptr</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>A</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=mi>0</span><span class=p>];</span>   <span class=cm>/* Points to elements in row i of A    */</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=o>*</span><span class=n>Bptr</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>B</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=n>k</span><span class=p>];</span>   <span class=cm>/* Points to elements in column k of B */</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=o>*</span><span class=n>Bend</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>B</span><span class=p>[</span><span class=n>N</span><span class=p>][</span><span class=n>k</span><span class=p>];</span>   <span class=cm>/* Marks stopping point for Bptr */</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>result</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>do</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>                              <span class=cm>/* No need for initial test */</span>
</span></span><span class=line><span class=cl>        <span class=n>result</span> <span class=o>+=</span> <span class=o>*</span><span class=n>Aptr</span> <span class=o>*</span> <span class=o>*</span><span class=n>Bptr</span><span class=p>;</span>   <span class=cm>/* Add next product to sum */</span>
</span></span><span class=line><span class=cl>        <span class=n>Aptr</span><span class=o>++</span><span class=p>;</span>                    <span class=cm>/* Move Aptr to next column */</span>
</span></span><span class=line><span class=cl>        <span class=n>Bptr</span> <span class=o>+=</span> <span class=n>N</span><span class=p>;</span>                 <span class=cm>/* Move Bptr to next row */</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>while</span> <span class=p>(</span><span class=n>Bptr</span> <span class=o>!=</span> <span class=n>Bend</span><span class=p>);</span>        <span class=cm>/* Test for stopping point */</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><p>比较两者我们可以发现，优化代码没有使用索引 j，并将所有的数组引用都转换为了指针引用。其中，<code>Aptr</code>指向矩阵 A 中第 i 行中的连续元素，<code>Bptr</code>指向矩阵 B 中第 k 列 中的连续元素。<code>Bend</code>则指向矩阵 B 中第 k 列中的第 N + 1 个元素，它就等于循环结束时<code>Bptr</code>的值。</p><h3 id=变长数组><a href=#变长数组 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:变长数组 class=headings>变长数组</a></h3><p>C 只支持可以在编译时确定长度的多维数组(一维可能除外），声明可变大小的数组时必须使用<code>malloc</code>或<code>calloc</code>等函数来分配数组的存储空间，并且需要通过行主索引（row-major indexing）将多维数组的映射显式编码为一维数组（就像 <a href=/posts/machine-level-representation-of-programs-note/#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84>公式 3.1</a> 做的那样）。</p><p>我们可以编写一个函数来访问 n × n 数组的元素 i, j，如下所示：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>var_ele</span><span class=p>(</span><span class=kt>long</span> <span class=n>n</span><span class=p>,</span> <span class=kt>int</span> <span class=n>A</span><span class=p>[</span><span class=n>n</span><span class=p>][</span><span class=n>n</span><span class=p>],</span> <span class=kt>long</span> <span class=n>i</span><span class=p>,</span> <span class=kt>long</span> <span class=n>j</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>A</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><p>参数<code>n</code>必须在参数<code>A[n][n]</code>之前，这样函数在处理数组时才能够明确其维度。该程序经 GCC 编译得到的汇编代码如下：</p><pre tabindex=0><code class=language-x86asm data-lang=x86asm>; int var_ele(long n, int A[n][n], long i, long j)
; n in %rdi, A in %rsi, i in %rdx, j in %rcx 
var_ele:
  ； Compute n * i
  imulq %rdx, %rdi
  ; Compute A + 4(n * i)
  leaq (%rsi,%rdi,4), %rax
  ; Read from M[A + 4(n * i) + j]
  movl (%rax,%rcx,4), %eax
  ret
</code></pre><p>数组元素 A[i][j] 地址的计算方式与定长多维数组类似，即 $x_A + 4(n * i) + 4j = x_A + 4(n * i + j)$。区别之处在于：</p><ul><li>由于添加了变量<code>n</code>，寄存器的使用方式不同；</li><li>使用了乘法指令<code>imulq</code>而不是<code>leaq</code>来计算 n * i，因此将导致程序性能的损失。</li></ul><p>无论数组的长度是否为常量，编译器都会对操作多维数组的代码进行一定优化。虽然二者实现的细节有所差异，但其宗旨是一致的：避免直接使用 <a href=/posts/machine-level-representation-of-programs-note/#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84>公式 3.1</a> 而导致的乘法运算。</p><h2 id=异构数据结构><a href=#异构数据结构 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:异构数据结构 class=headings>异构数据结构</a></h2><h3 id=结构体><a href=#结构体 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:结构体 class=headings>结构体</a></h3><p>结构体（Structure）的每个部分都存储在连续的内存空间中，指向结构体的指针是其第一个字节的地址。一个简单的结构体声明如下：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>rec</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>j</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>a</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=o>*</span><span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div></div><p>该结构体包含了 4 个 字段：2 个 4 字节的 int 变量，1 个两元素 int 型数组和一个 8 字节的 int 型指针，共占用 24 字节的内存空间：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211115220443.png alt=20211115220443></p><p>汇编代码可以通过在结构体地址上添加适当的偏移量来访问结构体中的任意字段。假设<code>structure rec *</code>类型的变量<code>r</code>存储在寄存器 %rdi 中，那么下列代码将元素<code>r -> i</code>，即<code>(*r).i</code>，拷贝到<code>r -> j</code>：</p><pre tabindex=0><code class=language-x86asm data-lang=x86asm>movl (%rdi), %eax
movl %eax, 4(%rdi)
</code></pre><p>同样，如果我们要获取结构体中数组元素<code>rec.a[i]</code>的地址<code>&(r -> a[i])</code>，只需：</p><pre tabindex=0><code class=language-x86asm data-lang=x86asm>; r in %rdi, i in %rdi
leaq 8(%rdi, %rsi, 4), %rax
</code></pre><p>如上述汇编代码所示，程序对结构体字段的选择是在编译时完成的，因此机器代码中不含有任何有关字段声明或字段名称的信息。</p><h3 id=联合体><a href=#联合体 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:联合体 class=headings>联合体</a></h3><p>联合体（Unions）的声明和语法与结构体相同，但其不同字段均引用相同的内存空间。例如一个结构体和一个联合体的声明如下：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>S3</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>c</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=kt>double</span> <span class=n>v</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>union</span> <span class=n>U3</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>c</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=kt>double</span> <span class=n>v</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div></div><p>那么<code>S3</code>和<code>U3</code>各个字段的偏移量和总数据长度为：</p><div class=table-container><table><thead><tr><th>Type</th><th>c</th><th>i</th><th>v</th><th>Size</th></tr></thead><tbody><tr><td>S3</td><td>0</td><td>4</td><td>16</td><td>24</td></tr><tr><td>U3</td><td>0</td><td>0</td><td>0</td><td>8</td></tr></tbody></table></div><p>对于类型为<code>union U3 *</code>的指针<code>p</code>，表达式<code>p -> c</code>，<code>p -> i[0]</code>和<code>p -> v</code>都将引用联合体的起始地址。联合体的长度等于其所有字段中最大的数据长度，而结构体则等于其所有字段长度的和。我们将在下一节 <a href=/posts/machine-level-representation-of-programs-note/#%E6%95%B0%E6%8D%AE%E5%AF%B9%E9%BD%90>数据对齐</a> 中介绍为什么<code>i</code>在<code>S3</code>中的偏移量是 4 而不是 1，以及<code>v</code>的偏移量是 16，而不是 9 或 12。</p><p>如果一个数据结构中的两个字段是互斥（mutually exclusive）的，我们就可以使用联合体来减少空间浪费。假如存在一个二叉树，其每个叶节点（leaf node）都有两个双精度浮点值，每个内部节点（internal node）都有两个指向子节点的指针。那么使用结构体实现该数据结构的代码为：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>node_s</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// for internal node
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>node_s</span> <span class=o>*</span><span class=n>left</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>node_s</span> <span class=o>*</span><span class=n>right</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// for leaf node
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>double</span> <span class=n>data</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div></div><p>这样每个节点都需要占用 32 字节的空间，其中只有一半会被节点真正使用。而如果我们使用联合体来实现：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>union</span> <span class=n>node_u</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>union</span> <span class=n>node_u</span> <span class=o>*</span><span class=n>left</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>union</span> <span class=n>node_u</span> <span class=o>*</span><span class=n>right</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=n>internal</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>double</span> <span class=n>data</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div></div><p>则每个节点就只需占用 16 个字节的空间。对于类型为<code>union node_u *</code>的指针<code>n</code>，叶节点可以用<code>n -> data[0]</code>和<code>n -> data[1]</code>来表示，而内部节点指向的子节点可以用<code>n -> internal.left</code>和<code>n -> internal.right</code>来表示。</p><p>联合体还可用于访问不同数据类型的位模式（bit pattern）。假设我们需要将一个 double 类型的变量强制转换为 unsigned long，则可以用如下方法实现：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>unsigned</span> <span class=kt>long</span> <span class=nf>double2bits</span><span class=p>(</span><span class=kt>double</span> <span class=n>d</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>union</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>double</span> <span class=n>d</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>u</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=n>temp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>temp</span><span class=p>.</span><span class=n>d</span> <span class=o>=</span> <span class=n>d</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>temp</span><span class=p>.</span><span class=n>u</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div></div><p>该代码将两种数据类型均存储在联合体<code>temp</code>中，使其有着相同的位级表达，从而实现了类型转换。</p><h3 id=数据对齐><a href=#数据对齐 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:数据对齐 class=headings>数据对齐</a></h3><p>许多计算机系统要求某些对象的地址必须是某个值（通常为 2，4或8）的倍数，其目的是简化处理器和内存系统之间的硬件接口设计。假设一个处理器每次都从内存中读取 8 个字节，而一个 double 类型的数据地址为 8 的倍数，那么它就可以被一次内存访问操作读取或写入。否则，它会被拆分为两个 8 字节的内存块，导致处理器操作次数的增加。</p><p>无论数据对齐是否实现，x86-64 的硬件都将正常工作。但是 Intel 建议对齐数据以提高内存系统性能，其规则为：任何 K 字节对象的地址必须为 K 的倍数：</p><div class=table-container><table><thead><tr><th>K</th><th>Types</th></tr></thead><tbody><tr><td>1</td><td>char</td></tr><tr><td>2</td><td>short</td></tr><tr><td>4</td><td>int, float</td></tr><tr><td>8</td><td>long, double, char *</td></tr></tbody></table></div><p>编译器会在汇编代码中放置指令，指示全局数据所需的对齐方式。比如我们在介绍跳转表时，示例代码中的<code>.align 8</code>就代表该指令后面的数据地址均为 8 的倍数。对于涉及到结构体的代码，编译器可能还需要在字段分配空间时插入间隙以实现数据对齐。一个简单结构体的声明如下：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>S1</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>c</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>j</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div></div><p>编译器实际为其分配的内存空间为：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211117223136.png alt=20211117223136></p><p>即然各字段的偏移量均为 4 的倍数，那么只要起始地址也为 4 的倍数，该结构体就实现了数据对齐。</p><h2 id=机器级代码中控制和数据的组合><a href=#机器级代码中控制和数据的组合 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:机器级代码中控制和数据的组合 class=headings>机器级代码中控制和数据的组合</a></h2><h3 id=理解指针><a href=#理解指针 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:理解指针 class=headings>理解指针</a></h3><ul><li>指针不是机器代码的一部分，而是 C 提供的一种用来帮助程序员避免寻址错误的抽象；</li><li>每个指针都有一个关联的类型。特殊的指针类型<code>void *</code>代表通用（范型）指针，可以显式或隐式地转换为有关联类型的指针；</li><li>每个指针都有一个值，其值为指定类型的某个对象的地址。若指针的值为<code>NULL(0)</code>，则代表它没有指向任何地方；</li><li>指针是用操作符<code>&</code>创建的，在机器代码中常用<code>leaq</code>指令实现；</li><li>使用操作符<code>*</code>来引用指针；</li><li>数组和指针之间关系密切；</li><li>指针可以被强制类型转换，但不会改变其值；</li><li>指针也可以指向函数，使程序可以在其他地方调用代码，其值为函数的机器代码中第一条指令的地址。</li></ul><p>例如一个函数的原型为：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>fun</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=o>*</span><span class=n>p</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div></div><p>我们可以声明一个指针来指向它：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>fp</span><span class=p>)(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span> <span class=o>*</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>fp</span> <span class=o>=</span> <span class=n>fun</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div></div><p>这样便可以使用指针来调用该函数：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=n>y</span> <span class=o>=</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>result</span> <span class=o>=</span> <span class=n>fp</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>y</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div></div><h3 id=内存引用越界和缓冲区溢出><a href=#内存引用越界和缓冲区溢出 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:内存引用越界和缓冲区溢出 class=headings>内存引用越界和缓冲区溢出</a></h3><p>C 不会对数组引用做任何的边界检查，这可能导致存储在栈中的数据因写入越界（out-of-bounds）的数组元素而损坏。如果程序随后以这种状态重新加载寄存器或执行<code>ret</code>指令，事情可能会变得十分严重。</p><p>一种常见的状态损坏原因称为缓存区溢出（buffer overflow），比较典型的例子是字符串的长度超过了栈中为其分配的字符数组空间：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/* Implementation of library function gets() */</span>
</span></span><span class=line><span class=cl><span class=kt>char</span> <span class=o>*</span><span class=nf>gets</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=n>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>c</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=o>*</span><span class=n>dest</span> <span class=o>=</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>((</span><span class=n>c</span> <span class=o>=</span> <span class=n>getchar</span><span class=p>())</span> <span class=o>!=</span> <span class=sc>&#39;\n&#39;</span> <span class=o>&amp;&amp;</span> <span class=n>c</span> <span class=o>!=</span> <span class=n>EOF</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=n>dest</span><span class=o>++</span> <span class=o>=</span> <span class=n>c</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>c</span> <span class=o>==</span> <span class=n>EOF</span> <span class=o>&amp;&amp;</span> <span class=n>dest</span> <span class=o>==</span> <span class=n>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* No characters read */</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=n>dest</span><span class=o>++</span> <span class=o>=</span> <span class=sc>&#39;\0&#39;</span><span class=p>;</span> <span class=cm>/* Terminate string */</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=cm>/* Read input line and write it back */</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>echo</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>buf</span><span class=p>[</span><span class=mi>8</span><span class=p>];</span> <span class=cm>/* Way too small! */</span>
</span></span><span class=line><span class=cl>    <span class=n>gets</span><span class=p>(</span><span class=n>buf</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>puts</span><span class=p>(</span><span class=n>buf</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><p>上半部分代码展示了库函数<code>gets</code>的实现过程：它首先从标准输入中读取一行字符串，当遇到换行符或某些错误条件时停止；然后它将读取内容复制到参数<code>s</code>指向的位置上，并以字符<code>null</code>结尾。<code>gets</code>的问题在于其无法确定是否分配了足够的空间来保存读取到的字符串。而在下半部分的函数<code>echo</code>中，我们故意将缓冲区做得非常小（只有 8 个字节），因此任何超过 7 个字符的字符串都会导致越界写入。随着字符串长度的增加，受到影响的栈区域会越来越多：</p><div class=table-container><table><thead><tr><th>Character typed</th><th>Additional corrupted state</th></tr></thead><tbody><tr><td>0-7</td><td>None</td></tr><tr><td>9-23</td><td>Unused stack space</td></tr><tr><td>24-31</td><td>Return Address</td></tr><tr><td>32+</td><td>Saved state in caller</td></tr></tbody></table></div><p>编译器为函数<code>echo</code>分配了 24 个字节的空间，因此读取少于 23 个字符的内容不会发生严重后果。但一旦超出这个范围，返回指针的值和其他保存的状态就会被破坏，<code>ret</code>指令将导致程序跳转到一个完全不可预知的位置。</p><h3 id=阻止缓冲区溢出攻击><a href=#阻止缓冲区溢出攻击 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:阻止缓冲区溢出攻击 class=headings>阻止缓冲区溢出攻击</a></h3><p>缓冲区溢出甚至会导致计算机受到网络攻击，危害系统安全。受到攻击的程序会接受一个字符串，包含一些可执行代码的字节编码（称为漏洞利用代码），以及一些额外字节。只要额外字节能够将返回地址覆盖为指向漏洞利用代码的指针，程序执行<code>ret</code>指令时就会跳转到漏洞利用代码。现代编译器和操作系统已经开始使用一些机制来抵御这种攻击。</p><h4 id=随机化栈><a href=#随机化栈 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:随机化栈 class=headings>随机化栈</a></h4><p>只要我们在程序开始运行时在栈上分配 0 到 n 个字节之间的随机空间（例如使用分配函数<code>alloca</code>），就可以让相同的代码在多次运行中使用不同的栈地址。分配的空间范围 n 需要足够大，以便栈地址能够发生足够的变化。但又要足够小，否则程序将浪费太多的内存空间。</p><p>不过攻击者可以在实际的漏洞利用代码前加入一长串的<code>nop</code>指令（即 no operation，不做任何操作），从而暴力攻克随机化栈。因此随机化栈可以增加成功攻击系统所需的工作量，但不能提供可靠完善的保障。</p><h4 id=栈损坏检测><a href=#栈损坏检测 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:栈损坏检测 class=headings>栈损坏检测</a></h4><p>我们还可以在局部缓冲区和栈的剩余部分之间插入一个金丝雀值（Canary）来检测栈是否损坏：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211123220533.png alt=20211123220533></p><h4 id=限制可执行代码区域><a href=#限制可执行代码区域 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:限制可执行代码区域 class=headings>限制可执行代码区域</a></h4><p>最后，我们可以限制只有保存了编译器生成的代码的那部分内存区域是可执行的，其他部分被限制为只读或只写。</p><h3 id=支持可变大小的栈帧><a href=#支持可变大小的栈帧 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:支持可变大小的栈帧 class=headings>支持可变大小的栈帧</a></h3><p>在之前我们介绍的汇编代码中，编译器为程序分配的运行时栈大小都是确定的。而有些程序则需要大小可变的运行时栈，例如：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>long</span> <span class=nf>vframe</span><span class=p>(</span><span class=kt>long</span> <span class=n>n</span><span class=p>,</span> <span class=kt>long</span> <span class=n>idx</span><span class=p>,</span> <span class=kt>long</span> <span class=o>*</span><span class=n>q</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>long</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>long</span> <span class=o>*</span><span class=n>p</span><span class=p>[</span><span class=n>n</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>p</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>q</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>*</span><span class=n>p</span><span class=p>[</span><span class=n>idx</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><p>函数<code>vframe</code>声明了一个变长的指针数组<code>*p[n]</code>，将在栈中占用 8n 个字节的空间。由于 n 的值是由函数第一个参数给出的，因此编译器无法确定要为该函数的运行时栈分配多少空间。另外，程序涉及了对局部变量<code>i</code>地址的引用，所以该变量必须存储在栈中。当函数返回时，运行时栈需要被回收，栈指针将指向存储返回地址的位置。</p><p>为了管理可变大小的栈帧，x86-64 使用寄存器 %rbp 作为帧指针（又称为基指针，base pointer）。栈帧结构如下图所示：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211123223334.png alt=20211123223334></p><p>上文提到，%rbp 是一个<a href=/posts/machine-level-representation-of-programs-note/#%E8%A2%AB%E4%BF%9D%E5%AD%98%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8>被调用者保存寄存器</a>，因此其原值将被保存在栈中（图中的 Saved %rbp）。在程序的执行过程中，%rbp 会一直指向这个位置。一些固定长度的局部变量，比如<code>i</code>，就可以根据其相对于 %rbp 的偏移量来引用。函数编译后生成的部分汇编代码如下：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211123224435.png alt=20211123224435></p><p>函数首先将 %rbp 压入栈中，然后将其置为当前运行时栈的地址（汇编代码第 2 到 3 行）。接下来在栈上分配了 16 个字节的空间，栈指针指向图中 s1 的位置。前 8 个字节用于存储局部变量<code>i</code>，后 8 个字节并未使用。然后它开始为数组<code>*p[n]</code>分配空间，栈指针指向图中 s2 的位置。其相对于 s1 的偏移量是通过汇编代码第 5 到 7 行计算得到的：</p><p>$$
(8n + 22) \And (-16)= \begin{cases}
8n + 8 &\text n 为奇数 \cr
8n + 16 &\text n 为偶数
\end{cases}
$$</p><p>由于该结果是 16 的倍数，因此实现了数据对齐。汇编代码第 8 到 10 行将图中 p 的值置为最接近 s2 的 8 的倍数，最终由寄存器 %rcx 中的值作为<code>*p[n]</code>的起始地址。假设 n 为 5 或 6，s1 的值为 2065 或 2064，则图中各值为：</p><div class=table-container><table><thead><tr><th>n</th><th>s1</th><th>s2</th><th>p</th><th>e1</th><th>e2</th></tr></thead><tbody><tr><td>5</td><td>2065</td><td>2017</td><td>2024</td><td>1</td><td>7</td></tr><tr><td>6</td><td>2064</td><td>2000</td><td>2000</td><td>16</td><td>0</td></tr></tbody></table></div><p>在函数执行结束前，汇编代码第 20 行的<code>leave</code>指令将帧指针恢复原值。相当于执行了以下两条指令：</p><pre tabindex=0><code class=language-x86asm data-lang=x86asm>; Set stack pointer to beginning of frame 
movq %rbp, %rsp
; Restore saved %rbp and set stack ptr
; to end of caller’s frame
popq %rbp
</code></pre><h2 id=浮点代码><a href=#浮点代码 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:浮点代码 class=headings>浮点代码</a></h2><p>处理器的浮点架构由操作浮点数的程序如何映射到机器级代码的不同方面组成，包括：</p><ul><li>浮点数是被如何被存储和访问的；</li><li>操作浮点数的指令；</li><li>浮点数如何作为参数传递给函数以及如何作为结果返回；</li><li>在函数调用时如何保存寄存器中的值。</li></ul><p>我们的内容基于 AVX2（Adcanced Vector Extensions2）扩展，可以在 GCC 编译时加入<code>-mavx2</code>参数以生成这种架构的代码。</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211125224206.png alt=20211125224206></p><p>如上图所示，AVX 架构允许浮点数存储在 16 个 YMM 寄存器中，每个长度均为 256 位（32 字节）。在对标量数据进行操作时，这些寄存器只会保存浮点型数据。而对于 float 类型和 double 类型，分别只有较低的 32 位和 64 位被使用。汇编代码通过 XMM 寄存器（即图中的 %xmm0–%xmm15）的名称来引用它们，每个 XMM 寄存器是其对应的 YMM 寄存器的低 128 位（16 字节）。</p><h3 id=浮点数的移动和转换操作><a href=#浮点数的移动和转换操作 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:浮点数的移动和转换操作 class=headings>浮点数的移动和转换操作</a></h3><p>下图展示了一组在内存和 XMM 寄存器之间和在两个 XMM 寄存器之间不进行类型转换的传输数据浮点数指令：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211128173012.png alt=20211128173012></p><p>前四个指令涉及到对内存的引用，我们称其为 Scalar 指令。它们操作的对象是单独的数值，只会改变目的寄存器低位的四字节或八字节。而后两个指令则属于 Packed 指令，它们会更新目的寄存器中全部的内容。</p><p>浮点数和整型之间进行转换的操作指令为：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211128212129.png alt=20211128212129></p><p>在 C 和大多数编程语言中，浮点数转换为整型时会先进行截断操作，将数值向零舍入。而整型转化为浮点数时，我们一般会忽略第二个源操作数，因为它只影响结果的高位字节。因此，通常情况下第二个源操作数和目的操作数是相同的。</p><p>最后则是两种浮点数（float 和 double）之间的类型转换。假设寄存器 %xmm0 的低位四字节保存了一个单精度浮点值，那么我们很容易使用指令<code>vcvtss2sd %xmm0, %xmm0, %xmm0</code>来把它转换为双精度浮点值然后再存储于寄存器 %xmm0 的低位八字节中。然而实际上 GCC 生成的汇编代码为：</p><pre tabindex=0><code class=language-x86asm data-lang=x86asm>; Replicate first vector element
vunpcklps %xmm0, %xmm0, %xmm0
; Convert two vector elements to double
vcvtps2pd %xmm0, %xmm0
</code></pre><p>指令<code>vunpcklps</code>会交错两个 XMM 寄存器中的值，并将它们存储在第三个寄存器中。举例来说，如果两个源寄存器中的值分别为$[s_3, s_2, s_1, s_0]$和$[d_3, d_2, d_1, d_0]$，那么目标寄存器的值就是$[s_1, d_1, s_0, d_0 ]$。在上述代码中，三个操作数使用相同的寄存器，因此如果寄存器 %xmm0 中的原始值为$[x_3, x_2, x_1, x_0]$，则该指令将更新其值为$[x_1, x_1, x_0, x_0]$。</p><p>指令<code>vcvtps2pd</code>将源 XMM 寄存器中的两个低位单精度值扩展为目的 XMM 寄存器中的两个双精度值。设 $dx_0$ 为将 $x_0$ 转换为双精度的结果，那么该指令将得出值$[dx_0, dx_0]$。综上，这两条指令的最终效果是将寄存器 %xmm0 中低位四字节中的原始单精度值转换为双精度值，并将它的两个副本存储在寄存器 %xmm0 中。</p><p>同样，GCC 为双精度值转换为单精度生成类似的汇编代码：</p><pre tabindex=0><code class=language-x86asm data-lang=x86asm>; Replicate first vector element
vmovddup %xmm0, %xmm0
; Convert two vector elements to single
vcvtpd2psx %xmm0, %xmm0
</code></pre><p>假设寄存器 %xmm0 中包含了两个双精度值$[x_1, x_0]$，则执行上述代码的结果为$[0.0, 0.0, x_0, x_0]$。</p><h3 id=过程中的浮点代码><a href=#过程中的浮点代码 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:过程中的浮点代码 class=headings>过程中的浮点代码</a></h3><p>观察图 3.45 中最右侧的注释，我们可以发现以下准则：</p><ul><li>最多可以使用 XMM 寄存器传递八个参数（%xmm0-%xmm7），其余的则需要通过栈；</li><li>和 %rax 类似，%xmm0 通常作为浮点数的返回寄存器；</li><li>所有 XMM 寄存器均为调用者保存（caller-saved），被调用者可以覆盖其中任意一个；</li><li>当函数参数是指针、整数和浮点数的组合时，指针和整数在通用寄存器中传递，而浮点值则在 XMM 寄存器中传递。</li></ul><h3 id=浮点数的算数操作><a href=#浮点数的算数操作 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:浮点数的算数操作 class=headings>浮点数的算数操作</a></h3><p>浮点数算数操作指令如下，每个指令都有一到两个源操作数和一个目的操作数。第一个源操作数可以是 XMM 寄存器或内存中的位置，第二个源操作数和目的操作数只能是 XMM 寄存器；</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211128224621.png alt=20211128224621></p><h3 id=浮点常量的定义和使用><a href=#浮点常量的定义和使用 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:浮点常量的定义和使用 class=headings>浮点常量的定义和使用</a></h3><p>与整数算术运算不同，AVX 浮点运算不能将立即数作为操作数。编译器必须为常量分配和初始化存储空间，再由代码从内存中读取值。</p><h3 id=浮点代码中的位级运算><a href=#浮点代码中的位级运算 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:浮点代码中的位级运算 class=headings>浮点代码中的位级运算</a></h3><p>下图展示了两个用于 XMM 寄存器的位级运算指令，其操作对象均为 Packed 数值（XMM 寄存器中全部的 128 位）：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20211129222149.png alt=20211129222149></p><h3 id=浮点数的比较操作><a href=#浮点数的比较操作 class=anchor-link><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:浮点数的比较操作 class=headings>浮点数的比较操作</a></h3><p>AVX 2 为浮点数值的比较运算提供两种操作指令：</p><div class=table-container><table><thead><tr><th>Instruction</th><th>Based on</th><th>Description</th></tr></thead><tbody><tr><td>ucomiss $S_1$, $S_2$</td><td>$S_2 - S_1$</td><td>Compare single precision</td></tr><tr><td>ucomisd $S_1$, $S_2$</td><td>$S_2 - S_1$</td><td>Compare double precision</td></tr></tbody></table></div><p>上述指令与 <a href=/posts/machine-level-representation-of-programs-note/#%E6%9D%A1%E4%BB%B6%E7%A0%81>条件码</a> 中介绍的 CMP 指令类相似。参数 $S_2$ 必须是 XMM 寄存器，而参数 $S_1$ 则既可以是 XMM 寄存器，又可以是内存中的位置。</p><p>浮点数比较操作会改变以下条件码的值，其中 PF 意为 Parity Flag：</p><div class=table-container><table><thead><tr><th>Ordering $S_2$:$S_1$</th><th>CF</th><th>ZF</th><th>PF</th></tr></thead><tbody><tr><td>Unordered</td><td>1</td><td>1</td><td>1</td></tr><tr><td>$S_2$ &lt; $S_1$</td><td>1</td><td>0</td><td>0</td></tr><tr><td>$S_2$ = $S_1$</td><td>0</td><td>1</td><td>0</td></tr><tr><td>$S_2$ > $S_1$</td><td>0</td><td>0</td><td>0</td></tr></tbody></table></div><p>当任意操作数为 NaN 时，Unordered 的情况就会出现。PF 的值将被置为 1，对应的跳转指令为<code>jp</code>。其余三种情况则和整型的 <a href=/posts/machine-level-representation-of-programs-note/#%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4>跳转指令</a> 相同，分别为<code>jb</code>、<code>je</code>和<code>ja</code>。</p></div><p class=edit-page><a href=https://github.com/koktlzz/koktlzz.github.io/blob/main/content/posts/machine-level-representation-of-programs-note.md><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-edit-2"><path d="M17 3a2.828 2.828.0 114 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>Edit this page on GitHub</a></p></article><div id=utterances></div></div></main><div id=back-to-top class=back-to-top><a href=#><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon arrow-up"><path d="M34.9 289.5l-22.2-22.2c-9.4-9.4-9.4-24.6.0-33.9L207 39c9.4-9.4 24.6-9.4 33.9.0l194.3 194.3c9.4 9.4 9.4 24.6.0 33.9L413 289.4c-9.5 9.5-25 9.3-34.3-.4L264 168.6V456c0 13.3-10.7 24-24 24h-32c-13.3.0-24-10.7-24-24V168.6L69.2 289.1c-9.3 9.8-24.8 10-34.3.4z"/></svg></a></div><footer id=footer class=footer><div class=footer-inner><div class=site-info>©&nbsp;2020–2022&nbsp;<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon footer-icon"><path d="M462.3 62.6C407.5 15.9 326 24.3 275.7 76.2L256 96.5l-19.7-20.3C186.1 24.3 104.5 15.9 49.7 62.6c-62.8 53.6-66.1 149.8-9.9 207.9l193.5 199.8c12.5 12.9 32.8 12.9 45.3.0l193.5-199.8c56.3-58.1 53-154.3-9.8-207.9z"/></svg>&nbsp;koktlzz</div><div class=powered-by>Powered by <a href=https://github.com/gohugoio/hugo target=_blank rel=noopener>Hugo</a> | Theme is <a href=https://github.com/reuixiy/hugo-theme-meme target=_blank rel=noopener>MemE</a></div><div class=site-copyright><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en target=_blank rel=noopener>CC BY-NC-SA 4.0</a></div><ul class=socials><li class=socials-item><a href=/rss.xml target=_blank rel="external noopener" title=RSS><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="icon social-icon"><path d="M19.199 24C19.199 13.467 10.533 4.8.0 4.8V0c13.165.0 24 10.835 24 24h-4.801zM3.291 17.415c1.814.0 3.293 1.479 3.293 3.295.0 1.813-1.485 3.29-3.301 3.29C1.47 24 0 22.526.0 20.71s1.475-3.294 3.291-3.295zM15.909 24h-4.665c0-6.169-5.075-11.245-11.244-11.245V8.09c8.727.0 15.909 7.184 15.909 15.91z"/></svg></a></li><li class=socials-item><a href=mailto:gwrhnu@163.com target=_blank rel="external noopener" title=Email><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon social-icon"><path d="M464 64H48C21.49 64 0 85.49.0 112v288c0 26.51 21.49 48 48 48h416c26.51.0 48-21.49 48-48V112c0-26.51-21.49-48-48-48zm0 48v40.805c-22.422 18.259-58.168 46.651-134.587 106.49-16.841 13.247-50.201 45.072-73.413 44.701-23.208.375-56.579-31.459-73.413-44.701C106.18 199.465 70.425 171.067 48 152.805V112h416zM48 4e2V214.398c22.914 18.251 55.409 43.862 104.938 82.646 21.857 17.205 60.134 55.186 103.062 54.955 42.717.231 80.509-37.199 103.053-54.947 49.528-38.783 82.032-64.401 104.947-82.653V4e2H48z"/></svg></a></li><li class=socials-item><a href=https://github.com/koktlzz target=_blank rel="external noopener" title=GitHub><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="icon social-icon"><path d="M12 .297c-6.63.0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577.0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93.0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176.0.0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22.0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22.0 1.606-.015 2.896-.015 3.286.0.315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg></a></li></ul></div></footer></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.css integrity="sha256-gPJfuwTULrEAAcI3X4bALVU/2qBU+QY/TpoD3GO+Exw=" crossorigin=anonymous><script>if(typeof renderMathInElement=="undefined"){var getScript=t=>{var e=document.createElement("script");e.defer=!0,e.crossOrigin="anonymous",Object.keys(t).forEach(n=>{e[n]=t[n]}),document.body.appendChild(e)};getScript({src:"https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.js",integrity:"sha256-YTW9cMncW/ZQMhY69KaUxIa2cPTxV87Uh627Gf5ODUw=",onload:()=>{getScript({src:"https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/contrib/mhchem.min.js",integrity:"sha256-yzSfYeVsWJ1x+2g8CYHsB/Mn7PcSp8122k5BM4T3Vxw=",onload:()=>{getScript({src:"https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/contrib/auto-render.min.js",integrity:"sha256-fxJzNV6hpc8tgW8tF0zVobKa71eTCRGTgxFXt1ZpJNM=",onload:()=>{renderKaTex()}})}})}})}else renderKaTex();function renderKaTex(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1}]})}</script><script>function loadComments(){(function(){var t=document.getElementById("utterances"),e=document.createElement("script");e.src="https://utteranc.es/client.js",e.async=!0,e.crossOrigin="anonymous",e.setAttribute("repo","koktlzz/koktlzz.github.io"),e.setAttribute("issue-term","pathname"),e.setAttribute("theme","github-light"),e.setAttribute("label","comment"),t.appendChild(e)})()}</script><script src=https://cdn.jsdelivr.net/npm/medium-zoom@latest/dist/medium-zoom.min.js></script>
<script>let imgNodes=document.querySelectorAll("div.post-body img");imgNodes=Array.from(imgNodes).filter(e=>e.parentNode.tagName!=="A"),mediumZoom(imgNodes,{background:"hsla(var(--color-bg-h), var(--color-bg-s), var(--color-bg-l), 0.95)"})</script><script src=https://cdn.jsdelivr.net/npm/instant.page@5.1.0/instantpage.min.js type=module defer></script></body></html>