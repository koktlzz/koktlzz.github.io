<!doctype html><html lang=en><head prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article#"><meta charset=UTF-8><meta name=generator content="Hugo 0.154.5"><meta name=theme-color content="#fff"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=format-detection content="telephone=no, date=no, address=no, email=no"><meta http-equiv=Cache-Control content="no-transform"><meta http-equiv=Cache-Control content="no-siteapp"><title>CSAPP 读书笔记：并发编程 | Inspire Hub</title><link rel=stylesheet href=/css/meme.min.29f06ccbcbf49b8f420fa6e6976a12c3760e5b7fc62170ba2f32d3e10a36c609.css><script src=https://cdn.jsdelivr.net/npm/lunr@2.3.9/lunr.min.js defer></script><script src=/js/meme.min.afe5e32f041c73f30c35ee4995b010968e55825ff6f568b51b055236df10a0fd.js></script><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=IBM+Plex+Serif:ital,wght@0,400;0,500;0,700;1,400;1,700&amp;family=Source+Code+Pro:ital,wght@0,400;0,700;1,400;1,700&amp;family=Comfortaa:wght@700&amp;display=swap" media=print onload='this.media="all"'><noscript><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=IBM+Plex+Serif:ital,wght@0,400;0,500;0,700;1,400;1,700&amp;family=Source+Code+Pro:ital,wght@0,400;0,700;1,400;1,700&amp;family=Comfortaa:wght@700&amp;display=swap"></noscript><meta name=author content><meta name=description content="根据第八章介绍的内容，两个在时间上重叠的逻辑控制流是并发的。硬件异常处理程序、进程和 Linux 信号处理程序等都是计算机系统在不同层级上对并发的应用。现代操作系统为构建并发程序提供了三种基本方法 …"><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=mask-icon href=/icons/safari-pinned-tab.svg color=#2a6df4><link rel=apple-touch-icon sizes=180x180 href=/icons/apple-touch-icon.png><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-title content="Inspire Hub"><meta name=apple-mobile-web-app-status-bar-style content="black"><meta name=mobile-web-app-capable content="yes"><meta name=application-name content="Inspire Hub"><meta name=msapplication-starturl content="../../"><meta name=msapplication-TileColor content="#fff"><meta name=msapplication-TileImage content="../../icons/mstile-150x150.png"><link rel=manifest href=/manifest.json><link rel=canonical href=/posts/concurrent-programming-note/><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","datePublished":"2022-08-25T15:31:42+01:00","dateModified":"2024-10-11T17:16:36+08:00","url":"/posts/concurrent-programming-note/","headline":"CSAPP 读书笔记：并发编程","description":"根据第八章介绍的内容，两个在时间上重叠的逻辑控制流是并发的。硬件异常处理程序、进程和 Linux 信号处理程序等都是计算机系统在不同层级上对并发的应用。现代操作系统为构建并发程序提供了三种基本方法 …","inLanguage":"en","articleSection":"posts","wordCount":3012,"image":["https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20220829163846.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20220829164820.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20220829222214.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20220829222709.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20220831234213.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20220907221941.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20220912235213.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20220913221845.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20220913224057.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20220913224916.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20220914000230.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20220914223735.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20220915001107.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20220915230021.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20220918212928.png","https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20220918230933.png"],"author":{"@type":"Person","url":"/"},"license":"[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)","publisher":{"@type":"Organization","name":"Inspire Hub","logo":{"@type":"ImageObject","url":"/icons/apple-touch-icon.png"},"url":"/"},"mainEntityOfPage":{"@type":"WebSite","@id":"/"}}</script><meta property="og:title" content="CSAPP 读书笔记：并发编程"><meta property="og:description" content="根据第八章介绍的内容，两个在时间上重叠的逻辑控制流是并发的。硬件异常处理程序、进程和 Linux 信号处理程序等都是计算机系统在不同层级上对并发的应用。现代操作系统为构建并发程序提供了三种基本方法 …"><meta property="og:url" content="/posts/concurrent-programming-note/"><meta property="og:site_name" content="Inspire Hub"><meta property="og:locale" content="en"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20220829163846.png"><meta property="og:type" content="article"><meta property="article:published_time" content="2022-08-25T15:31:42+01:00"><meta property="article:modified_time" content="2024-10-11T17:16:36+08:00"><meta property="article:section" content="posts"><link rel=preconnect href=https://www.google-analytics.com crossorigin><script async src="https://www.googletagmanager.com/gtag/js?id=G-D022F6NT2P"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-D022F6NT2P")</script></head><body><div class=container><header class=header><div class=header-wrapper><div class="header-inner single"><div class=site-brand><a href=/ class=brand>Inspire Hub</a></div><nav class=nav><ul class=menu id=menu><li class=menu-item><a href=/posts/><svg viewBox="0 0 512 512" class="icon archive"><path d="M32 448c0 17.7 14.3 32 32 32h384c17.7.0 32-14.3 32-32V160H32v288zm160-212c0-6.6 5.4-12 12-12h104c6.6.0 12 5.4 12 12v8c0 6.6-5.4 12-12 12H204c-6.6.0-12-5.4-12-12v-8zM480 32H32C14.3 32 0 46.3.0 64v48c0 8.8 7.2 16 16 16h480c8.8.0 16-7.2 16-16V64c0-17.7-14.3-32-32-32z"/></svg><span class=menu-item-name>Posts</span></a></li><li class=menu-item><a href=/series/><svg viewBox="0 0 512 512" class="icon th"><path d="M149.333 56v80c0 13.255-10.745 24-24 24H24c-13.255.0-24-10.745-24-24V56c0-13.255 10.745-24 24-24h101.333c13.255.0 24 10.745 24 24zm181.334 240v-80c0-13.255-10.745-24-24-24H205.333c-13.255.0-24 10.745-24 24v80c0 13.255 10.745 24 24 24h101.333c13.256.0 24.001-10.745 24.001-24zm32-240v80c0 13.255 10.745 24 24 24H488c13.255.0 24-10.745 24-24V56c0-13.255-10.745-24-24-24H386.667c-13.255.0-24 10.745-24 24zm-32 80V56c0-13.255-10.745-24-24-24H205.333c-13.255.0-24 10.745-24 24v80c0 13.255 10.745 24 24 24h101.333c13.256.0 24.001-10.745 24.001-24zm-205.334 56H24c-13.255.0-24 10.745-24 24v80c0 13.255 10.745 24 24 24h101.333c13.255.0 24-10.745 24-24v-80c0-13.255-10.745-24-24-24zM0 376v80c0 13.255 10.745 24 24 24h101.333c13.255.0 24-10.745 24-24v-80c0-13.255-10.745-24-24-24H24c-13.255.0-24 10.745-24 24zm386.667-56H488c13.255.0 24-10.745 24-24v-80c0-13.255-10.745-24-24-24H386.667c-13.255.0-24 10.745-24 24v80c0 13.255 10.745 24 24 24zm0 160H488c13.255.0 24-10.745 24-24v-80c0-13.255-10.745-24-24-24H386.667c-13.255.0-24 10.745-24 24v80c0 13.255 10.745 24 24 24zM181.333 376v80c0 13.255 10.745 24 24 24h101.333c13.255.0 24-10.745 24-24v-80c0-13.255-10.745-24-24-24H205.333c-13.255.0-24 10.745-24 24z"/></svg><span class=menu-item-name>Series</span></a></li><li class=menu-item><a href=/tags/><svg viewBox="0 0 640 512" class="icon tags"><path d="M497.941 225.941 286.059 14.059A48 48 0 00252.118.0H48C21.49.0.0 21.49.0 48v204.118a48 48 0 0014.059 33.941l211.882 211.882c18.744 18.745 49.136 18.746 67.882.0l204.118-204.118c18.745-18.745 18.745-49.137.0-67.882zM112 160c-26.51.0-48-21.49-48-48s21.49-48 48-48 48 21.49 48 48-21.49 48-48 48zm513.941 133.823L421.823 497.941c-18.745 18.745-49.137 18.745-67.882.0l-.36-.36L527.64 323.522c16.999-16.999 26.36-39.6 26.36-63.64s-9.362-46.641-26.36-63.64L331.397.0h48.721a48 48 0 0133.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137.0 67.882z"/></svg><span class=menu-item-name>Tags</span></a></li><li class=menu-item><a href></a></li><li class="menu-item search-item"><form id=search class=search role=search><label for=search-input><svg viewBox="0 0 512 512" class="icon search-icon"><path d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg></label>
<input type=search id=search-input class=search-input></form><template id=search-result hidden><article class="content post"><h2 class=post-title><a class=summary-title-link></a></h2><summary class=summary></summary><div class=read-more-container><a class=read-more-link>Read More »</a></div></article></template></li></ul></nav></div></div><input type=checkbox id=nav-toggle aria-hidden=true>
<label for=nav-toggle class=nav-toggle></label><label for=nav-toggle class=nav-curtain></label></header><main class="main single" id=main><nav class=contents><h2 id=contents class=contents-title>On This Page</h2><ol class=toc><li><a id=contents:使用进程实现并发 href=#使用进程实现并发>使用进程实现并发</a><ol><li><a id=contents:基于进程的并发服务器 href=#基于进程的并发服务器>基于进程的并发服务器</a></li><li><a id=contents:进程的优缺点 href=#进程的优缺点>进程的优缺点</a></li></ol></li><li><a id=contents:使用-io-多路复用实现并发 href=#使用-io-多路复用实现并发>使用 I/O 多路复用实现并发</a><ol><li><a id=contents:基于-io-多路复用的并发服务器 href=#基于-io-多路复用的并发服务器>基于 I/O 多路复用的并发服务器</a></li><li><a id=contents:io-多路复用的优缺点 href=#io-多路复用的优缺点>I/O 多路复用的优缺点</a></li></ol></li><li><a id=contents:使用线程实现并发 href=#使用线程实现并发>使用线程实现并发</a><ol><li><a id=contents:线程执行模型 href=#线程执行模型>线程执行模型</a></li><li><a id=contents:posix-线程 href=#posix-线程>Posix 线程</a></li><li><a id=contents:创建线程 href=#创建线程>创建线程</a></li><li><a id=contents:终止线程 href=#终止线程>终止线程</a></li><li><a id=contents:回收线程 href=#回收线程>回收线程</a></li><li><a id=contents:分离线程 href=#分离线程>分离线程</a></li><li><a id=contents:初始化线程 href=#初始化线程>初始化线程</a></li><li><a id=contents:基于线程的并发服务器 href=#基于线程的并发服务器>基于线程的并发服务器</a></li></ol></li><li><a id=contents:线程程序中的共享变量 href=#线程程序中的共享变量>线程程序中的共享变量</a><ol><li><a id=contents:线程内存模型 href=#线程内存模型>线程内存模型</a></li><li><a id=contents:将变量映射到内存 href=#将变量映射到内存>将变量映射到内存</a></li><li><a id=contents:共享变量 href=#共享变量>共享变量</a></li></ol></li><li><a id=contents:使用信号量同步线程 href=#使用信号量同步线程>使用信号量同步线程</a><ol><li><a id=contents:进度图 href=#进度图>进度图</a></li><li><a id=contents:信号量 href=#信号量>信号量</a></li><li><a id=contents:使用信号量实现互斥 href=#使用信号量实现互斥>使用信号量实现互斥</a></li><li><a id=contents:使用信号量调度共享资源 href=#使用信号量调度共享资源>使用信号量调度共享资源</a><ol><li><a id=contents:生产者-消费者问题 href=#生产者-消费者问题>生产者-消费者问题</a></li><li><a id=contents:读取者-写入者问题 href=#读取者-写入者问题>读取者-写入者问题</a></li></ol></li><li><a id=contents:基于预线程的并发服务器 href=#基于预线程的并发服务器>基于预线程的并发服务器</a></li></ol></li><li><a id=contents:使用线程实现并行 href=#使用线程实现并行>使用线程实现并行</a><ol><li><a id=contents:并行程序的性能指标 href=#并行程序的性能指标>并行程序的性能指标</a></li></ol></li><li><a id=contents:其他并发问题 href=#其他并发问题>其他并发问题</a><ol><li><a id=contents:线程安全 href=#线程安全>线程安全</a></li><li><a id=contents:可重入 href=#可重入>可重入</a></li><li><a id=contents:竞争 href=#竞争>竞争</a></li><li><a id=contents:死锁 href=#死锁>死锁</a></li></ol></li></ol></nav><div class=main-inner><article class="content post h-entry" data-small-caps=true data-align=default data-type=posts><h1 class="post-title p-name">CSAPP 读书笔记：并发编程</h1><div class=post-tags><a href=/tags/os/ rel=tag class=post-tags-link><svg viewBox="0 0 512 512" class="icon tag-icon"><path d="M0 252.118V48C0 21.49 21.49.0 48 0h204.118a48 48 0 0133.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137.0 67.882L293.823 497.941c-18.745 18.745-49.137 18.745-67.882.0L14.059 286.059A48 48 0 010 252.118zM112 64c-26.51.0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48z"/></svg>OS</a>
<a href=/tags/concurrent/ rel=tag class=post-tags-link><svg viewBox="0 0 512 512" class="icon tag-icon"><path d="M0 252.118V48C0 21.49 21.49.0 48 0h204.118a48 48 0 0133.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137.0 67.882L293.823 497.941c-18.745 18.745-49.137 18.745-67.882.0L14.059 286.059A48 48 0 010 252.118zM112 64c-26.51.0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48z"/></svg>Concurrent</a></div><div class="post-body e-content"><p>根据 <a href=/posts/exception-control-flow-note/#%E5%B9%B6%E5%8F%91%E6%B5%81>第八章</a> 介绍的内容，两个在时间上重叠的逻辑控制流是并发的。硬件异常处理程序、进程和 Linux 信号处理程序等都是计算机系统在不同层级上对并发的应用。现代操作系统为构建并发程序提供了三种基本方法：</p><ul><li>进程</li><li>I/O 多路复用（Multiplexing）</li><li>线程（Thread）</li></ul><h2 id=使用进程实现并发><a href=#使用进程实现并发 class=anchor-link><svg viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:使用进程实现并发 class=headings>使用进程实现并发</a></h2><p>构建并发程序最简单的方法是使用进程，如在父进程中接受客户端请求，然后创建子进程为客户端提供服务。</p><p>假设服务器在监听描述符<code>listenfd(3)</code>上接受来自客户端 1 的连接请求，并返回一个连接描述符<code>connfd(4)</code>：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20220829163846.png alt=20220829163846></p><p>服务器将调用<code>fork</code>创建一个子进程（下图中的“Child 1”），它获得服务器 <a href=/posts/system-level-io-note/#%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6>描述符表</a> 的完整副本。由于子进程不再需要监听描述符，而父进程不再需要连接描述符，我们应当将它们关闭：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20220829164820.png alt=20220829164820></p><p>随后服务器接受来自客户端 2 的连接请求并返回一个新的连接描述符<code>connfd(5)</code>：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20220829222214.png alt=20220829222214></p><p>服务器再次调用<code>fork</code>创建另一个子进程（下图中的“Child 2”）。此时，父进程正在等待下一个连接请求，两个子进程则并发地为各自的客户端提供服务：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20220829222709.png alt=20220829222709></p><h3 id=基于进程的并发服务器><a href=#基于进程的并发服务器 class=anchor-link><svg viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:基于进程的并发服务器 class=headings>基于进程的并发服务器</a></h3><p>一个基于进程的并发服务器代码如下，其中第 32 行调用的<code>echo</code>函数来自于上一章介绍的 <a href=http://csapp.cs.cmu.edu/2e/ics2/code/netp/echo.c target=_blank rel=noopener>echo.c</a>：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;csapp.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>echo</span><span class=p>(</span><span class=kt>int</span> <span class=n>connfd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>sigchld_handler</span><span class=p>(</span><span class=kt>int</span> <span class=n>sig</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=nf>waitpid</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>WNOHANG</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>**</span><span class=n>argv</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>listenfd</span><span class=p>,</span> <span class=n>connfd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>socklen_t</span> <span class=n>clientlen</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>sockaddr_storage</span> <span class=n>clientaddr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>argc</span> <span class=o>!=</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=s>&#34;usage: %s &lt;port&gt;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>argv</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>Signal</span><span class=p>(</span><span class=n>SIGCHLD</span><span class=p>,</span> <span class=n>sigchld_handler</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>listenfd</span> <span class=o>=</span> <span class=nf>Open_listenfd</span><span class=p>(</span><span class=n>argv</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>clientlen</span> <span class=o>=</span> <span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>sockaddr_storage</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>connfd</span> <span class=o>=</span> <span class=nf>Accept</span><span class=p>(</span><span class=n>listenfd</span><span class=p>,</span> <span class=p>(</span><span class=n>SA</span> <span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>clientaddr</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>clientlen</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nf>Fork</span><span class=p>()</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>Close</span><span class=p>(</span><span class=n>listenfd</span><span class=p>);</span> <span class=cm>/* Child closes its listening socket */</span>
</span></span><span class=line><span class=cl>            <span class=nf>echo</span><span class=p>(</span><span class=n>connfd</span><span class=p>);</span>    <span class=cm>/* Child services client */</span>
</span></span><span class=line><span class=cl>            <span class=nf>Close</span><span class=p>(</span><span class=n>connfd</span><span class=p>);</span>   <span class=cm>/* Child closes connection with client */</span>
</span></span><span class=line><span class=cl>            <span class=nf>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>         <span class=cm>/* Child exits */</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nf>Close</span><span class=p>(</span><span class=n>connfd</span><span class=p>);</span> <span class=cm>/* Parent closes connected socket (important!) */</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><p>考虑到服务器将运行很长时间，我们需要安装一个 SIGCHLD 信号处理程序来回收子进程（第 4～9 行），详见 <a href=/posts/exception-control-flow-note/#%E6%AD%A3%E7%A1%AE%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86>正确的信号处理</a>。</p><p>父进程必须关闭<code>connfd</code>（第 36 行），否则连接描述符指向的 <a href=/posts/system-level-io-note/#%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6>打开文件表条目</a> 永远不会被释放，从而导致内存泄漏。子进程则不需要关闭<code>connfd</code>（第 33 行可以省略），因为它会在子进程退出时由内核自动关闭。</p><h3 id=进程的优缺点><a href=#进程的优缺点 class=anchor-link><svg viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:进程的优缺点 class=headings>进程的优缺点</a></h3><p>父子进程共享打开文件表，但并不共享用户地址空间（虚拟内存），因此进程之间必须显式地使用 IPC（Interprocess Communications）机制来共享状态信息。由于进程控制和 IPC 的开销很高，基于进程的并发程序往往很慢。</p><h2 id=使用-io-多路复用实现并发><a href=#使用-io-多路复用实现并发 class=anchor-link><svg viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:使用-io-多路复用实现并发 class=headings>使用 I/O 多路复用实现并发</a></h2><p>I/O 多路复用技术的基本思想是应用程序调用<code>select</code>函数监视多个文件描述符，等待一个或多个描述符准备好用于某种 I/O 操作。该函数十分复杂并有多种使用场景，这里我们只讨论 I/O 操作为读取的情况：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/select.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>select</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>,</span> <span class=n>fd_set</span> <span class=o>*</span><span class=n>fdset</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// Returns: nonzero count of ready descriptors, −1 on error
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Macros for manipulating descriptor sets
</span></span></span><span class=line><span class=cl><span class=nf>FD_ZERO</span><span class=p>(</span><span class=n>fd_set</span> <span class=o>*</span><span class=n>fdset</span><span class=p>);</span>          <span class=cm>/* Clear all bits in fdset */</span>
</span></span><span class=line><span class=cl><span class=nf>FD_CLR</span><span class=p>(</span><span class=kt>int</span> <span class=n>fd</span><span class=p>,</span> <span class=n>fd_set</span> <span class=o>*</span><span class=n>fdset</span><span class=p>);</span>   <span class=cm>/* Clear bit fd in fdset */</span>
</span></span><span class=line><span class=cl><span class=nf>FD_SET</span><span class=p>(</span><span class=kt>int</span> <span class=n>fd</span><span class=p>,</span> <span class=n>fd_set</span> <span class=o>*</span><span class=n>fdset</span><span class=p>);</span>   <span class=cm>/* Turn on bit fd in fdset */</span>
</span></span><span class=line><span class=cl><span class=nf>FD_ISSET</span><span class=p>(</span><span class=kt>int</span> <span class=n>fd</span><span class=p>,</span> <span class=n>fd_set</span> <span class=o>*</span><span class=n>fdset</span><span class=p>);</span> <span class=cm>/* Is bit fd in fdset on? */</span>
</span></span></code></pre></td></tr></table></div></div></div><p>参数<code>fd_set</code>是一个描述符集，它在逻辑上是一个位向量（固定长度的 0，1 序列）：</p><p>$$b_{n - 1},&mldr;, b_1, b_0$$</p><p>其中的每个位 $b_k$ 都对应了一个描述符 $k$。当且仅当 $b_k$ 等于 1 时，描述符 $k$ 属于该描述符集。</p><p>在我们的应用场景中，参数<code>fd_set</code>是读取描述符集（Read Set），参数<code>n</code>是读取集的基数（Cardinality）。程序调用<code>select</code>函数后会一直阻塞，直到读取集中至少有一个描述符准备好被读取（即从该描述符中读取一个字节的请求不会阻塞）。</p><p>我们将读取集中已准备好被读取的描述符集合称为就绪集（Ready Set）。<code>select</code>函数会将<code>fdset</code>修改为就绪集，并返回就绪集的基数。因此，我们在每次调用该函数前都应当先更新读取集。</p><h3 id=基于-io-多路复用的并发服务器><a href=#基于-io-多路复用的并发服务器 class=anchor-link><svg viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:基于-io-多路复用的并发服务器 class=headings>基于 I/O 多路复用的并发服务器</a></h3><p>一个基于 I/O 多路复用的并发服务器代码如下：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;csapp.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span>
</span></span><span class=line><span class=cl><span class=p>{</span>                                <span class=cm>/* represents a pool of connected descriptors */</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>maxfd</span><span class=p>;</span>                   <span class=cm>/* largest descriptor in read_set */</span>
</span></span><span class=line><span class=cl>    <span class=n>fd_set</span> <span class=n>read_set</span><span class=p>;</span>             <span class=cm>/* set of all active descriptors */</span>
</span></span><span class=line><span class=cl>    <span class=n>fd_set</span> <span class=n>ready_set</span><span class=p>;</span>            <span class=cm>/* subset of descriptors ready for reading  */</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>nready</span><span class=p>;</span>                  <span class=cm>/* number of ready descriptors from select */</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>maxi</span><span class=p>;</span>                    <span class=cm>/* highwater index into client array */</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>clientfd</span><span class=p>[</span><span class=n>FD_SETSIZE</span><span class=p>];</span>    <span class=cm>/* set of active descriptors */</span>
</span></span><span class=line><span class=cl>    <span class=kt>rio_t</span> <span class=n>clientrio</span><span class=p>[</span><span class=n>FD_SETSIZE</span><span class=p>];</span> <span class=cm>/* set of active read buffers */</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>pool</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>byte_cnt</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=cm>/* counts total bytes received by server */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>**</span><span class=n>argv</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>listenfd</span><span class=p>,</span> <span class=n>connfd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>socklen_t</span> <span class=n>clientlen</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>sockaddr_storage</span> <span class=n>clientaddr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=n>pool</span> <span class=n>pool</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>argc</span> <span class=o>!=</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=s>&#34;usage: %s &lt;port&gt;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>argv</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>listenfd</span> <span class=o>=</span> <span class=nf>Open_listenfd</span><span class=p>(</span><span class=n>argv</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=nf>init_pool</span><span class=p>(</span><span class=n>listenfd</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>pool</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* Wait for listening/connected descriptor(s) to become ready */</span>
</span></span><span class=line><span class=cl>        <span class=n>pool</span><span class=p>.</span><span class=n>ready_set</span> <span class=o>=</span> <span class=n>pool</span><span class=p>.</span><span class=n>read_set</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>pool</span><span class=p>.</span><span class=n>nready</span> <span class=o>=</span> <span class=nf>Select</span><span class=p>(</span><span class=n>pool</span><span class=p>.</span><span class=n>maxfd</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>pool</span><span class=p>.</span><span class=n>ready_set</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/* If listening descriptor ready, add new client to pool */</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nf>FD_ISSET</span><span class=p>(</span><span class=n>listenfd</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>pool</span><span class=p>.</span><span class=n>ready_set</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>clientlen</span> <span class=o>=</span> <span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>sockaddr_storage</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>connfd</span> <span class=o>=</span> <span class=nf>Accept</span><span class=p>(</span><span class=n>listenfd</span><span class=p>,</span> <span class=p>(</span><span class=n>SA</span> <span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>clientaddr</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>clientlen</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=nf>add_client</span><span class=p>(</span><span class=n>connfd</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>pool</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/* Echo a text line from each ready connected descriptor */</span>
</span></span><span class=line><span class=cl>        <span class=nf>check_clients</span><span class=p>(</span><span class=o>&amp;</span><span class=n>pool</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><p>该程序使用<code>pool</code>类型的结构体（第 3～12 行）保存活跃的客户端，并使用<code>init_pool</code>函数初始化客户端池（第 29 行）。在无限循环的每次迭代中，服务器调用<code>select</code>函数检测两种不同类型的输入事件：来自新客户端的连接请求；为现有客户端提供服务的连接描述符已准备好被读取。当连接请求到达时（第 38 行），服务器打开连接（第 41 行）并将新客户端加入到客户端池中（第 42 行）。最后，服务器调用<code>check_clients</code>函数向每个已连接的描述符写入文本行（第 46 行）。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>init_pool</span><span class=p>(</span><span class=kt>int</span> <span class=n>listenfd</span><span class=p>,</span> <span class=n>pool</span> <span class=o>*</span><span class=n>p</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* Initially, there are no connected descriptors */</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=o>-&gt;</span><span class=n>maxi</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>FD_SETSIZE</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>p</span><span class=o>-&gt;</span><span class=n>clientfd</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* Initially, listenfd is only member of select read set */</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=o>-&gt;</span><span class=n>maxfd</span> <span class=o>=</span> <span class=n>listenfd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>FD_ZERO</span><span class=p>(</span><span class=o>&amp;</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>read_set</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>FD_SET</span><span class=p>(</span><span class=n>listenfd</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>read_set</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><p><code>init_pool</code>函数初始化客户端池。<code>p->clientfd</code>数组包含了所有已连接的描述符，一开始我们使用 -1 填充它（第 5～7 行）。此时<code>listenfd</code>是读取集<code>p->read_set</code>中唯一的描述符（第 10～12 行）。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>add_client</span><span class=p>(</span><span class=kt>int</span> <span class=n>connfd</span><span class=p>,</span> <span class=n>pool</span> <span class=o>*</span><span class=n>p</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=o>-&gt;</span><span class=n>nready</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>FD_SETSIZE</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=cm>/* Find an available slot */</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>clientfd</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=cm>/* Add connected descriptor to the pool */</span>
</span></span><span class=line><span class=cl>            <span class=n>p</span><span class=o>-&gt;</span><span class=n>clientfd</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>connfd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=nf>Rio_readinitb</span><span class=p>(</span><span class=o>&amp;</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>clientrio</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>connfd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=cm>/* Add the descriptor to descriptor set */</span>
</span></span><span class=line><span class=cl>            <span class=nf>FD_SET</span><span class=p>(</span><span class=n>connfd</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>read_set</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=cm>/* Update max descriptor and pool highwater mark */</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>connfd</span> <span class=o>&gt;</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>maxfd</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>p</span><span class=o>-&gt;</span><span class=n>maxfd</span> <span class=o>=</span> <span class=n>connfd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=o>&gt;</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>maxi</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>p</span><span class=o>-&gt;</span><span class=n>maxi</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=o>==</span> <span class=n>FD_SETSIZE</span><span class=p>)</span> <span class=cm>/* Couldn&#39;t find an empty slot */</span>
</span></span><span class=line><span class=cl>        <span class=nf>app_error</span><span class=p>(</span><span class=s>&#34;add_client error: Too many clients&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><p><code>add_client</code>函数将一个新客户端添加到活跃客户端池中。如果<code>p->clientfd</code>数组中还有空位（第 6 行），该函数就将连接描述符<code>connfd</code>添加到该数组并初始化一个读取缓冲区以调用 <a href=/posts/system-level-io-note/#%E6%9C%89%E7%BC%93%E5%86%B2%E7%9A%84%E8%BE%93%E5%85%A5%E5%87%BD%E6%95%B0><code>rio_readlineb</code></a>（第 9～10 行）。随后函数将连接描述符<code>connfd</code>添加到读取集（第 13 行），并更新客户端池的一些属性：变量<code>maxfd</code>代表<code>select</code>函数监视的最大文件描述符；变量<code>maxi</code>代表<code>p->clientfd</code>数组的最大索引（这样<code>check_clients</code>函数就不需要遍历整个数组）。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>check_clients</span><span class=p>(</span><span class=n>pool</span> <span class=o>*</span><span class=n>p</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=n>connfd</span><span class=p>,</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>buf</span><span class=p>[</span><span class=n>MAXLINE</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=kt>rio_t</span> <span class=n>rio</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=p>(</span><span class=n>i</span> <span class=o>&lt;=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>maxi</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>nready</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>);</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>connfd</span> <span class=o>=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>clientfd</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>rio</span> <span class=o>=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>clientrio</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/* If the descriptor is ready, echo a text line from it */</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>((</span><span class=n>connfd</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=nf>FD_ISSET</span><span class=p>(</span><span class=n>connfd</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>ready_set</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>p</span><span class=o>-&gt;</span><span class=n>nready</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>((</span><span class=n>n</span> <span class=o>=</span> <span class=nf>Rio_readlineb</span><span class=p>(</span><span class=o>&amp;</span><span class=n>rio</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=n>MAXLINE</span><span class=p>))</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>byte_cnt</span> <span class=o>+=</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Server received %d (%d total) bytes on fd %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                       <span class=n>n</span><span class=p>,</span> <span class=n>byte_cnt</span><span class=p>,</span> <span class=n>connfd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=nf>Rio_writen</span><span class=p>(</span><span class=n>connfd</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=cm>/* EOF detected, remove descriptor from pool */</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nf>Close</span><span class=p>(</span><span class=n>connfd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=nf>FD_CLR</span><span class=p>(</span><span class=n>connfd</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>read_set</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=n>p</span><span class=o>-&gt;</span><span class=n>clientfd</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><p><code>check_clients</code>函数遍历客户端池中所有已就绪的连接描述符，如果从描述符中读取文本行成功（第 16 行），就将该行返回给客户端（第 18-21 行）。一旦客户端关闭连接且服务器检测到 EOF，服务器便关闭连接描述符（第 27 行）并将该描述符从读取集和客户端池中删除（第 28-29 行）。</p><p>I/O 多路复用的本质是将逻辑控制流建模为状态机（State Machines）：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20220831234213.png alt=20220831234213></p><p>如上图所示，基于 I/O 多路复用的并发服务器为每个新客户端 $k$ 创建一个状态机 $s_k$ 并将其与连接描述符 $d_k$ 关联。每个状态机都有一个状态（等待描述符 $d_k$ 准备好被读取），一个输入事件（描述符 $d_k$ 已准备好被读取）和一个状态转换（从描述符 $d_k$ 中读取文本行）。</p><p>在示例的并发服务器中，<code>select</code>函数检测输入事件，<code>add_client</code>函数创建新的状态机（逻辑控制流）。<code>check_clients</code>函数通过读写文本行来执行状态转换，并在客户端发送完文本行后删除状态机。</p><h3 id=io-多路复用的优缺点><a href=#io-多路复用的优缺点 class=anchor-link><svg viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:io-多路复用的优缺点 class=headings>I/O 多路复用的优缺点</a></h3><p>基于 I/O 多路复用的应用程序运行在单个进程的上下文中，因此每个逻辑控制流都可以访问整个进程的地址空间，这使得控制流之间共享数据变得非常容易。由于它不需要通过上下文切换管理新进程，程序的运行效率较高。像 Node.js、Nginx 和 Tornado 等现代高性能服务器均使用 I/O 多路复用实现。</p><p>I/O 多路复用的缺点是编码十分复杂，并且无法充分利用多核处理器。</p><h2 id=使用线程实现并发><a href=#使用线程实现并发 class=anchor-link><svg viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:使用线程实现并发 class=headings>使用线程实现并发</a></h2><p>线程是在进程上下文中运行的逻辑控制流，它由内核自动调度。每个线程都有自己的线程上下文，包括一个唯一的线程 ID（TID）、栈、栈指针、程序计数器、通用寄存器和条件码寄存器。在同一个进程内运行的所有线程共享该进程全部的虚拟地址空间。</p><h3 id=线程执行模型><a href=#线程执行模型 class=anchor-link><svg viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:线程执行模型 class=headings>线程执行模型</a></h3><p>线程的执行模型与进程类似：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20220907221941.png alt=20220907221941></p><p>如上图所示，主线程（Main Thread）是进程生命周期的开始，它在某一时刻创建了一个对等线程（Peer Thread）。两线程同时运行，控制权通过上下文切换传递。</p><p>线程执行与进程的区别在于：</p><ul><li>线程上下文比进程上下文小得多，因此线程上下文切换比进程快；</li><li>属于同一进程的线程构成了一个对等池，它们没有父子层级结构。线程可以杀死任何对等线程或等待任何对等线程终止；</li><li>每个对等线程都可以读写相同的共享数据。</li></ul><h3 id=posix-线程><a href=#posix-线程 class=anchor-link><svg viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:posix-线程 class=headings>Posix 线程</a></h3><p>Posix 线程（Pthread）是 C 程序操作线程的标准接口。它定义了大约六十个函数，允许程序创建线程、终止线程、回收线程、与对等线程安全地共享数据以及通知对等线程系统状态的变化等。</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;csapp/csapp.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=nf>thread</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>vargp</span><span class=p>)</span> <span class=cm>/* thread routine */</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Hello, world!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>pthread_t</span> <span class=n>tid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=nf>Pthread_create</span><span class=p>(</span><span class=o>&amp;</span><span class=n>tid</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=kr>thread</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>Pthread_join</span><span class=p>(</span><span class=n>tid</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><p>示例程序中，主线程创建了一个对等线程并等待它终止，对等线程在打印<code>Hello, world!\n</code>后返回。</p><p>线程的代码和局部数据封装在线程例程（Thread Routine）中，它将通用指针<code>void *</code>作为输入并返回另一个通用指针（第 2 行）。如果需要向线程例程传递多个参数，则应将它们放入一个结构体中并传递指向该结构体的指针。同样，如果想让线程例程返回多个参数，则应返回一个指向包含多个参数的结构体指针。</p><h3 id=创建线程><a href=#创建线程 class=anchor-link><svg viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:创建线程 class=headings>创建线程</a></h3><p>线程调用函数<code>pthread_create</code>创建新线程：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;pthread.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=kt>void</span> <span class=o>*</span><span class=p>(</span><span class=n>func</span><span class=p>)(</span><span class=kt>void</span> <span class=o>*</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>pthread_create</span><span class=p>(</span><span class=kt>pthread_t</span> <span class=o>*</span><span class=n>tid</span><span class=p>,</span> <span class=kt>pthread_attr_t</span> <span class=o>*</span><span class=n>attr</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                   <span class=n>func</span> <span class=o>*</span><span class=n>f</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>arg</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// Returns: 0 if OK, nonzero on error
</span></span></span></code></pre></td></tr></table></div></div></div><p>参数<code>f</code>是新线程在其上下文中运行的例程，参数<code>arg</code>是该例程的输入参数。参数<code>attr</code>可用于更改新线程的默认属性，一般设为<code>NULL</code>。该函数返回时，参数<code>tid</code>将变为新线程的线程 ID。线程还可以调用<code>pthread_self</code>函数确认自己的线程 ID：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;pthread.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=kt>pthread_t</span> <span class=nf>pthread_self</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>//Returns: thread ID of caller
</span></span></span></code></pre></td></tr></table></div></div></div><h3 id=终止线程><a href=#终止线程 class=anchor-link><svg viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:终止线程 class=headings>终止线程</a></h3><p>线程终止的方式包括：</p><ul><li>在其例程返回时隐式终止；</li><li>调用函数<code>pthread_exit</code>显式终止，参数<code>thread_return</code>用于函数 <a href=/posts/concurrent-programming-note/#%E5%9B%9E%E6%94%B6%E7%BA%BF%E7%A8%8B><code>pthread_join</code></a>：</li></ul><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;pthread.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>pthread_exit</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>thread_return</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// Never returns
</span></span></span></code></pre></td></tr></table></div></div></div><ul><li>调用 Linux 函数<code>exit</code>终止进程以及与该进程关联的所有线程；</li><li>调用函数<code>pthread_cancel</code>终止另一个线程 ID 为<code>tid</code>的对等线程：</li></ul><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;pthread.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>pthread_cancel</span><span class=p>(</span><span class=kt>pthread_t</span> <span class=n>tid</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// Returns: 0 if OK, nonzero on error
</span></span></span></code></pre></td></tr></table></div></div></div><h3 id=回收线程><a href=#回收线程 class=anchor-link><svg viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:回收线程 class=headings>回收线程</a></h3><p>线程调用<code>pthread_join</code>函数等待另一个线程<code>tid</code>终止：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;pthread.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>pthread_join</span><span class=p>(</span><span class=kt>pthread_t</span> <span class=n>tid</span><span class=p>,</span> <span class=kt>void</span> <span class=o>**</span><span class=n>thread_return</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// Returns: 0 if OK, nonzero on error
</span></span></span></code></pre></td></tr></table></div></div></div><p>线程<code>tid</code>终止后，该函数将线程例程返回的通用指针分配到<code>thread_return</code>指向的位置，然后回收终止线程持有的所有内存资源。与 <a href=/posts/exception-control-flow-note/#%E5%9B%9E%E6%94%B6%E5%AD%90%E8%BF%9B%E7%A8%8B><code>waitpid</code></a> 不同，<code>pthread_join</code>只能等待某个特定线程终止。</p><h3 id=分离线程><a href=#分离线程 class=anchor-link><svg viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:分离线程 class=headings>分离线程</a></h3><p>在任意时刻，线程都是可连接的（Joinable）或分离的（Detached）。一个可连接的线程可以被其他线程回收或杀死，其内存资源（如栈）在它被另一个线程回收之前不会释放；相反，一个分离的线程无法被其他线程回收或杀死，其内存资源将在它终止时由系统自动释放。</p><p>默认情况下，线程是可连接的。为了避免内存泄漏，每个可连接的线程都应当被另一个线程显式地回收，或者调用<code>pthread_detach</code>函数成为一个分离的线程：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;pthread.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>pthread_detach</span><span class=p>(</span><span class=kt>pthread_t</span> <span class=n>tid</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// Returns: 0 if OK, nonzero on error
</span></span></span></code></pre></td></tr></table></div></div></div><p>参数<code>tid</code>是被分离的线程 ID，线程可以将其设为<code>pthread_self()</code>来分离自己。</p><h3 id=初始化线程><a href=#初始化线程 class=anchor-link><svg viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:初始化线程 class=headings>初始化线程</a></h3><p>线程调用<code>pthread_once</code>函数初始化与线程例程关联的状态：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;pthread.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=kt>pthread_once_t</span> <span class=n>once_control</span> <span class=o>=</span> <span class=n>PTHREAD_ONCE_INIT</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>pthread_once</span><span class=p>(</span><span class=kt>pthread_once_t</span> <span class=o>*</span><span class=n>once_control</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                 <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>init_routine</span><span class=p>)(</span><span class=kt>void</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=c1>// Always returns 0
</span></span></span></code></pre></td></tr></table></div></div></div><p>参数<code>once_control</code>是一个全局变量或静态变量，它始终被初始化为<code>PTHREAD_ONCE_INIT</code>。该函数第一次被调用时会直接调用<code>init_routine</code>，随后使用相同<code>once_control</code>参数的调用不会起任何作用。如下示例程序将输出 1：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;pthread.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=kt>pthread_once_t</span> <span class=n>once_control</span> <span class=o>=</span> <span class=n>PTHREAD_ONCE_INIT</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>cnt</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>init_routine</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cnt</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>pthread_once</span><span class=p>(</span><span class=o>&amp;</span><span class=n>once_control</span><span class=p>,</span> <span class=o>*</span><span class=n>init_routine</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>pthread_once</span><span class=p>(</span><span class=o>&amp;</span><span class=n>once_control</span><span class=p>,</span> <span class=o>*</span><span class=n>init_routine</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%d&#34;</span><span class=p>,</span> <span class=n>cnt</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><p>当我们需要动态初始化多个线程共享的全局变量时，该函数十分有用。</p><h3 id=基于线程的并发服务器><a href=#基于线程的并发服务器 class=anchor-link><svg viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:基于线程的并发服务器 class=headings>基于线程的并发服务器</a></h3><p>一个基于线程的并发服务器代码如下：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;csapp.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>echo</span><span class=p>(</span><span class=kt>int</span> <span class=n>connfd</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cm>/* thread routine */</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=nf>thread</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>vargp</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>connfd</span> <span class=o>=</span> <span class=o>*</span><span class=p>((</span><span class=kt>int</span> <span class=o>*</span><span class=p>)</span><span class=n>vargp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>Pthread_detach</span><span class=p>(</span><span class=nf>pthread_self</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=nf>Free</span><span class=p>(</span><span class=n>vargp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>echo</span><span class=p>(</span><span class=n>connfd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>Close</span><span class=p>(</span><span class=n>connfd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>**</span><span class=n>argv</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>listenfd</span><span class=p>,</span> <span class=o>*</span><span class=n>connfdp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>socklen_t</span> <span class=n>clientlen</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>sockaddr_storage</span> <span class=n>clientaddr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>pthread_t</span> <span class=n>tid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>argc</span> <span class=o>!=</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=s>&#34;usage: %s &lt;port&gt;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>argv</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>listenfd</span> <span class=o>=</span> <span class=nf>Open_listenfd</span><span class=p>(</span><span class=n>argv</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>clientlen</span> <span class=o>=</span> <span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>sockaddr_storage</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>connfdp</span> <span class=o>=</span> <span class=nf>Malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=n>connfdp</span> <span class=o>=</span> <span class=nf>Accept</span><span class=p>(</span><span class=n>listenfd</span><span class=p>,</span> <span class=p>(</span><span class=n>SA</span> <span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>clientaddr</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>clientlen</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>Pthread_create</span><span class=p>(</span><span class=o>&amp;</span><span class=n>tid</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=kr>thread</span><span class=p>,</span> <span class=n>connfdp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><p>程序的整体结构与基于进程的并发服务器类似，主线程反复等待客户端连接，然后创建对等线程处理请求。值得注意的是，该程序调用<code>Malloc</code>函数生成指向连接描述符的指针<code>connfdp</code>并将其传递给对等线程（第 32～34 行）。这是因为如果我们直接传递指针，如：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>connfd</span> <span class=o>=</span> <span class=nf>Accept</span><span class=p>(</span><span class=n>listenfd</span><span class=p>,</span> <span class=p>(</span><span class=n>SA</span> <span class=o>*</span><span class=p>)</span> <span class=o>&amp;</span><span class=n>clientaddr</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>clientlen</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nf>Pthread_create</span><span class=p>(</span><span class=o>&amp;</span><span class=n>tid</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=kr>thread</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>connfd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=nf>thread</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>vargp</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>connfd</span> <span class=o>=</span> <span class=o>*</span><span class=p>((</span><span class=kt>int</span> <span class=o>*</span><span class=p>)</span><span class=n>vargp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span> <span class=p>.</span> <span class=p>.</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><p>就会导致对等线程中的赋值语句与主线程中的<code>Accpet</code>调用产生竞争：若新客户端在赋值语句执行完毕前与服务器建立连接，则对等线程中的局部变量<code>connfd</code>会变成新客户端的连接描述符。由于<code>Malloc</code>可以将<code>connfd</code>动态分配到不同的堆内存 Block 中，这一问题便得到了解决。</p><p>为了避免内存泄漏，我们必须分离每个线程（第 8 行）并释放主线程分配的堆内存（第 9 行）。进程中的所有线程共享描述符表，连接描述符的<code>rfcnt</code>始终为 1。因此我们只需在对等线程中关闭连接描述符，而不必像基于进程的并发服务器那样在主线程进行同样的操作。</p><h2 id=线程程序中的共享变量><a href=#线程程序中的共享变量 class=anchor-link><svg viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:线程程序中的共享变量 class=headings>线程程序中的共享变量</a></h2><p>在程序员看来，线程的最大优势在于多个线程可以轻松地共享相同的程序变量。然而，这种便利可能会带来一些问题。为了正确地编写线程程序，我们以如下程序为例说明共享变量的含义及工作原理：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;csapp.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#define N 2
</span></span></span><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=nf>thread</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>vargp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>char</span> <span class=o>**</span><span class=n>ptr</span><span class=p>;</span> <span class=cm>/* global variable */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>pthread_t</span> <span class=n>tid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=o>*</span><span class=n>msgs</span><span class=p>[</span><span class=n>N</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;Hello from foo&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;Hello from bar&#34;</span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>ptr</span> <span class=o>=</span> <span class=n>msgs</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>N</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nf>Pthread_create</span><span class=p>(</span><span class=o>&amp;</span><span class=n>tid</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=kr>thread</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>Pthread_exit</span><span class=p>(</span><span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=nf>thread</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>vargp</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>myid</span> <span class=o>=</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span><span class=n>vargp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=kt>int</span> <span class=n>cnt</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>                                    
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;[%d]: %s (cnt=%d)</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>myid</span><span class=p>,</span> <span class=n>ptr</span><span class=p>[</span><span class=n>myid</span><span class=p>],</span> <span class=o>++</span><span class=n>cnt</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><h3 id=线程内存模型><a href=#线程内存模型 class=anchor-link><svg viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:线程内存模型 class=headings>线程内存模型</a></h3><p>每个线程都有自己独立的线程上下文，因此多个线程之间共享同一进程上下文中的其余部分。它们包括：只读文本（代码）段、可读写数据段、堆、共享库和打开文件描述符等。</p><p>线程无法读取或写入另一个线程的寄存器，但任何线程都能够访问共享虚拟内存中的任何位置。尽管栈属于线程上下文的一部分，但线程可以使用指针对另一个线程的栈内容读取和写入。示例程序第 25 行，对等线程通过全局变量<code>ptr</code>间接引用了主线程栈中的数组<code>msgs[N]</code>。</p><h3 id=将变量映射到内存><a href=#将变量映射到内存 class=anchor-link><svg viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:将变量映射到内存 class=headings>将变量映射到内存</a></h3><p>C 线程程序根据变量的存储类型将其映射到虚拟内存：</p><ul><li>全局变量：全局变量的唯一实例在运行时位于 <a href=/posts/linking-note/#%E5%8A%A0%E8%BD%BD%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6>可读写段</a>，它可以被任意线程引用。示例程序第 5 行声明的全局变量<code>ptr</code>便是如此；</li><li>局部自动变量：局部自动变量在运行时位于每个线程的栈中，如示例程序中的变量<code>tid</code>和<code>myid</code>。为了区分不同线程中的相同变量，我们将它们分别表示为<code>tid.m</code>、<code>myid.p0</code>和<code>myid.p1</code>；</li><li>局部静态变量：与全局变量一样，局部静态变量的唯一实例在运行时位于可读写段。即使示例程序中的每个对等线程都声明了局部静态变量<code>cnt</code>（第 24 行），在运行时虚拟内存中也只有一个<code>cnt</code>实例。</li></ul><h3 id=共享变量><a href=#共享变量 class=anchor-link><svg viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:共享变量 class=headings>共享变量</a></h3><p>当一个变量的实例被多个线程引用时，我们就称它为共享的。在示例程序中，变量<code>cnt</code>是共享的，而<code>myid</code>则不是。对等线程均通过<code>ptr</code>间接引用了局部变量<code>msgs</code>，因此<code>msgs</code>也是共享的。</p><h2 id=使用信号量同步线程><a href=#使用信号量同步线程 class=anchor-link><svg viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:使用信号量同步线程 class=headings>使用信号量同步线程</a></h2><p>以下程序<code>badcnt.c</code>创建了两个对等线程，每个线程都会将全局共享变量<code>cnt</code>递增<code>niters</code>次：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;csapp.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=nf>thread</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>vargp</span><span class=p>);</span> <span class=cm>/* Thread routine prototype */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* Global shared variable */</span>
</span></span><span class=line><span class=cl><span class=k>volatile</span> <span class=kt>long</span> <span class=n>cnt</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=cm>/* Counter */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>**</span><span class=n>argv</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>long</span> <span class=n>niters</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>pthread_t</span> <span class=n>tid1</span><span class=p>,</span> <span class=n>tid2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* Check input argument */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>argc</span> <span class=o>!=</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;usage: %s &lt;niters&gt;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>argv</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>niters</span> <span class=o>=</span> <span class=nf>atoi</span><span class=p>(</span><span class=n>argv</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* Create threads and wait for them to finish */</span>
</span></span><span class=line><span class=cl>    <span class=nf>Pthread_create</span><span class=p>(</span><span class=o>&amp;</span><span class=n>tid1</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=kr>thread</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>niters</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>Pthread_create</span><span class=p>(</span><span class=o>&amp;</span><span class=n>tid2</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=kr>thread</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>niters</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>Pthread_join</span><span class=p>(</span><span class=n>tid1</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>Pthread_join</span><span class=p>(</span><span class=n>tid2</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* Check result */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>cnt</span> <span class=o>!=</span> <span class=p>(</span><span class=mi>2</span> <span class=o>*</span> <span class=n>niters</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;BOOM! cnt=%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>cnt</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;OK cnt=%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>cnt</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* Thread routine */</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=nf>thread</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>vargp</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>long</span> <span class=n>i</span><span class=p>,</span> <span class=n>niters</span> <span class=o>=</span> <span class=o>*</span><span class=p>((</span><span class=kt>long</span> <span class=o>*</span><span class=p>)</span><span class=n>vargp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>niters</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>cnt</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><p>理论上，该程序的输出结果应为<code>2 * niters</code>。然而当它在 Linux 系统上运行时，我们不但会得到错误的答案，并且每次的结果还不同：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>linux&gt; ./badcnt <span class=m>1000000</span> BOOM! <span class=nv>cnt</span><span class=o>=</span><span class=m>1445085</span>
</span></span><span class=line><span class=cl>linux&gt; ./badcnt <span class=m>1000000</span> BOOM! <span class=nv>cnt</span><span class=o>=</span><span class=m>1915220</span>
</span></span><span class=line><span class=cl>linux&gt; ./badcnt <span class=m>1000000</span> BOOM! <span class=nv>cnt</span><span class=o>=</span><span class=m>1404746</span>
</span></span></code></pre></td></tr></table></div></div></div><p>为了清楚地理解这一问题，我们需要研究一下计数器循环（第 40～41 行）的汇编代码：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-nasm data-lang=nasm><span class=line><span class=cl><span class=c1>; i in %rax, niters in %rcx, cnt in %rdx</span>
</span></span><span class=line><span class=cl>    <span class=nf>movq</span>  <span class=p>(</span><span class=o>%</span><span class=nb>rdi</span><span class=p>),</span> <span class=o>%</span><span class=nb>rcx</span>
</span></span><span class=line><span class=cl>    <span class=nf>testq</span> <span class=o>%</span><span class=nb>rcx</span><span class=p>,</span> <span class=o>%</span><span class=nb>rcx</span>
</span></span><span class=line><span class=cl>    <span class=nf>jle</span>   <span class=nv>.L2</span>
</span></span><span class=line><span class=cl>    <span class=nf>movl</span>  <span class=kc>$</span><span class=mi>0</span><span class=p>,</span> <span class=o>%</span><span class=nb>eax</span>
</span></span><span class=line><span class=cl><span class=nl>.L3:</span>
</span></span><span class=line><span class=cl>    <span class=nf>movq</span>  <span class=nv>cnt</span><span class=p>(</span><span class=o>%</span><span class=nv>rip</span><span class=p>),</span> <span class=o>%</span><span class=nb>rdx</span>
</span></span><span class=line><span class=cl>    <span class=nf>addq</span>  <span class=kc>$</span><span class=mi>1</span><span class=p>,</span> <span class=o>%</span><span class=nb>rdx</span>
</span></span><span class=line><span class=cl>    <span class=nf>movq</span>  <span class=nv>movq</span> <span class=o>%</span><span class=nb>rdx</span><span class=p>,</span> <span class=nv>cnt</span><span class=p>(</span><span class=o>%</span><span class=nv>rip</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>addq</span>  <span class=kc>$</span><span class=mi>1</span><span class=p>,</span> <span class=o>%</span><span class=nb>rax</span>
</span></span><span class=line><span class=cl>    <span class=nf>cmpq</span>  <span class=o>%</span><span class=nb>rcx</span><span class=p>,</span> <span class=o>%</span><span class=nb>rax</span>
</span></span><span class=line><span class=cl>    <span class=nf>jne</span>   <span class=nv>.L3</span>
</span></span><span class=line><span class=cl><span class=nl>.L2:</span>
</span></span></code></pre></td></tr></table></div></div></div><p>这段代码可以分为以下五个部分：</p><ul><li>$H_i$：循环头部的指令块（第 2～5 行）；</li><li>$L_i$：将变量<code>cnt</code>加载到寄存器 %$rdx_i$（第 7 行）；</li><li>$U_i$：将 %$rdx_i$ 加一（第 8 行）；</li><li>$S_i$：将 %$rdx_i$ 更新后的值存回变量<code>cnt</code>（第 9 行）；</li><li>$T_i$：循环尾部的指令块（第 10～13 行）。</li></ul><p>上述指令在单核处理器上以某种顺序依次执行，不同的执行顺序将导致不同的结果。我们以第一次循环为例：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20220912235213.png alt=20220912235213></p><p>如图（b）所示，线程 2 在第五步将变量<code>cnt</code>加载到 %$rdx_2$。此时线程 1 已经在第三步更新了 %$rdx_1$ 的值，但还未把它存回<code>cnt</code>。因此 %$rdx_2$ 的初始值为 0，线程 2 无法像图（a）那样将<code>cnt</code>从 1 递增到 2。</p><h3 id=进度图><a href=#进度图 class=anchor-link><svg viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:进度图 class=headings>进度图</a></h3><p>进度图（Progress Graph）将 n 个并发线程建模为 n 维笛卡尔空间中的轨迹（Trajectory）。其中，每个坐标轴对应线程 $k$ 的进度，每个点代表线程 $k$ 已完成指令 $I_k$ 的状态。程序<code>badcnt.c</code>第一次循环的进度图如下，点 $(L_1, S_2)$ 代表线程 1 已完成 $L_1$，线程 2 则已完成 $S_2$：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20220913221845.png alt=20220913221845></p><p>程序的执行历史可以用进度图中的轨迹表示。假设该程序第一次循环的指令执行顺序为：</p><p>$$H_1, L_1, U_1, H_2, L_2, S_1, T_1, U_2, S_2, T_2$$</p><p>则进度图轨迹为：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20220913224057.png alt=20220913224057></p><p>对于线程 $i$，操作共享变量<code>cnt</code>的指令 $(L_i, U_i, S_i)$ 构成了一个临界区（Critical Section），它不应当与其他线程的临界区相交。在进度图上，两线程临界区的交集构成了不安全区（Unsafe Region）：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20220913224916.png alt=20220913224916></p><p>不安全区不包括其边缘，例如状态 $(H_1, H_2)$ 和 $(S_1, U_2)$ 均不属于该区域。绕过不安全区的轨迹被称为安全轨迹，而触及了不安全区中任何部分的轨迹都是不安全的。</p><h3 id=信号量><a href=#信号量 class=anchor-link><svg viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:信号量 class=headings>信号量</a></h3><p>信号量（Semaphore）<code>s</code>是一个具有非负整数值的全局变量，我们只能对它进行两种操作：</p><ul><li><code>P(s)</code>：若<code>s</code>非零，则将其减一并立即返回；若<code>s</code>为零，则将线程暂停。当<code>s</code>变为非零且线程由<code>V</code>操作重启后，<code>P</code>再将<code>s</code>减一并把控制权返回给调用者；</li><li><code>V(s)</code>：将<code>s</code>加一。如果存在任何被<code>P</code>操作阻塞的线程，就随机重启它们中的一个。</li></ul><p><code>P(s)</code>和<code>V(s)</code>操作不可分割（具有原子性），因此它们不会被中断。其定义保证了正确初始化的信号量永远不会变为负值，我们将这种属性称为信号量的不变性（Semaphore Invariant）。</p><p>Posix 标准定义了多种操作信号量的函数：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;semaphore.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>sem_init</span><span class=p>(</span><span class=kt>sem_t</span> <span class=o>*</span><span class=n>sem</span><span class=p>,</span> <span class=kt>int</span> <span class=n>pshared</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>value</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>sem_wait</span><span class=p>(</span><span class=kt>sem_t</span> <span class=o>*</span><span class=n>s</span><span class=p>);</span>   <span class=cm>/* P(s) */</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>sem_post</span><span class=p>(</span><span class=kt>sem_t</span> <span class=o>*</span><span class=n>s</span><span class=p>);</span>   <span class=cm>/* V(s) */</span>
</span></span><span class=line><span class=cl><span class=c1>// Returns: 0 if OK, −1 on error
</span></span></span></code></pre></td></tr></table></div></div></div><p>每个信号量都必须在使用前初始化，<code>sem_init</code>函数则将信号量<code>sem</code>初始化为参数<code>value</code>。在我们的应用场景中，参数<code>pshared</code>始终为 0。线程分别调用<code>sem_wait</code>和<code>sem_post</code>函数来执行<code>P(s)</code>和<code>V(s)</code>操作。为了简洁起见，我们使用以下等效的包装函数代替：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;csapp.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>P</span><span class=p>(</span><span class=kt>sem_t</span> <span class=o>*</span><span class=n>s</span><span class=p>);</span>   <span class=cm>/* Wrapper function for sem_wait */</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>V</span><span class=p>(</span><span class=kt>sem_t</span> <span class=o>*</span><span class=n>s</span><span class=p>);</span>   <span class=cm>/* Wrapper function for sem_post */</span>
</span></span><span class=line><span class=cl><span class=c1>// Returns: nothing
</span></span></span></code></pre></td></tr></table></div></div></div><h3 id=使用信号量实现互斥><a href=#使用信号量实现互斥 class=anchor-link><svg viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:使用信号量实现互斥 class=headings>使用信号量实现互斥</a></h3><p>信号量提供了一种便捷的方法来确保线程对共享变量的访问互斥（Mutually Exclusive）：将一个初始值为 1 的信号量与每个共享变量相关联，然后使用<code>P</code>和<code>V</code>操作包围临界区。</p><p>在这种情况下，信号量的值始终为 0 或 1，因此我们将它称为二进制信号量。用于实现互斥的二进制信号量通常被称为互斥锁（Mutex），对其进行<code>P</code>和<code>V</code>操作则分别被称为加锁和解锁。一个已被锁定但互斥锁还未被解锁的线程被称为持有互斥锁。</p><p>下图展示了我们如何使用二进制信号量正确同步程序<code>badcnt.c</code>，其中的每个状态都标注了该状态下信号量的值：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20220914000230.png alt=20220914000230></p><p>图中信号量为 -1 的状态共同构成了禁止区（Forbidden Region）。由于信号量的不变性，任何可行的轨迹都无法进入该区域。禁止区完全包围了不安全区，因此轨迹也不会触及不安全区的任何部分。无论运行时指令执行的顺序如何，程序都会正确地递增<code>cnt</code>。</p><p>综上，为了使用信号量实现互斥，我们需要首先声明一个信号量<code>mutex</code>：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>volatile</span> <span class=kt>long</span> <span class=n>cnt</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=cm>/* Counter */</span>
</span></span><span class=line><span class=cl><span class=kt>sem_t</span> <span class=n>mutex</span><span class=p>;</span>           <span class=cm>/* Semaphore that protects counter */</span>
</span></span></code></pre></td></tr></table></div></div></div><p>然后在主线程中将其初始化：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=nf>Sem_init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span> <span class=cm>/* mutex = 1 */</span>
</span></span></code></pre></td></tr></table></div></div></div><p>最终在对等线程中调用<code>P</code>和<code>V</code>包围对共享变量<code>cnt</code>的更新操作：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>niters</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>P</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>cnt</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>V</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>);</span> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><h3 id=使用信号量调度共享资源><a href=#使用信号量调度共享资源 class=anchor-link><svg viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:使用信号量调度共享资源 class=headings>使用信号量调度共享资源</a></h3><p>除了实现互斥之外，信号量的另一个重要作用是调度对共享资源的访问。在这种情况下，线程使用信号量与其他线程通信。让我们来看看两个经典案例：生产者-消费者（Producer-Consumer）问题和读取者-写入者（Readers-Writers）问题。</p><h4 id=生产者-消费者问题><a href=#生产者-消费者问题 class=anchor-link><svg viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:生产者-消费者问题 class=headings>生产者-消费者问题</a></h4><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20220914223735.png alt=20220914223735></p><p>如上图所示，生产者和消费者线程共享一个有界缓冲区。生产者线程重复生成新项目并将它们插入缓冲区，消费者线程则不断从缓冲区中删除项目，然后消费（使用）它们。</p><p>由于插入和删除项目涉及到更新共享变量，我们必须保证线程对缓冲区的访问是互斥的。但仅仅保证互斥是不够的，我们还需要调度线程对缓冲区的访问：若缓冲区已满（没有空位），则生产者必须等待空位；若缓冲区为空（没有可用的项目），则消费者必须等待项目可用。</p><p>我们开发了一个名为 $S_{buf}$ 的简单包，它可以操作<code>sbuf_t</code>类型的缓冲区：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=o>*</span><span class=n>buf</span><span class=p>;</span>          <span class=cm>/* Buffer array */</span>         
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>n</span><span class=p>;</span>             <span class=cm>/* Maximum number of slots */</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>front</span><span class=p>;</span>         <span class=cm>/* buf[(front+1)%n] is first item */</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>rear</span><span class=p>;</span>          <span class=cm>/* buf[rear%n] is last item */</span>
</span></span><span class=line><span class=cl>    <span class=kt>sem_t</span> <span class=n>mutex</span><span class=p>;</span>       <span class=cm>/* Protects accesses to buf */</span>
</span></span><span class=line><span class=cl>    <span class=kt>sem_t</span> <span class=n>slots</span><span class=p>;</span>       <span class=cm>/* Counts available slots */</span>
</span></span><span class=line><span class=cl>    <span class=kt>sem_t</span> <span class=n>items</span><span class=p>;</span>       <span class=cm>/* Counts available items */</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=kt>sbuf_t</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div></div><p>所有项目均存储在一个动态分配且包含<code>n</code>个空位的整型数组<code>buf</code>中，<code>front</code>和<code>rear</code>用于记录数组中的第一个项目和最后一个项目。信号量<code>mutex</code>实现了对缓冲区访问的互斥，<code>slots</code>和<code>items</code>则分别计算缓冲区中的空位和可用项目的数量。</p><p>$S_{buf}$ 包的实现如下：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;csapp.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;sbuf.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* Create an empty, bounded, shared FIFO buffer with n slots */</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>sbuf_init</span><span class=p>(</span><span class=kt>sbuf_t</span> <span class=o>*</span><span class=n>sp</span><span class=p>,</span> <span class=kt>int</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>sp</span><span class=o>-&gt;</span><span class=n>buf</span> <span class=o>=</span> <span class=nf>Calloc</span><span class=p>(</span><span class=n>n</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>));</span> 
</span></span><span class=line><span class=cl>    <span class=n>sp</span><span class=o>-&gt;</span><span class=n>n</span> <span class=o>=</span> <span class=n>n</span><span class=p>;</span>                       <span class=cm>/* Buffer holds max of n items */</span>
</span></span><span class=line><span class=cl>    <span class=n>sp</span><span class=o>-&gt;</span><span class=n>front</span> <span class=o>=</span> <span class=n>sp</span><span class=o>-&gt;</span><span class=n>rear</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>        <span class=cm>/* Empty buffer iff front == rear */</span>
</span></span><span class=line><span class=cl>    <span class=nf>Sem_init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>sp</span><span class=o>-&gt;</span><span class=n>mutex</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>      <span class=cm>/* Binary semaphore for locking */</span>
</span></span><span class=line><span class=cl>    <span class=nf>Sem_init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>sp</span><span class=o>-&gt;</span><span class=n>slots</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>n</span><span class=p>);</span>      <span class=cm>/* Initially, buf has n empty slots */</span>
</span></span><span class=line><span class=cl>    <span class=nf>Sem_init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>sp</span><span class=o>-&gt;</span><span class=n>items</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>      <span class=cm>/* Initially, buf has zero data items */</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* Clean up buffer sp */</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>sbuf_deinit</span><span class=p>(</span><span class=kt>sbuf_t</span> <span class=o>*</span><span class=n>sp</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>Free</span><span class=p>(</span><span class=n>sp</span><span class=o>-&gt;</span><span class=n>buf</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* Insert item onto the rear of shared buffer sp */</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>sbuf_insert</span><span class=p>(</span><span class=kt>sbuf_t</span> <span class=o>*</span><span class=n>sp</span><span class=p>,</span> <span class=kt>int</span> <span class=n>item</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>P</span><span class=p>(</span><span class=o>&amp;</span><span class=n>sp</span><span class=o>-&gt;</span><span class=n>slots</span><span class=p>);</span>                          <span class=cm>/* Wait for available slot */</span>
</span></span><span class=line><span class=cl>    <span class=nf>P</span><span class=p>(</span><span class=o>&amp;</span><span class=n>sp</span><span class=o>-&gt;</span><span class=n>mutex</span><span class=p>);</span>                          <span class=cm>/* Lock the buffer */</span>
</span></span><span class=line><span class=cl>    <span class=n>sp</span><span class=o>-&gt;</span><span class=n>buf</span><span class=p>[(</span><span class=o>++</span><span class=n>sp</span><span class=o>-&gt;</span><span class=n>rear</span><span class=p>)</span><span class=o>%</span><span class=p>(</span><span class=n>sp</span><span class=o>-&gt;</span><span class=n>n</span><span class=p>)]</span> <span class=o>=</span> <span class=n>item</span><span class=p>;</span>   <span class=cm>/* Insert the item */</span>
</span></span><span class=line><span class=cl>    <span class=nf>V</span><span class=p>(</span><span class=o>&amp;</span><span class=n>sp</span><span class=o>-&gt;</span><span class=n>mutex</span><span class=p>);</span>                          <span class=cm>/* Unlock the buffer */</span>
</span></span><span class=line><span class=cl>    <span class=nf>V</span><span class=p>(</span><span class=o>&amp;</span><span class=n>sp</span><span class=o>-&gt;</span><span class=n>items</span><span class=p>);</span>                          <span class=cm>/* Announce available item */</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* Remove and return the first item from buffer sp */</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>sbuf_remove</span><span class=p>(</span><span class=kt>sbuf_t</span> <span class=o>*</span><span class=n>sp</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>item</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>P</span><span class=p>(</span><span class=o>&amp;</span><span class=n>sp</span><span class=o>-&gt;</span><span class=n>items</span><span class=p>);</span>                          <span class=cm>/* Wait for available item */</span>
</span></span><span class=line><span class=cl>    <span class=nf>P</span><span class=p>(</span><span class=o>&amp;</span><span class=n>sp</span><span class=o>-&gt;</span><span class=n>mutex</span><span class=p>);</span>                          <span class=cm>/* Lock the buffer */</span>
</span></span><span class=line><span class=cl>    <span class=n>item</span> <span class=o>=</span> <span class=n>sp</span><span class=o>-&gt;</span><span class=n>buf</span><span class=p>[(</span><span class=o>++</span><span class=n>sp</span><span class=o>-&gt;</span><span class=n>front</span><span class=p>)</span><span class=o>%</span><span class=p>(</span><span class=n>sp</span><span class=o>-&gt;</span><span class=n>n</span><span class=p>)];</span>  <span class=cm>/* Remove the item */</span>
</span></span><span class=line><span class=cl>    <span class=nf>V</span><span class=p>(</span><span class=o>&amp;</span><span class=n>sp</span><span class=o>-&gt;</span><span class=n>mutex</span><span class=p>);</span>                          <span class=cm>/* Unlock the buffer */</span>
</span></span><span class=line><span class=cl>    <span class=nf>V</span><span class=p>(</span><span class=o>&amp;</span><span class=n>sp</span><span class=o>-&gt;</span><span class=n>slots</span><span class=p>);</span>                          <span class=cm>/* Announce available slot */</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>item</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><p><code>sbuf_init</code>函数为缓冲区分配堆内存，将<code>front</code>和<code>rear</code>设为 0，并为三个信号量分配初始值；<code>sbuf_deinit</code>函数在程序使用完缓冲区后释放它；<code>sbuf_insert</code>函数等待一个可用的空位，然后锁定<code>mutex</code>，将项目添加到缓冲区尾部并解锁<code>mutex</code>，最后通知消费者线程新项目可用；<code>sbuf_remove</code>函数与之对称：当缓冲区中有项目可用时，它锁定<code>mutex</code>，然后移除缓冲区头部的项目并解锁<code>mutex</code>，最后通知生产者有新的空位。</p><h4 id=读取者-写入者问题><a href=#读取者-写入者问题 class=anchor-link><svg viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:读取者-写入者问题 class=headings>读取者-写入者问题</a></h4><p>读取者-写入者问题是互斥问题的一般化。假设并发线程集合正在访问一个共享对象，如主存中的数据结构或磁盘上的数据库。写入者必须拥有对该对象的独占访问权，但读取者却可以与其他读取者共享。</p><p>我们可以根据读取者和写入者的优先级将这一问题分为两种情况：</p><ul><li>读取者优先：读取者不会因写入者在等待而等待；</li><li>写入者优先：一旦写入者准备好写入就尽快执行写入。</li></ul><p>示例程序展示了一个读取者优先的解决方案：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/* Global variables */</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>readcnt</span><span class=p>;</span>    <span class=cm>/* Initially = 0 */</span>
</span></span><span class=line><span class=cl><span class=kt>sem_t</span> <span class=n>mutex</span><span class=p>,</span> <span class=n>w</span><span class=p>;</span> <span class=cm>/* Both initially = 1 */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>reader</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>P</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>readcnt</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>readcnt</span> <span class=o>==</span> <span class=mi>1</span><span class=p>)</span> <span class=cm>/* First in */</span>
</span></span><span class=line><span class=cl>            <span class=nf>P</span><span class=p>(</span><span class=o>&amp;</span><span class=n>w</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>V</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/* Critical section */</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* Reading happens  */</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=nf>P</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>readcnt</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>readcnt</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=cm>/* Last out */</span>
</span></span><span class=line><span class=cl>            <span class=nf>V</span><span class=p>(</span><span class=o>&amp;</span><span class=n>w</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>V</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>writer</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>P</span><span class=p>(</span><span class=o>&amp;</span><span class=n>w</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/* Critical section */</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* Writing happens  */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=nf>V</span><span class=p>(</span><span class=o>&amp;</span><span class=n>w</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><p>信号量<code>w</code>实现了对共享对象访问的互斥，<code>mutex</code>则保护了对共享变量<code>readcnt</code>（表示当前处于临界区的读取者数量）的访问。写入者每次进入临界区时都会锁定<code>w</code>并在离开时对其解锁。但只有第一个进入临界区的读取者才需要锁定<code>w</code>，只有最后一个离开临界区的读取者才需要解锁它。因此只要有一个读取者持有<code>w</code>（位于临界区），其他读取者就都可以畅通无阻地访问共享对象。</p><p>所有此类问题的解决方案都会导致饥饿（Starvation），即线程被阻塞并无法取得任何进展。例如在上述程序中，当读取者线程批量到达时，写入者只能无限期等待。</p><h3 id=基于预线程的并发服务器><a href=#基于预线程的并发服务器 class=anchor-link><svg viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:基于预线程的并发服务器 class=headings>基于预线程的并发服务器</a></h3><p>前文介绍的 <a href=/posts/concurrent-programming-note/#%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8>基于线程的并发服务器</a> 需要为每个客户端创建一个新线程，因此其成本较高。基于预线程（Prethreading）的并发服务器可以通过生产者-消费者模型减少这一开销：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20220915001107.png alt=20220915001107></p><p>如上图所示，主线程不断地接受来自客户端连接请求并在有界缓冲区中插入连接描述符。每个工作线程重复地从缓冲区中移除一个描述符并为客户端提供服务，然后等待下一个描述符。</p><p>我们使用 $S_{buf}$ 包实现这一模型：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;csapp.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;sbuf.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#define NTHREADS 4
</span></span></span><span class=line><span class=cl><span class=cp>#define SBUFSIZE 16
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>echo_cnt</span><span class=p>(</span><span class=kt>int</span> <span class=n>connfd</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=nf>thread</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>vargp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>sbuf_t</span> <span class=n>sbuf</span><span class=p>;</span> <span class=cm>/* shared buffer of connected descriptors */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>**</span><span class=n>argv</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=n>listenfd</span><span class=p>,</span> <span class=n>connfd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>socklen_t</span> <span class=n>clientlen</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>sockaddr_storage</span> <span class=n>clientaddr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>pthread_t</span> <span class=n>tid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>argc</span> <span class=o>!=</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=s>&#34;usage: %s &lt;port&gt;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>argv</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>listenfd</span> <span class=o>=</span> <span class=nf>Open_listenfd</span><span class=p>(</span><span class=n>argv</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>sbuf_init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>sbuf</span><span class=p>,</span> <span class=n>SBUFSIZE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>NTHREADS</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=cm>/* Create worker threads */</span>
</span></span><span class=line><span class=cl>        <span class=nf>Pthread_create</span><span class=p>(</span><span class=o>&amp;</span><span class=n>tid</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=kr>thread</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>clientlen</span> <span class=o>=</span> <span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>sockaddr_storage</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>connfd</span> <span class=o>=</span> <span class=nf>Accept</span><span class=p>(</span><span class=n>listenfd</span><span class=p>,</span> <span class=p>(</span><span class=n>SA</span> <span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>clientaddr</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>clientlen</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>sbuf_insert</span><span class=p>(</span><span class=o>&amp;</span><span class=n>sbuf</span><span class=p>,</span> <span class=n>connfd</span><span class=p>);</span> <span class=cm>/* Insert connfd in buffer */</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=nf>thread</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>vargp</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>Pthread_detach</span><span class=p>(</span><span class=nf>pthread_self</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>connfd</span> <span class=o>=</span> <span class=nf>sbuf_remove</span><span class=p>(</span><span class=o>&amp;</span><span class=n>sbuf</span><span class=p>);</span><span class=cm>/* Remove connfd from buffer */</span> 
</span></span><span class=line><span class=cl>        <span class=nf>echo_cnt</span><span class=p>(</span><span class=n>connfd</span><span class=p>);</span>               <span class=cm>/* Service client */</span>
</span></span><span class=line><span class=cl>        <span class=nf>Close</span><span class=p>(</span><span class=n>connfd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><p>在初始化缓冲区<code>sbuf</code>（第 25 行）之后，主线程创建了一组工作线程（第 26～27 行）。它进入无限循环，接受连接请求并将连接描述符插入到<code>sbuf</code>中。工作线程等待连接描述符可用后便将其从缓冲区中移除（第 42 行），然后调用<code>echo_cnt</code>函数为客户端提供服务。</p><p><code>echo_cnt</code>是上文提到的<code>echo</code>函数的变体，它将服务器接收到的字节数记录在全局变量<code>byte_cnt</code>中：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;csapp.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=n>byte_cnt</span><span class=p>;</span> <span class=cm>/* byte counter */</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>sem_t</span> <span class=n>mutex</span><span class=p>;</span>  <span class=cm>/* and the mutex that protects it */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>init_echo_cnt</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>Sem_init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>byte_cnt</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>echo_cnt</span><span class=p>(</span><span class=kt>int</span> <span class=n>connfd</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>buf</span><span class=p>[</span><span class=n>MAXLINE</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=kt>rio_t</span> <span class=n>rio</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=kt>pthread_once_t</span> <span class=n>once</span> <span class=o>=</span> <span class=n>PTHREAD_ONCE_INIT</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>Pthread_once</span><span class=p>(</span><span class=o>&amp;</span><span class=n>once</span><span class=p>,</span> <span class=n>init_echo_cnt</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>    <span class=nf>Rio_readinitb</span><span class=p>(</span><span class=o>&amp;</span><span class=n>rio</span><span class=p>,</span> <span class=n>connfd</span><span class=p>);</span>        
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>((</span><span class=n>n</span> <span class=o>=</span> <span class=nf>Rio_readlineb</span><span class=p>(</span><span class=o>&amp;</span><span class=n>rio</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=n>MAXLINE</span><span class=p>))</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>P</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>byte_cnt</span> <span class=o>+=</span> <span class=n>n</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;server received %d (%d total) bytes on fd %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=n>n</span><span class=p>,</span> <span class=n>byte_cnt</span><span class=p>,</span> <span class=n>connfd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>V</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>Rio_writen</span><span class=p>(</span><span class=n>connfd</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><p>该函数使用<code>Pthread_once</code>（第 19 行）初始化信号量<code>mutex</code>和<code>byte_cnt</code>，于是我们便不必在主线程进行同样的操作了。这种方法使包更加易于使用，不过同时也增加了许多无用的工作（只有第一次调用<code>Pthread_once</code>是有意义的）。</p><h2 id=使用线程实现并行><a href=#使用线程实现并行 class=anchor-link><svg viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:使用线程实现并行 class=headings>使用线程实现并行</a></h2><p>到目前为止，我们对并发的研究仅局限于单核处理器。实际上并发程序往往在拥有多核处理器的机器上运行得更快，这是因为操作系统内核可以在多个 CPU 核心上并行调度线程。</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20220915230021.png alt=20220915230021></p><p>编写并行程序十分棘手，看似很小的代码更改却会对程序性能产生重大的影响。并行程序同步线程的开销非常高，因此我们需要尽量避免它，否则就可能出现线程数增加程序性能反而降低的问题。如果同步操作不可避免，则应当尽可能地增加有用计算以分摊其开销。</p><p>由于在同一个核心上切换多个线程的上下文会产生额外的开销，并行程序的线程数通常与机器的 CPU 核心数相同。</p><h3 id=并行程序的性能指标><a href=#并行程序的性能指标 class=anchor-link><svg viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:并行程序的性能指标 class=headings>并行程序的性能指标</a></h3><p>加速比（Speedup）被定义为：</p><p>$$S_p = \cfrac{T_1}{T_p}$$</p><p>其中，$p$ 是处理器核心的数量，$T_p$ 是程序在 $p$ 个核心上运行的时间。这个公式也被称为强缩放（Strong Scaling）。当 $T_1$ 是并行程序的顺序执行版本的运行时间时，$S_p$ 被称为绝对加速比；当 $T_1$ 是并行程序在一个核心上的运行时间时，$S_p$ 被称为相对加速比。绝对加速比比相对加速比更能真实地反映程序的性能，然而它也更难测量。尤其是一些复杂的并行程序，为其创建一个顺序执行的版本非常困难。</p><p>效率（Efficiency）被定义为：</p><p>$$E_p = \cfrac{S_p}{p} = \cfrac{T_1}{pT_p}$$</p><p>该指标能够衡量程序并行化的开销，效率高的程序用于线程同步和通信的时间较少。</p><h2 id=其他并发问题><a href=#其他并发问题 class=anchor-link><svg viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:其他并发问题 class=headings>其他并发问题</a></h2><h3 id=线程安全><a href=#线程安全 class=anchor-link><svg viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:线程安全 class=headings>线程安全</a></h3><p>若一个函数被多个并发线程重复调用时总能生成正确的结果，我们就称它为线程安全的（Thread-safe）。反之，则为线程不安全函数。线程不安全函数可以分为以下四类：</p><ul><li>不保护共享变量的函数：上文提到的 <a href=/posts/concurrent-programming-note/#%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%90%8C%E6%AD%A5%E7%BA%BF%E7%A8%8B><code>badcnt</code></a> 函数便属于此类。我们只需使用<code>P</code>和<code>V</code>等同步操作保护共享变量便可使函数线程安全，但同时也会增加程序的运行时间；</li><li>在多次调用中持续跟踪状态的函数：如伪随机数生成函数 <a href=https://man7.org/linux/man-pages/man3/rand.3.html target=_blank rel=noopener><code>rand</code></a>，其当前调用的结果取决于上次迭代的中间结果。因此如果多个线程调用该函数，我们就无法确定返回的随机数序列。修改此类函数唯一的方法便是重写它们，使其不依赖任何<code>static</code>数据并让调用者通过参数来传递状态信息；</li></ul><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>next_seed</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* rand - return pseudo-random integer on 0..32767 */</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>rand</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>next_seed</span> <span class=o>=</span> <span class=n>next_seed</span><span class=o>*</span><span class=mi>1103515245</span> <span class=o>+</span> <span class=mi>12345</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>int</span><span class=p>)(</span><span class=n>next_seed</span><span class=o>/</span><span class=mi>65536</span><span class=p>)</span> <span class=o>%</span> <span class=mi>32768</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* srand - set seed for rand() */</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>srand</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>new_seed</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>next_seed</span> <span class=o>=</span> <span class=n>new_seed</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> 
</span></span></code></pre></td></tr></table></div></div></div><ul><li>返回指向<code>static</code>变量指针的函数：一些函数，如<code>ctime</code>和<code>gethostbyname</code>，在<code>static</code>变量中计算结果并返回指向该变量的指针。如果并发线程调用此类函数，一个线程正在使用的变量就有可能被另一个线程返回的结果覆盖。我们可以直接重写它们，但也可以在源码不可用或难以修改时使用锁定和复制（Lock-and-Copy）技术来解决线程不安全问题；</li></ul><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>char</span> <span class=o>*</span><span class=nf>ctime_ts</span><span class=p>(</span><span class=k>const</span> <span class=kt>time_t</span> <span class=o>*</span><span class=n>timep</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>privatep</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=o>*</span><span class=n>sharedp</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>P</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>sharedp</span> <span class=o>=</span> <span class=nf>ctime</span><span class=p>(</span><span class=n>timep</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>strcpy</span><span class=p>(</span><span class=n>privatep</span><span class=p>,</span> <span class=n>sharedp</span><span class=p>);</span> <span class=cm>/* Copy string from shared to private */</span>
</span></span><span class=line><span class=cl>    <span class=nf>V</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>privatep</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><ul><li>调用线程不安全函数的函数：如果函数<code>f</code>调用了第二类线程不安全函数<code>g</code>，那么<code>f</code>也是线程不安全的并且只能重写<code>g</code>；如果<code>g</code>是第一类或第三类函数，我们就可以使用互斥锁保护调用点和所有生成的共享数据以使<code>f</code>线程安全。在上面的例子中，虽然函数<code>ctime_ts</code>调用了线程不安全函数<code>ctime</code>，但它却是线程安全的。</li></ul><h3 id=可重入><a href=#可重入 class=anchor-link><svg viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:可重入 class=headings>可重入</a></h3><p>可重入（Reentrant）函数是一种特殊的线程安全函数，它在被多个线程调用时不会引用任何共享数据。</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20220918212928.png alt=20220918212928></p><p>可重入函数不需要进行同步操作，因此通常比不可重入函数更高效。将第二类线程不安全函数重写为可重入函数是使其线程安全的唯一方法。我们可以将上节提到的函数<code>rand</code>修改为：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/* rand_r - a reentrant pseudo-random integer on 0..32767 */</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>rand_r</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>int</span> <span class=o>*</span><span class=n>nextp</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=n>nextp</span> <span class=o>=</span> <span class=o>*</span><span class=n>nextp</span> <span class=o>*</span> <span class=mi>1103515245</span> <span class=o>+</span> <span class=mi>12345</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>int</span><span class=p>)(</span><span class=o>*</span><span class=n>nextp</span> <span class=o>/</span> <span class=mi>65536</span><span class=p>)</span> <span class=o>%</span> <span class=mi>32768</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><p>其关键思想在于，<code>rand_r</code>使用被调用者传入的指针<code>nextp</code>代替了静态变量<code>next_seed</code>。</p><p>如果函数的所有参数都按值传递且所有的数据引用都指向局部自动变量，那么我们就称该函数是显式可重入的。无论该函数被调用的方式如何，其可重入性都不变；如果函数的某些参数通过引用（指针）传递且调用者线程小心地将非共享数据传递给指针，那么我们就称该函数是隐式可重入的，函数<code>rand_r</code>便是如此。</p><h3 id=竞争><a href=#竞争 class=anchor-link><svg viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:竞争 class=headings>竞争</a></h3><p>当多个线程的执行顺序会影响程序的正确性时就会发生竞争，如：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;csapp.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#define N 4
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=nf>thread</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>vargp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> 
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>pthread_t</span> <span class=n>tid</span><span class=p>[</span><span class=n>N</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>N</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>        <span class=nf>Pthread_create</span><span class=p>(</span><span class=o>&amp;</span><span class=n>tid</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=nb>NULL</span><span class=p>,</span> <span class=kr>thread</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>i</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>N</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>        <span class=nf>Pthread_join</span><span class=p>(</span><span class=n>tid</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* thread routine */</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=nf>thread</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>vargp</span><span class=p>)</span> 
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>myid</span> <span class=o>=</span> <span class=o>*</span><span class=p>((</span><span class=kt>int</span> <span class=o>*</span><span class=p>)</span><span class=n>vargp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Hello from thread %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>myid</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><p>示例程序中，主线程创建了四个对等线程并将指向了唯一整数 ID 的指针<code>&amp;i</code>传递给它们。对等线程将参数传递的 ID 复制到局部变量（第 21 行），然后打印包含 ID 的消息。该程序看似简单，然而却输出了错误的结果：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>linux</span><span class=o>&gt;</span> <span class=p>.</span><span class=o>/</span><span class=n>race</span>
</span></span><span class=line><span class=cl><span class=n>Hello</span> <span class=n>from</span> <span class=kr>thread</span> <span class=mi>1</span> 
</span></span><span class=line><span class=cl><span class=n>Hello</span> <span class=n>from</span> <span class=kr>thread</span> <span class=mi>3</span> 
</span></span><span class=line><span class=cl><span class=n>Hello</span> <span class=n>from</span> <span class=kr>thread</span> <span class=mi>2</span> 
</span></span><span class=line><span class=cl><span class=n>Hello</span> <span class=n>from</span> <span class=kr>thread</span> <span class=mi>3</span>
</span></span></code></pre></td></tr></table></div></div></div><p>出现这一问题的原因在于，主线程循环中变量<code>i</code>的自增（第 12 行）与对等线程中对参数的解引用和赋值（第 21 行）之间产生了竞争。如果对等线程在主线程变量<code>i</code>自增之后才执行第 22 行的代码，那么变量<code>myid</code>就变成了其他线程的 ID。</p><p>为了消除竞争，我们需要为每个 ID 动态分配一个堆内存 Block，并向线程传递指向该 Block 的指针。实际上，前文介绍的 <a href=/posts/concurrent-programming-note/#%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8>基于线程的并发服务器</a> 便使用了这一方法。</p><p>另一种方法是主线程直接向对等线程传递<code>i</code>而非其指针：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>N</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=nf>Pthread_create</span><span class=p>(</span><span class=o>&amp;</span><span class=n>tid</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=nb>NULL</span><span class=p>,</span> <span class=kr>thread</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span> <span class=n>i</span><span class=p>);</span> 
</span></span></code></pre></td></tr></table></div></div></div><p>对等线程则将参数转换回<code>int</code>类型并赋给变量<code>myid</code>：</p><div class=highlight><div class=chroma><div class=table-container><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=n>myid</span> <span class=o>=</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span><span class=n>vargp</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div></div><p>相比于第一种方法，这种方法的好处是减少了调用<code>malloc</code>和<code>free</code>带来的开销。但在类型转换中，它假设指针至少与整型一样大，可能不适用于某些操作系统。</p><h3 id=死锁><a href=#死锁 class=anchor-link><svg viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96.0-59.27-59.26-59.27-155.7.0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757.0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037.0 01-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482.0 0120.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96.0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454.0 0020.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037.0 00-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639.0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a><a href=#contents:死锁 class=headings>死锁</a></h3><p>信号量的引入可能会导致线程被永远阻塞，我们将这种运行时错误称为死锁（Deadlock）。进度图是理解死锁的重要工具：</p><p><img src=https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20220918230933.png alt=20220918230933></p><p>上图中的两个线程使用信号量<code>s</code>和<code>t</code>实现互斥，但程序员错误地对<code>P</code>和<code>V</code>操作排序。一旦某个轨迹进入了死锁状态<code>d</code>，两信号量重叠的禁止区域便阻止了它所有的可行路线。换言之，由于每个阻塞线程等待的<code>V</code>操作永远不会被执行，程序发生死锁。</p><p>死锁是一个非常棘手的问题，因为它难以预测。程序可能正确地运行了上千次，但下一次便会出现死锁。更糟糕的是，并发程序每次执行的轨迹都有所不同，因此死锁还难以复现。</p><p>对于二进制信号量，我们可以使用互斥锁排序规则来防止死锁：若每个线程以相同的顺序加锁（如上图中两线程均先执行<code>P(s)</code>，再执行<code>P(t)</code>），则程序无死锁。解锁的顺序并不重要，因为<code>V</code>操作不会阻塞线程。</p></div><p class=edit-page><a href=https://github.com/koktlzz/koktlzz.github.io/blob/main/content/posts/concurrent-programming-note.md><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-edit-2"><path d="M17 3a2.828 2.828.0 114 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>Edit this page on GitHub</a></p></article><script src=https://giscus.app/client.js data-repo=koktlzz/koktlzz.github.io data-repo-id=R_kgDOGRJFtw data-category=Announcements data-category-id=DIC_kwDOGRJFt84CTCRR data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></div></main><div id=back-to-top class=back-to-top><a href=#><svg viewBox="0 0 448 512" class="icon arrow-up"><path d="M34.9 289.5l-22.2-22.2c-9.4-9.4-9.4-24.6.0-33.9L207 39c9.4-9.4 24.6-9.4 33.9.0l194.3 194.3c9.4 9.4 9.4 24.6.0 33.9L413 289.4c-9.5 9.5-25 9.3-34.3-.4L264 168.6V456c0 13.3-10.7 24-24 24h-32c-13.3.0-24-10.7-24-24V168.6L69.2 289.1c-9.3 9.8-24.8 10-34.3.4z"/></svg></a></div><footer id=footer class=footer><div class=footer-inner><div class=site-info>©&nbsp;2020–2026&nbsp;<svg viewBox="0 0 512 512" class="icon footer-icon"><path d="M462.3 62.6C407.5 15.9 326 24.3 275.7 76.2L256 96.5l-19.7-20.3C186.1 24.3 104.5 15.9 49.7 62.6c-62.8 53.6-66.1 149.8-9.9 207.9l193.5 199.8c12.5 12.9 32.8 12.9 45.3.0l193.5-199.8c56.3-58.1 53-154.3-9.8-207.9z"/></svg>&nbsp;</div><div class=powered-by>Powered by <a href=https://github.com/gohugoio/hugo target=_blank rel=noopener>Hugo</a> | Theme is <a href=https://github.com/reuixiy/hugo-theme-meme target=_blank rel=noopener>MemE</a></div><div class=site-copyright><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en target=_blank rel=noopener>CC BY-NC-SA 4.0</a></div><ul class=socials><li class=socials-item><a href=/rss.xml target=_blank rel="external noopener" title=RSS><svg viewBox="0 0 24 24" class="icon social-icon"><path d="M19.199 24C19.199 13.467 10.533 4.8.0 4.8V0c13.165.0 24 10.835 24 24h-4.801zM3.291 17.415c1.814.0 3.293 1.479 3.293 3.295.0 1.813-1.485 3.29-3.301 3.29C1.47 24 0 22.526.0 20.71s1.475-3.294 3.291-3.295zM15.909 24h-4.665c0-6.169-5.075-11.245-11.244-11.245V8.09c8.727.0 15.909 7.184 15.909 15.91z"/></svg></a></li><li class=socials-item><a href=mailto:koktlgwr@gmail.com target=_blank rel="external noopener" title=Email><svg viewBox="0 0 512 512" class="icon social-icon"><path d="M464 64H48C21.49 64 0 85.49.0 112v288c0 26.51 21.49 48 48 48h416c26.51.0 48-21.49 48-48V112c0-26.51-21.49-48-48-48zm0 48v40.805c-22.422 18.259-58.168 46.651-134.587 106.49-16.841 13.247-50.201 45.072-73.413 44.701-23.208.375-56.579-31.459-73.413-44.701C106.18 199.465 70.425 171.067 48 152.805V112h416zM48 4e2V214.398c22.914 18.251 55.409 43.862 104.938 82.646 21.857 17.205 60.134 55.186 103.062 54.955 42.717.231 80.509-37.199 103.053-54.947 49.528-38.783 82.032-64.401 104.947-82.653V4e2H48z"/></svg></a></li><li class=socials-item><a href=https://github.com/koktlzz target=_blank rel="external noopener" title=GitHub><svg viewBox="0 0 24 24" class="icon social-icon"><path d="M12 .297c-6.63.0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577.0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93.0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176.0.0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22.0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22.0 1.606-.015 2.896-.015 3.286.0.315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg></a></li></ul></div></footer></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.css integrity="sha256-gPJfuwTULrEAAcI3X4bALVU/2qBU+QY/TpoD3GO+Exw=" crossorigin=anonymous><script>if(typeof renderMathInElement=="undefined"){var getScript=e=>{var t=document.createElement("script");t.defer=!0,t.crossOrigin="anonymous",Object.keys(e).forEach(n=>{t[n]=e[n]}),document.body.appendChild(t)};getScript({src:"https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.js",integrity:"sha256-YTW9cMncW/ZQMhY69KaUxIa2cPTxV87Uh627Gf5ODUw=",onload:()=>{getScript({src:"https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/contrib/mhchem.min.js",integrity:"sha256-yzSfYeVsWJ1x+2g8CYHsB/Mn7PcSp8122k5BM4T3Vxw=",onload:()=>{getScript({src:"https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/contrib/auto-render.min.js",integrity:"sha256-fxJzNV6hpc8tgW8tF0zVobKa71eTCRGTgxFXt1ZpJNM=",onload:()=>{renderKaTex()}})}})}})}else renderKaTex();function renderKaTex(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1}]})}</script><script src=https://cdn.jsdelivr.net/npm/medium-zoom@latest/dist/medium-zoom.min.js></script><script>let imgNodes=document.querySelectorAll("div.post-body img");imgNodes=Array.from(imgNodes).filter(e=>e.parentNode.tagName!=="A"),mediumZoom(imgNodes,{background:"hsla(var(--color-bg-h), var(--color-bg-s), var(--color-bg-l), 0.95)"})</script><script src=https://cdn.jsdelivr.net/npm/instant.page@5.1.0/instantpage.min.js type=module defer></script></body></html>