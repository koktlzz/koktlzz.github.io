<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><title type="text">Inspire Hub</title><subtitle type="html">MemE is a powerful and highly customizable GoHugo theme for personal blogs.</subtitle><updated>2022-02-18T09:11:17+00:00</updated><id>/</id><link rel="alternate" type="text/html" href="/"/><link rel="self" type="application/atom+xml" href="/atom.xml"/><author><name>koktlzz</name><uri>/</uri><email>koktlgwr@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</rights><generator uri="https://gohugo.io/" version="0.92.2">Hugo</generator><entry><title type="text">使用 Thanos 实现多集群（租户）监控</title><link rel="alternate" type="text/html" href="/posts/thanos-receiver-deployment-demo/"/><id>/posts/thanos-receiver-deployment-demo/</id><updated>2022-02-18T17:10:55+08:00</updated><published>2022-01-18T09:51:42+01:00</published><author><name>koktlzz</name><uri>/</uri><email>koktlgwr@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</rights><summary type="html">Thanos 已成为目前 Kubernetes 集群监控的标准解决方案之一。它基于 Prometheus 之上，可以为我们提供：全局的指标查询视图、几乎无限的数据保留期限和包含 Prometheus 在内所有组件的高可用性 &amp;hellip;</summary><category scheme="/tags/prometheus/" term="Prometheus" label="Prometheus"/><category scheme="/tags/thanos/" term="Thanos" label="Thanos"/></entry><entry><title type="text">CSAPP 读书笔记：存储系统的层级结构</title><link rel="alternate" type="text/html" href="/posts/the-memory-hierarchy-note/"/><id>/posts/the-memory-hierarchy-note/</id><updated>2022-01-18T10:06:47+08:00</updated><published>2021-12-28T21:41:42+01:00</published><author><name>koktlzz</name><uri>/</uri><email>koktlgwr@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</rights><summary type="html">存储系统（Memory System）可以分为多个层级（Hierarchy），每个层级的存储设备（Storage Device）具有不同的容量、成本和访问时间。层级越低，存储设备的容量就越大，成本也越低，但访问速度却越慢。存储系统的层次结构对应用性能有着显著的影响 &amp;hellip;</summary><category scheme="/tags/csapp/" term="CSAPP" label="CSAPP"/><category scheme="/tags/os/" term="OS" label="OS"/></entry><entry><title type="text">CSAPP 读书笔记：处理器架构</title><link rel="alternate" type="text/html" href="/posts/processor-architecture-note/"/><id>/posts/processor-architecture-note/</id><updated>2022-01-18T10:06:47+08:00</updated><published>2021-12-12T09:19:42+01:00</published><author><name>koktlzz</name><uri>/</uri><email>koktlgwr@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</rights><summary type="html">我们将处理器支持的指令及其对应的字节编码方式称为指令集架构（Instruction Set Architecture，ISA）。不同的处理器系列，例如 Intel IA32/x86-64，IBM/Freescale Power 和 ARM 等，均使用不同的 ISA。为一种机器编译得到的程序，无法在 ISA 不同的机器上运行 &amp;hellip;</summary><category scheme="/tags/csapp/" term="CSAPP" label="CSAPP"/></entry><entry><title type="text">【译】从零开始编写一个时序数据库</title><link rel="alternate" type="text/html" href="/posts/writing-a-time-series-database-from-scratch/"/><id>/posts/writing-a-time-series-database-from-scratch/</id><updated>2022-01-17T16:47:57+08:00</updated><published>2021-11-21T00:25:25+08:00</published><author><name>koktlzz</name><uri>/</uri><email>koktlgwr@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</rights><summary type="html">Prometheus 是一个包含了自定义时间序列数据库的监控系统，其查询语言、操作模型以及一些概念性决策使得它易于与 Kubernetes 集成。然而，Kubernetes 集群中的工作负载是动态变化的，有可能给它带来一定的压力 &amp;hellip;</summary><category scheme="/tags/prometheus/" term="Prometheus" label="Prometheus"/><category scheme="/tags/tsdb/" term="TSDB" label="TSDB"/></entry><entry><title type="text">通过安装 CoreOS 系统了解 Linux 启动流程</title><link rel="alternate" type="text/html" href="/posts/understand-linux-boot-process-by-installing-coreos/"/><id>/posts/understand-linux-boot-process-by-installing-coreos/</id><updated>2021-10-28T22:14:42+08:00</updated><published>2021-10-20T00:25:25+08:00</published><author><name>koktlzz</name><uri>/</uri><email>koktlgwr@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</rights><summary type="html">OpenShift 4.X 版本要求安装在操作系统为 CoreOS 的机器上，因此官方文档给出了使用 PXE 或 IPXE 引导 CoreOS 系统的方法。我们可以参考其操作流程，将一台 CentOS 7.X 的机器改写为 CoreOS 系统，步骤如下 &amp;hellip;</summary><category scheme="/tags/os/" term="OS" label="OS"/><category scheme="/tags/linux/" term="Linux" label="Linux"/><category scheme="/tags/coreos/" term="CoreOs" label="CoreOs"/></entry><entry><title type="text">CSAPP 读书笔记：程序的机器级表示</title><link rel="alternate" type="text/html" href="/posts/machine-level-representation-of-programs-note/"/><id>/posts/machine-level-representation-of-programs-note/</id><updated>2021-11-30T13:18:11+08:00</updated><published>2021-09-23T09:19:42+01:00</published><author><name>koktlzz</name><uri>/</uri><email>koktlgwr@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</rights><summary type="html">在使用高级语言，如 C、Java 编程时，我们无法了解程序具体的机器级实现。相比之下，使用汇编语言编写程序时，程序员必须指定程序使用的低级指令来执行计算。编译器提供的类型检查有助于检测许多程序错误，确保我们以一致的方式来引用和操作数据 &amp;hellip;</summary><category scheme="/tags/csapp/" term="CSAPP" label="CSAPP"/><category scheme="/tags/os/" term="OS" label="OS"/></entry><entry><title type="text">CSAPP 读书笔记：信息的表示和处理</title><link rel="alternate" type="text/html" href="/posts/representing-and-manipulating-information-note/"/><id>/posts/representing-and-manipulating-information-note/</id><updated>2021-10-28T23:26:56+08:00</updated><published>2021-07-19T09:19:42+01:00</published><author><name>koktlzz</name><uri>/</uri><email>koktlgwr@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</rights><summary type="html">大多数机器使用字节（8 位的块）作为存储器中的最小寻址单元，而非访问单独的位。内存中的每一个字节都对应一个唯一的数字，即它的地址，所有可能的地址集合构成了虚拟内存。它是由 DRAM、闪存（flash memory) 和磁盘存储共同实现的，而在程序看来则只是一个统一的字节数组 &amp;hellip;</summary><category scheme="/tags/csapp/" term="CSAPP" label="CSAPP"/><category scheme="/tags/os/" term="OS" label="OS"/></entry><entry><title type="text">CSAPP 读书笔记：计算机系统之旅</title><link rel="alternate" type="text/html" href="/posts/a-tour-of-computer-systems-note/"/><id>/posts/a-tour-of-computer-systems-note/</id><updated>2021-11-03T23:52:28+08:00</updated><published>2021-05-26T09:19:42+01:00</published><author><name>koktlzz</name><uri>/</uri><email>koktlgwr@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</rights><summary type="html">一堆 bit 可以表示系统中的所有信息，包括磁盘中的文件、内存中的程序和用户数据以及网络中传输的数据，区分它们的唯一方式便是我们查看这些数据对象时所处的上下文（Context）。例如，相同的一串 bit 在不同的 Context 中可能代表一个整数，也可能代表一个浮点数，甚至字符串 &amp;hellip;</summary><category scheme="/tags/csapp/" term="CSAPP" label="CSAPP"/><category scheme="/tags/os/" term="OS" label="OS"/></entry><entry><title type="text">对 Openshift SDN 网络模型的一些探索</title><link rel="alternate" type="text/html" href="/posts/explorations-on-the-openshift-sdn-network-model/"/><id>/posts/explorations-on-the-openshift-sdn-network-model/</id><updated>2021-10-28T22:16:59+08:00</updated><published>2021-05-13T09:19:42+01:00</published><author><name>koktlzz</name><uri>/</uri><email>koktlgwr@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</rights><summary type="html">在《Kubernetes Pod 是如何跨节点通信的？》中，我们简单地介绍了 Kubernetes 中的两种 SDN 网络模型：Underlay 和 Overlay。而 Openshift 中的 SDN 则是由 Overlay 网络 OVS（Open vSwitch）实现的，其使用的插件如下 &amp;hellip;</summary><category scheme="/tags/openshift/" term="Openshift" label="Openshift"/><category scheme="/tags/network/" term="Network" label="Network"/><category scheme="/tags/cni/" term="CNI" label="CNI"/><category scheme="/tags/open-vswitch/" term="Open vSwitch" label="Open vSwitch"/></entry><entry><title type="text">Kubernetes Pod 是如何跨节点通信的？</title><link rel="alternate" type="text/html" href="/posts/how-kubernetes-pods-communicate-across-nodes/"/><id>/posts/how-kubernetes-pods-communicate-across-nodes/</id><updated>2021-10-28T22:14:42+08:00</updated><published>2021-05-09T09:19:42+01:00</published><author><name>koktlzz</name><uri>/</uri><email>koktlgwr@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</rights><summary type="html">《A Guide to the Kubernetes Networking Model》一文生动形象地介绍了 Kubernetes 中的网络模型，然而受篇幅所限，作者并没有对 Pod 跨节点通信时数据包在节点之间传递的细节进行过多讨论 &amp;hellip;</summary><category scheme="/tags/kubernetes/" term="Kubernetes" label="Kubernetes"/><category scheme="/tags/network/" term="Network" label="Network"/><category scheme="/tags/cni/" term="CNI" label="CNI"/></entry><entry><title type="text">Kafka 是如何同步副本的？</title><link rel="alternate" type="text/html" href="/posts/how-does-kafka-synchronize-replicas/"/><id>/posts/how-does-kafka-synchronize-replicas/</id><updated>2021-10-28T22:14:42+08:00</updated><published>2021-03-26T00:25:25+08:00</published><author><name>koktlzz</name><uri>/</uri><email>koktlgwr@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</rights><summary type="html">通常，Kafka 中的每个 Partiotion 中有多个副本 (Replica) 以实现高可用。想象一个场景，Consumer 正在消费 Leader 中 Offset=10 的数据，而此时 Follower 中只同步到 Offset=8。那么当 Leader 所在的 Broker 宕机后，当前 Follower 经选举成为新的 Leader，Consumer 再次消费时便会报错 &amp;hellip;</summary><category scheme="/tags/kafka/" term="Kafka" label="Kafka"/></entry></feed>