<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><title type="text">Inspire Hub</title><subtitle type="html">MemE is a powerful and highly customizable GoHugo theme for personal blogs.</subtitle><updated>2022-06-23T16:04:16+00:00</updated><id>/</id><link rel="alternate" type="text/html" href="/"/><link rel="self" type="application/atom+xml" href="/atom.xml"/><author><name>koktlzz</name><uri>/</uri><email>koktlgwr@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</rights><generator uri="https://gohugo.io/" version="0.101.0">Hugo</generator><entry><title type="text">CSAPP 读书笔记：虚拟内存</title><link rel="alternate" type="text/html" href="/posts/virtual-memory-note/"/><id>/posts/virtual-memory-note/</id><updated>2022-06-21T23:03:33+08:00</updated><published>2022-05-10T09:19:42+01:00</published><author><name>koktlzz</name><uri>/</uri><email>koktlgwr@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</rights><summary type="html">为了更加有效地管理内存并减少错误的发生，现代系统提供了一种对主存储器的抽象，即虚拟内存（Virtual Memory，VM）。虚拟内存是硬件异常、硬件地址转换、主存储器、磁盘文件和内核软件之间的优雅交互，它为每个进程提供了一个大的、统一的和私有的地址空间 &amp;hellip;</summary><category scheme="/series/csapp-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" term="CSAPP 读书笔记" label="CSAPP 读书笔记"/><category scheme="/tags/os/" term="OS" label="OS"/></entry><entry><title type="text">CSAPP 读书笔记：链接</title><link rel="alternate" type="text/html" href="/posts/linking-note/"/><id>/posts/linking-note/</id><updated>2022-06-21T22:59:22+08:00</updated><published>2022-03-02T21:31:42+01:00</published><author><name>koktlzz</name><uri>/</uri><email>koktlgwr@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</rights><summary type="html">链接（Linking）是将各部分代码和数据收集并组成单个文件的过程，该文件可以被加载（复制）到内存中执行。链接可以在编译时（即源代码被翻译成机器代码时）执行，也可以在加载时 &amp;hellip;</summary><category scheme="/series/csapp-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" term="CSAPP 读书笔记" label="CSAPP 读书笔记"/><category scheme="/tags/os/" term="OS" label="OS"/></entry><entry><title type="text">使用 Thanos 实现多集群（租户）监控</title><link rel="alternate" type="text/html" href="/posts/thanos-receiver-deployment-demo/"/><id>/posts/thanos-receiver-deployment-demo/</id><updated>2022-02-21T16:51:58+08:00</updated><published>2022-01-18T09:51:42+01:00</published><author><name>koktlzz</name><uri>/</uri><email>koktlgwr@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</rights><summary type="html">Thanos 已成为目前 Kubernetes 集群监控的标准解决方案之一。它基于 Prometheus 之上，可以为我们提供：全局的指标查询视图、几乎无限的数据保留期限和包含 Prometheus 在内所有组件的高可用性 &amp;hellip;</summary><category scheme="/tags/prometheus/" term="Prometheus" label="Prometheus"/><category scheme="/tags/thanos/" term="Thanos" label="Thanos"/></entry><entry><title type="text">CSAPP 读书笔记：异常控制流</title><link rel="alternate" type="text/html" href="/posts/exception-control-flow-note/"/><id>/posts/exception-control-flow-note/</id><updated>2022-06-21T23:03:27+08:00</updated><published>2022-01-16T16:41:42+01:00</published><author><name>koktlzz</name><uri>/</uri><email>koktlgwr@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</rights><summary type="html">在计算机运行过程中，程序计数器将依次指向一系列的值：$a_0, a_1, &amp;hellip;, a_n$。其中，$a_k$ 是其对应指令 $I_k$ 的地址。每个从 $a_k$ 到 $a_{k+1}$ 的转换都称为控制转移（Control Transfer），一系列的控制转移则称为处理器的控制流（Control Flow）&amp;hellip;</summary><category scheme="/series/csapp-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" term="CSAPP 读书笔记" label="CSAPP 读书笔记"/><category scheme="/tags/os/" term="OS" label="OS"/></entry><entry><title type="text">CSAPP 读书笔记：存储系统的层级结构</title><link rel="alternate" type="text/html" href="/posts/the-memory-hierarchy-note/"/><id>/posts/the-memory-hierarchy-note/</id><updated>2022-05-11T12:06:15+08:00</updated><published>2021-12-28T21:41:42+01:00</published><author><name>koktlzz</name><uri>/</uri><email>koktlgwr@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</rights><summary type="html">存储系统（Memory System）可以分为多个层级（Hierarchy），每个层级的存储设备（Storage Device）具有不同的容量、成本和访问时间。层级越低，存储设备的容量就越大，成本也越低，但访问速度却越慢。存储系统的层次结构对应用性能有着显著的影响 &amp;hellip;</summary><category scheme="/series/csapp-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" term="CSAPP 读书笔记" label="CSAPP 读书笔记"/><category scheme="/tags/os/" term="OS" label="OS"/></entry><entry><title type="text">CSAPP 读书笔记：处理器架构</title><link rel="alternate" type="text/html" href="/posts/processor-architecture-note/"/><id>/posts/processor-architecture-note/</id><updated>2022-06-16T22:26:35+08:00</updated><published>2021-12-12T09:19:42+01:00</published><author><name>koktlzz</name><uri>/</uri><email>koktlgwr@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</rights><summary type="html">我们将处理器支持的指令及其对应的字节编码方式称为指令集架构（Instruction Set Architecture，ISA）。不同的处理器系列，例如 Intel IA32/x86-64，IBM/Freescale Power 和 ARM 等，均使用不同的 ISA。为一种机器编译得到的程序，无法在 ISA 不同的机器上运行 &amp;hellip;</summary><category scheme="/series/csapp-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" term="CSAPP 读书笔记" label="CSAPP 读书笔记"/><category scheme="/tags/isa/" term="ISA" label="ISA"/></entry><entry><title type="text">【译】从零开始编写一个时序数据库</title><link rel="alternate" type="text/html" href="/posts/writing-a-time-series-database-from-scratch/"/><id>/posts/writing-a-time-series-database-from-scratch/</id><updated>2022-01-17T16:47:57+08:00</updated><published>2021-11-21T00:25:25+08:00</published><author><name>koktlzz</name><uri>/</uri><email>koktlgwr@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</rights><summary type="html">Prometheus 是一个包含了自定义时间序列数据库的监控系统，其查询语言、操作模型以及一些概念性决策使得它易于与 Kubernetes 集成。然而，Kubernetes 集群中的工作负载是动态变化的，有可能给它带来一定的压力 &amp;hellip;</summary><category scheme="/tags/prometheus/" term="Prometheus" label="Prometheus"/><category scheme="/tags/tsdb/" term="TSDB" label="TSDB"/></entry><entry><title type="text">通过安装 CoreOS 系统了解 Linux 启动流程</title><link rel="alternate" type="text/html" href="/posts/understand-linux-boot-process-by-installing-coreos/"/><id>/posts/understand-linux-boot-process-by-installing-coreos/</id><updated>2021-10-28T22:14:42+08:00</updated><published>2021-10-20T00:25:25+08:00</published><author><name>koktlzz</name><uri>/</uri><email>koktlgwr@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</rights><summary type="html">OpenShift 4.X 版本要求安装在操作系统为 CoreOS 的机器上，因此官方文档给出了使用 PXE 或 IPXE 引导 CoreOS 系统的方法。我们可以参考其操作流程，将一台 CentOS 7.X 的机器改写为 CoreOS 系统，步骤如下 &amp;hellip;</summary><category scheme="/tags/os/" term="OS" label="OS"/><category scheme="/tags/linux/" term="Linux" label="Linux"/><category scheme="/tags/coreos/" term="CoreOs" label="CoreOs"/></entry><entry><title type="text">CSAPP 读书笔记：程序的机器级表示</title><link rel="alternate" type="text/html" href="/posts/machine-level-representation-of-programs-note/"/><id>/posts/machine-level-representation-of-programs-note/</id><updated>2022-06-24T00:03:56+08:00</updated><published>2021-09-23T09:19:42+01:00</published><author><name>koktlzz</name><uri>/</uri><email>koktlgwr@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</rights><summary type="html">在使用高级语言，如 C、Java 编程时，我们无法了解程序在机器级别的实现。而使用汇编语言编写程序时，程序员则只能引用低级指令。由高级语言编写的程序可以在多种不同的机器上编译运行，而汇编语言则与机器特性高度相关 &amp;hellip;</summary><category scheme="/series/csapp-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" term="CSAPP 读书笔记" label="CSAPP 读书笔记"/><category scheme="/tags/os/" term="OS" label="OS"/></entry><entry><title type="text">CSAPP 读书笔记：信息的表示和处理</title><link rel="alternate" type="text/html" href="/posts/representing-and-manipulating-information-note/"/><id>/posts/representing-and-manipulating-information-note/</id><updated>2022-06-23T22:56:45+08:00</updated><published>2021-07-19T09:19:42+01:00</published><author><name>koktlzz</name><uri>/</uri><email>koktlgwr@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</rights><summary type="html">大多数机器使用字节（8 位的块）作为存储器中的最小寻址单元，而非访问单独的位。内存中的每一个字节都对应一个唯一的数字，即它的地址，所有可能的地址集合构成了虚拟内存。它是由 DRAM、闪存（Flash Memory) 和磁盘存储共同实现的，而在程序看来则只是一个统一的字节数组 &amp;hellip;</summary><category scheme="/series/csapp-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" term="CSAPP 读书笔记" label="CSAPP 读书笔记"/><category scheme="/tags/os/" term="OS" label="OS"/></entry><entry><title type="text">CSAPP 读书笔记：计算机系统之旅</title><link rel="alternate" type="text/html" href="/posts/a-tour-of-computer-systems-note/"/><id>/posts/a-tour-of-computer-systems-note/</id><updated>2022-06-23T22:49:21+08:00</updated><published>2021-05-26T09:19:42+01:00</published><author><name>koktlzz</name><uri>/</uri><email>koktlgwr@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</rights><summary type="html">一堆 bit 可以表示系统中的所有信息，包括磁盘中的文件、内存中的程序和用户数据以及网络中传输的数据，区分它们的唯一方式便是我们查看这些数据对象时所处的上下文（Context）。例如，相同的一串 bit 在不同的 Context 中可能代表一个整数，也可能代表一个浮点数，甚至字符串 &amp;hellip;</summary><category scheme="/series/csapp-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" term="CSAPP 读书笔记" label="CSAPP 读书笔记"/><category scheme="/tags/os/" term="OS" label="OS"/></entry><entry><title type="text">对 Openshift SDN 网络模型的一些探索</title><link rel="alternate" type="text/html" href="/posts/explorations-on-the-openshift-sdn-network-model/"/><id>/posts/explorations-on-the-openshift-sdn-network-model/</id><updated>2022-05-11T12:06:15+08:00</updated><published>2021-05-13T09:19:42+01:00</published><author><name>koktlzz</name><uri>/</uri><email>koktlgwr@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</rights><summary type="html">在《Kubernetes Pod 是如何跨节点通信的？》中，我们简单地介绍了 Kubernetes 中的两种 SDN 网络模型：Underlay 和 Overlay。而 Openshift 中的 SDN 则是由 Overlay 网络 OVS（Open vSwitch）实现的，其使用的插件如下 &amp;hellip;</summary><category scheme="/tags/openshift/" term="Openshift" label="Openshift"/><category scheme="/tags/container-network/" term="Container Network" label="Container Network"/><category scheme="/tags/cni/" term="CNI" label="CNI"/><category scheme="/tags/open-vswitch/" term="Open vSwitch" label="Open vSwitch"/></entry><entry><title type="text">Kubernetes Pod 是如何跨节点通信的？</title><link rel="alternate" type="text/html" href="/posts/how-kubernetes-pods-communicate-across-nodes/"/><id>/posts/how-kubernetes-pods-communicate-across-nodes/</id><updated>2022-06-07T21:59:10+08:00</updated><published>2021-05-09T09:19:42+01:00</published><author><name>koktlzz</name><uri>/</uri><email>koktlgwr@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</rights><summary type="html">《A Guide to the Kubernetes Networking Model》一文生动形象地介绍了 Kubernetes 中的网络模型，然而受篇幅所限，作者并没有对 Pod 跨节点通信时数据包在节点之间传递的细节进行过多讨论 &amp;hellip;</summary><category scheme="/tags/kubernetes/" term="Kubernetes" label="Kubernetes"/><category scheme="/tags/container-network/" term="Container Network" label="Container Network"/><category scheme="/tags/cni/" term="CNI" label="CNI"/><category scheme="/tags/calico/" term="Calico" label="Calico"/></entry><entry><title type="text">Kafka 是如何同步副本的？</title><link rel="alternate" type="text/html" href="/posts/how-does-kafka-synchronize-replicas/"/><id>/posts/how-does-kafka-synchronize-replicas/</id><updated>2021-10-28T22:14:42+08:00</updated><published>2021-03-26T00:25:25+08:00</published><author><name>koktlzz</name><uri>/</uri><email>koktlgwr@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</rights><summary type="html">通常，Kafka 中的每个 Partiotion 中有多个副本 (Replica) 以实现高可用。想象一个场景，Consumer 正在消费 Leader 中 Offset=10 的数据，而此时 Follower 中只同步到 Offset=8。那么当 Leader 所在的 Broker 宕机后，当前 Follower 经选举成为新的 Leader，Consumer 再次消费时便会报错 &amp;hellip;</summary><category scheme="/tags/kafka/" term="Kafka" label="Kafka"/></entry></feed>