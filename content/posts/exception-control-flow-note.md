---
title: "CSAPP 读书笔记：异常控制流"
date: 2022-01-16T16:41:42+01:00
draft: true
tags: ["CSAPP","OS"]
summary: "在计算机运行过程中，程序计数器将依次指向一系列的值：$a_0, a_1, ..., a_n$。其中，$a_k$ 是其对应指令 $I_k$ 的地址。每个从 $a_k$ 到 $a_{k+1}$ 的转换都称为控制转移（Control Transfer），一系列的控制转移则称为处理器的控制流（Control Flow）..."
---

在计算机运行过程中，程序计数器将依次指向一系列的值：$a_0, a_1, ..., a_n$。其中，$a_k$ 是其对应指令 $I_k$ 的地址。每个从 $a_k$ 到 $a_{k+1}$ 的转换都称为控制转移（Control Transfer），一系列的控制转移则称为处理器的控制流（Control Flow）。

最简单的控制流便是程序中指令的顺序执行、跳转、调用以及返回，不过系统还必须对其状态的变化做出一定反应。这些变化无法被内部程序变量捕获，也不一定与程序的执行有关。比如，数据包到达网络适配器后需要被存储到内存中，程序访问磁盘中的数据需要得知其何时准备就绪，父进程必须在其子进程终止时收到通知。

现代系统通过异常控制流（Exceptional Control Flow，ECF）来处理上述情况，它应用于计算机系统的所有级别中：

- 硬件检测到的事件通过 ECF 将控制转移到异常处理程序（Exception Handler）；
- ECF 是操作系统实现 I/O、进程和虚拟内存的基本机制；
- 程序可以通过 ECF 请求一些操作系统服务，如向磁盘写入数据、读取网络中收到的数据以及创建新进程等；
- 一些编程语言通过 ECF 使程序进行非本地跳转（即违背通常的调用、返回栈规则的跳转）以对错误进行响应。

## 异常

异常（Exception）是为了响应处理器状态变化而在控制流中发生的突然变化，下图展示了其基本思想：

![20220208223330](https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20220208223330.png)

处理器状态的变化称为事件（Event），它可能与当前指令（$I_{curr}$）的执行直接相关，比如算术溢出或除数为零。 事件也可能与当前指令的执行无关，比如系统计时器关闭或 I/O 请求完成。

### 异常处理

异常处理涉及到软件和硬件的密切合作，因此很容易将不同组件执行的工作相混淆。系统中每种可能的异常都对应了一个唯一的非负整数，即异常数字（Exception Number）。当计算机系统启动时，操作系统会初始化一个跳转表，称为异常表（Exception Table）。异常数字是异常表的索引，而异常表中的每个条目 k 均包含了异常 k 的处理程序地址：

![20220209224522](https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20220209224522.png)

当处理器检测到事件的发生时，首先将确定异常数字，然后根据异常表调用对应的异常处理程序。

![20220210212750](https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20220210212750.png)

异常与过程调用类似，但也有一些重要区别：

- 异常的返回地址要么是当前指令（$I_{curr}$），要么是下一条指令（$I_{next}$）；
- 处理器还会将一些额外的处理器状态压入栈中；
- 当控制从用户程序转移到内核时，一切都将被压入到内核的栈中；
- 异常处理程序在内核态运行，因此可以访问所有系统资源。

### 异常的分类

![20220210214222](https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20220210214222.png)

#### 中断

中断（Interrupt）异步发生，因为它是由处理器外部的 I/O 设备发出的信号产生的。

![20220210215042](https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20220210215042.png)

当前指令执行完毕后，处理器注意到中断引脚变高，于是从系统总线读取异常数字，然后调用对应的中断处理程序。当处理程序返回时，它将控制权返回给下一条指令。随后程序继续执行，就好像中断从未发生过一样。
其余种类的异常作为当前指令的执行结果同步发生，我们将这类指令称为故障指令（Faulting Instruction）。

#### 陷阱和系统调用

与中断处理程序一样，陷阱（Trap）处理程序也将控制返回给下一条指令。其最重要的用途是在用户程序和内核之间提供接口，即系统调用（System Call）。

用户程序通过系统调用向内核请求服务，如读取文件（`read`）、创建新进程（`fork`）、加载新程序（`execve`）和终止当前进程（`exit`）等。

![20220210221251](https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20220210221251.png)

在程序员看来，系统调用和常规函数没有什么区别。但常规函数运行在用户态，因此其可执行的指令类型受限，也只能访问用户栈。而系统调用运行在内核态，能够执行特权指令并访问内核栈。

#### 故障

故障（Faulting）是由一些错误状况引起的异常，而这些错误情况有可能被处理程序修正，否则将返回到内核中的中止例程（图中的`abort`）：

![20220210222537](https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20220210222537.png)

#### 中止

与故障相比，导致中止（Abort）发生的错误状况无法挽救，通常是硬件出现问题，如 RAM 位损坏引起的奇偶校验错误。中止处理程序永远不会将控制权返回给应用程序：

![20220210223641](https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20220210223641.png)

### Linux/x86-64 系统中的异常

| Exception Number | Description |   Exception Class   |
| ---------------- | ----------- | ---- |
|        0          | Divide error | Fault |
| 13 | General protection fault | Fault |
| 14 | Page fault | Fault |
| 18 | Machine check | Abort |
| 32-255 | OS-defined exception | Interrupt or Trap |

#### 故障和中止

- 除法故障：当应用程序尝试除以 0 或除法指令的结果对目标操作数来说太大时，就会发生除法故障。Unix 不会试图纠正除法故障，而是直接中止程序；
- 一般保护性故障：若程序引用了未定义的虚拟内存区域，或试图写入只读文本段等，可能引起一般保护性故障。Linux 不会试图纠正该故障，Shell 一般称其为分段故障（Segmentation Faults）；
- 页面故障：当程序引用的虚拟地址对应的页面不在内存而在磁盘上时，将导致页面故障。处理程序将磁盘上合适的虚拟内存页面映射到物理内存页面，然后重新执行故障指令；
- 机器检查：在执行故障指令期间检测到致命的硬件错误时，会发生机器检查，处理程序永远不会将控制权返回给应用程序。

#### 系统调用

![20220213214429](https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20220213214429.png)

上图中的每个系统调用都有一个唯一的数字，对应了内核中跳转表的偏移量。该跳转表与上文提到的异常表不同。

C 标准库为大多数系统调用提供了一组包装函数（Wrapper Function），它们比直接使用系统调用更加方便。系统调用及其相关的包装函数统称为系统级函数。举例来说，我们可以使用系统级函数`write`代替`printf`：

```c
int main() {
write(1, "hello, world\n", 13);
_exit(0);
}
```

X86-64 系统通过`syscall`指令使用系统调用，其所有参数均通过寄存器传递。按照惯例，寄存器 %rax 保存系统调用编号，寄存器 %rdi、%rsi、%rdx、%r10、%r8 和 %r9 依次保存各参数的值。系统调用的返回值将写入到寄存器 %rax 中，若为负则表示发生了与负`errno`相关的错误。因此，上面的程序可以直接用汇编语言表示为：

![20220213221637](https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20220213221637.png)

## 进程

进程是正在执行的程序实例，而系统中的每个程序都在进程的上下文中运行。上下文包含了程序正确运行所需的状态，如程序代码和存储在内存中的数据、栈、寄存器、程序计数器、环境变量和打开的文件描述符集合。

进程为应用提供了两个关键抽象：

- 一个独立的逻辑控制流，让我们产生程序独占处理器的错觉；
- 一个私有的地址空间，让我们产生程序独占内存的错觉。

### 逻辑控制流

![20220213223239](https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20220213223239.png)

进程轮流使用处理器。每个进程执行其流程的一部分，然后在其他进程执行时被抢占（即暂时挂起）。

### 并发流

执行时间重叠的两个逻辑控制流称为并发流（Concurrent Flow），它们并发运行。如上图 8.12 所示，进程 A 和 进程 B 并发运行，但进程 B 和进程 C 则不是。

并发流的概念与处理器的核数以及计算机的数量无关，只要两个逻辑控制流在时间上重叠，那么它们便是并发的。如果两个逻辑控制流在不同的处理器内核或计算机上同时运行，我们就称它们为并行流（Parallel Flow）。显然，并行流是并发流的子集。

### 私有地址空间

进程为程序提供了私有地址空间。它是程序独享的，与空间内特定地址相关的内存字节通常不能被其他任何进程读取或写入。尽管私有地址空间的内容不同，但其具有相同的组织结构：

![20220214215948](https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20220214215948.png)

地址空间底部是为用户程序保留的，代码段总是从地址 0x400000 开始。地址空间顶部是为内核保留的，包含了内核为进程执行指令（如程序执行系统调用）时使用的代码、数据和栈。

### 用户态和内核态

处理器通过保存在控制寄存器中的模式位（Mode Bit）来识别进程当前享有的特权。当模式位被设置时，进程运行在内核态（Kernel Mode），反之则运行在用户态（User Mode）。在内核态中运行的程序可以执行指令集中的任意指令，并且可以访问系统中的任意位置。而在用户态中运行的程序则受到限制，只能使用系统调用间接地访问内核代码和数据。

应用程序的进程只能通过异常来从用户态切换到内核态。当异常发生且控制转移到异常处理程序时，处理器切换到内核态。随后异常处理程序在内核态中运行，处理器将在它返回时切换回用户态。

### 上下文切换

在进程执行期间，内核可以暂时挂起当前进程并重启先前被抢占的进程，这称为调度（Scheduling）。内核调度新进程是通过上下文切换（Context Switch）机制来实现的，该机制：

- 保存当前进程的上下文；
- 恢复之前被抢占进程的上下文；
- 将控制权转移给新进程。

程序使用系统调用时可能会发生上下文切换。比如系统调用`read`需要访问磁盘中的数据，内核可以通过上下文切换来调度另一个进程，这样就无需等待数据从磁盘加载到内存。

![20220215211459](https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20220215211459.png)

图 8.14 显示了一对进程 A 和 B 之间的上下文切换示例。在此示例中，进程 A 最初在用户模式下运行，直到它通过执行读取系统调用进入内核。内核中的陷阱处理程序向磁盘控制器请求 DMA 传输，并安排磁盘在磁盘控制器完成将数据从磁盘传输到内存后中断处理器。
磁盘将花费相对较长的时间来获取数据（大约几十毫秒），因此内核不会在此期间等待并且什么都不做，而是执行从进程 A 到 B 的上下文切换。请注意，在切换时，内核代表进程 A 在用户模式下执行指令（即，没有单独的内核进程）。在切换的第一部分，内核代表进程 A 在内核模式下执行指令。然后在某个时刻，它开始代表进程 B 执行指令（仍处于内核模式）。切换之后，内核是代表进程 B 在用户模式下执行指令。
进程 B 然后在用户模式下运行一段时间，直到磁盘发送中断以表示数据已从磁盘传输到内存。内核确定进程 B 已经运行了足够长的时间，并执行从进程 B 到 A 的上下文切换，将进程 A 中的控制权返回给紧跟 read 系统调用之后的指令。进程 A 继续运行，直到发生下一个异常，依此类推。

## 系统调用错误处理

## 进程控制

```c
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <stdio.h>
#include <sys/errno.h>
#include <string.h>

void unix_error(char *msg)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(errno));
    exit(0);
}

pid_t Fork(void){
    pid_t pid;
    if ((pid = fork()) < 0)
        unix_error("Fork error");
    return pid;
}

int main()
{

    pid_t pid;
    int x = 1;
    pid = Fork();
    if (pid == 0)
    { /*Child*/
        printf("child : x=%d\n", ++x);
        exit(0);
    }
    /* Parent */
    // printf("parent: x=%d\n", --x);
    exit(0);
}
```
