---
title: "CSAPP 读书笔记：虚拟内存"
date: 2022-05-10T09:19:42+01:00
draft: false
series: ["CSAPP 读书笔记"]
tags: ["OS"]
summary: "为了更加有效地管理内存并减少错误的发生，现代系统提供了一种对主存储器的抽象，即虚拟内存（Virtual Memory，VM）。虚拟内存是硬件异常、硬件地址转换、主存储器、磁盘文件和内核软件之间的优雅交互，它为每个进程提供了一个大的、统一的和私有的地址空间 ..."
---

为了更加有效地管理内存并减少错误的发生，现代系统提供了一种对主存储器的抽象，即虚拟内存（Virtual Memory，VM）。虚拟内存是硬件异常、硬件地址转换、主存储器、磁盘文件和内核软件之间的优雅交互，它为每个进程提供了一个大的、统一的和私有的地址空间。

虚拟内存有以下三个重要功能：

- 将主存储器作为磁盘的缓存，只保留主存中的活动区域并根据需要不断在两者之间传输数据；
- 为每个进程提供统一的地址空间，从而简化内存管理；
- 保护每个进程的地址空间不被其他进程所破坏。

## 物理寻址与虚拟寻址

主存中的每个字节都有一个唯一的物理地址（Physical Address，PA），CPU 使用物理地址访问内存的方式被称为物理寻址（Physical Addressing）：

![20220608145110](https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20220608145110.png)

如上图所示，CPU 生成了一个有效的物理地址并通过存储器总线传递给主存储器，详见 [访问主存储器](/posts/the-memory-hierarchy-note/#访问主存储器)。

CPU 也可以通过虚拟地址（Virtual Address，VA）访问主存，只不过该地址在发送到主存之前需要被转换为适当的物理地址。这种寻址方式被称为虚拟寻址（Virtual Addressing）：

![20220608150546](https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20220608150546.png)

地址转换（Address Translation ）需要 CPU 硬件和操作系统之间密切合作。位于 CPU 芯片上的内存管理单元（Memory Management Unit，MMU）根据 [页表](/posts/virtual-memory-note/#页表)（Page Table) 动态地将虚拟地址转换为物理地址。页表存储在主存中，其内容由操作系统维护。

## 地址空间

地址空间（Address Space）是一组有序的非负整数地址：

$$\lbrace0, 1, 2, . . .\rbrace$$

而如果这些整数是连续的，我们就称其为线性地址空间（Linear Address Space）。在拥有虚拟内存的系统中，CPU 从 $n$ 位线性地址空间中生成虚拟地址，该虚拟地址空间共有 $N=2^n$ 个地址：

$$\lbrace0,1,2,...,N -1\rbrace$$

现代系统通常支持 32 位或 64 位虚拟地址空间。同样地，系统也有一个物理地址空间：

$$\lbrace0,1,2,...,M -1\rbrace$$

与虚拟地址空间不同，$M$ 不一定是 2 的幂。但为了简化讨论，我们假设 $M=2^m$。

地址空间明确地将数据对象（字节）和其属性（地址）区分开来，因此每个数据对象都可以有多个独立的地址，这便是虚拟内存的基本思想。主存中的每个字节都有一个从物理地址空间中选择的物理地址，以及一个从虚拟地址空间中选择的虚拟地址。

## 虚拟内存作为缓存的工具

与存储层级结构中的其他缓存一样，磁盘与主存之间以 [Block](/posts/the-memory-hierarchy-note/#存储系统层级) 为单位传输数据。而在虚拟内存系统中，Block 被称为虚拟页面（Virtual Page，VP），其大小为 $P=2^p$。类似地，物理内存被划分为多个物理页面（Physical Page，PP)，大小同样为 $P$。

虚拟页面有以下三种状态：

- 未分配（Unallocated）：没有被进程申请使用的页面，不占用任何磁盘空间；
- 未缓存（Uncached）：仅加载到磁盘而未缓存到主存中的页面；
- 已缓存（Cached）：已缓存在主存中的页面。

### DRAM 缓存

我们将 CPU 和主存之间的 L1、L2 和 L3 级缓存称为 SRAM 缓存，而将主存中用来缓存虚拟页面的缓存称为 DRAM 缓存。

与 SRAM 缓存相比，DRAM 缓存发生缓存缺失的成本很高（需要从磁盘中加载数据），因此虚拟页面往往比较大——通常为 4 KB 到 2 MB。DRAM 缓存是 [全关联型](/posts/the-memory-hierarchy-note/#全关联型缓存) 的，这样任何一个虚拟页面都可以放在任何一个物理页面中。

### 页表

页表是由页表条目（Page Table Entries，PTEs）组成的数组。每个虚拟页面在页表都有一条 PTE，它在页表中的偏移量是固定的。每条 PTE 包含了一个有效位和一个 n 位的地址字段，有效位表示该虚拟页面是否已被缓存在 DRAM 中。若有效位为 1，则地址字段是缓存该页面的物理页面的起始地址；若有效位为 0 且地址字段为空，则代表该虚拟页面未分配；若有效位为 0 且地址字段非空，则地址字段是该页面在磁盘上的起始地址。

![20220608215707](https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20220608215707.png)

如上图所示，系统中存在 8 个虚拟页面和 4 个物理页面。页面 1，2，4 和 7 缓存在 DRAM 中，页面 3 和 6 已分配但未缓存，而页面 0 和 5 则未分配。

### 缺页故障

我们将访问 DRAM 缓存时发生的缓存缺失称为缺页故障（Page Fault）。若 CPU 引用上图页面 3 中的某个字，地址转换硬件会从主存中读取 PTE 3 ，然后根据其有效位判断该页面未缓存。缺页故障异常将调用内核中的异常处理程序，选择受害者页面（Victim Page）逐出主存。

在本例中，受害者页面为 VP 4，内核会先将 PTE 4 中的有效位重置为 0。如果该页面已发生更改，内核还需要将其复制回磁盘。接下来内核再把 VP 3 从磁盘复制到主存中的 PP 3，并更新 PTE 3 中的有效位。下图展示了异常处理程序返回后示例页表的状态：

![20220609113920](https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20220609113920.png)

上述在磁盘和主存之间传输页面的活动被称为交换（Swapping）或者分页（Paging）。页面从磁盘传输到主存被称为 Swapping In 或 Paging In，反之则为 Swapping Out 或 Paging Out。尽管我们可以努力预测缺页故障并在引用未缓存页面前分页，但现代系统均在异常发生后才分页，即按需分页（Demand Paging）。

### 分配页面

![20220609152723](https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20220609152723.png)

上图展示了分配一个新的虚拟页面（如进程调用`malloc`）后页表的变化。操作系统先在磁盘上开辟空间，然后更新 PTE 5 使 VP 5 指向磁盘上新创建的页面。

## 虚拟内存作为内存管理的工具

操作系统为每个进程都维护了一个单独的页表，因此每个进程都拥有自己的虚拟地址空间：

![20220609155208](https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20220609155208.png)

如上图所示，进程 i 的页表将 VP 1 映射到 PP 2，将 VP 2 映射到 PP 7；进程 j 的页表将 VP 1 映射到 PP 7，将 VP 2 映射到 PP 10。多个虚拟页面可以映射到同一个共享物理页面。虚拟内存系统简化了链接、加载、代码和数据的共享以及应用程序的内存分配：

- 简化链接：独立的虚拟地址空间允许每个进程使用相同的 [内存格式](/posts/exception-control-flow-note/#私有地址空间)，因此链接器无需考虑可执行文件的代码和数据在物理内存中的实际位置。这种统一性极大地简化了链接器的设计和实现；
- 简化加载：若要将目标文件的 .text 和 .data 段加载到一个新创建的进程中，加载器只需为它们分配虚拟页面，然后将其标记为未缓存，最后再将页表条目指向目标文件中对应的位置。实际上加载器从未将任何数据从磁盘复制到主存中，代码和数据只有在被第一次引用时才会按需分页；
- 简化共享：操作系统可以将不同进程中的不同虚拟页面映射到相同的物理页面，从而实现进程之间代码和数据的共享；
- 简化内存分配：当应用程序申请额外堆内存时，操作系统会为其分配一定数量的连续虚拟页面，然后将它们映射到任意位置的物理页面。这些物理页面无需连续，并且可以随机分散在物理内存中。

## 虚拟内存作为内存保护的工具

我们可以在 PTE 中添加一些权限位来控制进程对页面的访问：

![20220609164306](https://cdn.jsdelivr.net/gh/koktlzz/ImgBed@master/20220609164306.png)

如上图所示，SUP 表示是否只有在内核态运行的进程才能访问该页面，READ 和 WRITE 则分别表示页面是否可读写。例如，进程 i 在用户态中运行，那么它可以读取 VP 0，读取和写入 VP 1，但无法访问 VP 2。

如果某条指令违反了上述权限，CPU 就会触发通用保护故障，并将控制权转移到内核中的异常处理程序。该处理程序会向问题进程发送一个 SIGSEGV 信号。Linux Shell 通常将此异常报告为分段故障（Segmentation Fault）。

## 地址转换
