<?xml version="1.0" encoding="utf-8"?><rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Inspire Hub</title><link>/</link><description>MemE is a powerful and highly customizable GoHugo theme for personal blogs.</description><generator>Hugo 0.101.0 https://gohugo.io/</generator><language>en</language><managingEditor>koktlgwr@gmail.com (koktlzz)</managingEditor><webMaster>koktlgwr@gmail.com (koktlzz)</webMaster><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</copyright><lastBuildDate>Tue, 16 Aug 2022 07:31:20 +0000</lastBuildDate><atom:link rel="self" type="application/rss+xml" href="/rss.xml"/><item><title>CSAPP 读书笔记：系统级 I/O</title><link>/posts/system-level-io-note/</link><guid isPermaLink="true">/posts/system-level-io-note/</guid><pubDate>Sun, 07 Aug 2022 11:30:42 +0100</pubDate><author>koktlgwr@gmail.com (koktlzz)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</copyright><description>输入/输出 (I/O) 是在主存储器和外部设备（如磁盘驱动、终端和网络等）之间复制数据的过程。输入操作将数据从 I/O 设备复制到主存，输出操作则将数据从主存复制到设备 &amp;hellip;</description><category domain="/series/csapp-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">CSAPP 读书笔记</category><category domain="/tags/os/">OS</category></item><item><title>CSAPP 读书笔记：虚拟内存</title><link>/posts/virtual-memory-note/</link><guid isPermaLink="true">/posts/virtual-memory-note/</guid><pubDate>Tue, 10 May 2022 09:19:42 +0100</pubDate><author>koktlgwr@gmail.com (koktlzz)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</copyright><description>为了更加有效地管理内存并减少错误的发生，现代系统提供了一种对主存储器的抽象，即虚拟内存（Virtual Memory，VM）。虚拟内存是硬件异常、硬件地址转换、主存储器、磁盘文件和内核软件之间的优雅交互，它为每个进程提供了一个大的、统一的和私有的地址空间 &amp;hellip;</description><category domain="/series/csapp-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">CSAPP 读书笔记</category><category domain="/tags/os/">OS</category></item><item><title>CSAPP 读书笔记：链接</title><link>/posts/linking-note/</link><guid isPermaLink="true">/posts/linking-note/</guid><pubDate>Wed, 02 Mar 2022 21:31:42 +0100</pubDate><author>koktlgwr@gmail.com (koktlzz)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</copyright><description>链接（Linking）是将各部分代码和数据收集并组成单个文件的过程，该文件可以被加载（复制）到内存中执行。链接可以在编译时（即源代码被翻译成机器代码时）执行，也可以在加载时 &amp;hellip;</description><category domain="/series/csapp-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">CSAPP 读书笔记</category><category domain="/tags/os/">OS</category></item><item><title>使用 Thanos 实现多集群（租户）监控</title><link>/posts/thanos-receiver-deployment-demo/</link><guid isPermaLink="true">/posts/thanos-receiver-deployment-demo/</guid><pubDate>Tue, 18 Jan 2022 09:51:42 +0100</pubDate><author>koktlgwr@gmail.com (koktlzz)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</copyright><description>Thanos 已成为目前 Kubernetes 集群监控的标准解决方案之一。它基于 Prometheus 之上，可以为我们提供：全局的指标查询视图、几乎无限的数据保留期限和包含 Prometheus 在内所有组件的高可用性 &amp;hellip;</description><category domain="/tags/prometheus/">Prometheus</category><category domain="/tags/thanos/">Thanos</category></item><item><title>CSAPP 读书笔记：异常控制流</title><link>/posts/exception-control-flow-note/</link><guid isPermaLink="true">/posts/exception-control-flow-note/</guid><pubDate>Sun, 16 Jan 2022 16:41:42 +0100</pubDate><author>koktlgwr@gmail.com (koktlzz)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</copyright><description>在计算机的运行过程中，程序计数器依次指向一系列的值：$a_0, a_1, &amp;hellip;, a_n$。其中，$a_k$ 是其对应指令 $I_k$ 的地址。从 $a_k$ 到 $a_{k+1}$ 的转换被称为控制转移（Control Transfer），一系列的控制转移则被称为处理器的控制流 &amp;hellip;</description><category domain="/series/csapp-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">CSAPP 读书笔记</category><category domain="/tags/os/">OS</category></item><item><title>CSAPP 读书笔记：存储系统的层级结构</title><link>/posts/the-memory-hierarchy-note/</link><guid isPermaLink="true">/posts/the-memory-hierarchy-note/</guid><pubDate>Tue, 28 Dec 2021 21:41:42 +0100</pubDate><author>koktlgwr@gmail.com (koktlzz)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</copyright><description>存储系统（Memory System）包含多个层级（Hierarchy），每个层级的存储设备（Storage Device）具有不同的容量、成本和访问时间。层级越低，存储设备的容量就越大，成本也越低，但访问速度却越慢。存储系统的层级结构对应用性能有着显著的影响 &amp;hellip;</description><category domain="/series/csapp-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">CSAPP 读书笔记</category><category domain="/tags/os/">OS</category></item><item><title>CSAPP 读书笔记：处理器架构</title><link>/posts/processor-architecture-note/</link><guid isPermaLink="true">/posts/processor-architecture-note/</guid><pubDate>Sun, 12 Dec 2021 09:19:42 +0100</pubDate><author>koktlgwr@gmail.com (koktlzz)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</copyright><description>我们将处理器支持的指令及其对应的字节编码方式称为指令集架构（Instruction Set Architecture，ISA）。不同的处理器系列，例如 Intel IA32/x86-64，IBM/Freescale Power 和 ARM 等，均使用不同的 ISA。为一种机器编译得到的程序，无法在 ISA 不同的机器上运行 &amp;hellip;</description><category domain="/series/csapp-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">CSAPP 读书笔记</category><category domain="/tags/isa/">ISA</category></item><item><title>【译】从零开始编写一个时序数据库</title><link>/posts/writing-a-time-series-database-from-scratch/</link><guid isPermaLink="true">/posts/writing-a-time-series-database-from-scratch/</guid><pubDate>Sun, 21 Nov 2021 00:25:25 +0800</pubDate><author>koktlgwr@gmail.com (koktlzz)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</copyright><description>Prometheus 是一个包含了自定义时间序列数据库的监控系统，其查询语言、操作模型以及一些概念性决策使得它易于与 Kubernetes 集成。然而，Kubernetes 集群中的工作负载是动态变化的，有可能给它带来一定的压力 &amp;hellip;</description><category domain="/tags/prometheus/">Prometheus</category><category domain="/tags/tsdb/">TSDB</category></item><item><title>通过安装 CoreOS 系统了解 Linux 启动流程</title><link>/posts/understand-linux-boot-process-by-installing-coreos/</link><guid isPermaLink="true">/posts/understand-linux-boot-process-by-installing-coreos/</guid><pubDate>Wed, 20 Oct 2021 00:25:25 +0800</pubDate><author>koktlgwr@gmail.com (koktlzz)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</copyright><description>OpenShift 4.X 版本要求安装在操作系统为 CoreOS 的机器上，因此官方文档给出了使用 PXE 或 IPXE 引导 CoreOS 系统的方法。我们可以参考其操作流程，将一台 CentOS 7.X 的机器改写为 CoreOS 系统，步骤如下 &amp;hellip;</description><category domain="/tags/os/">OS</category><category domain="/tags/linux/">Linux</category><category domain="/tags/coreos/">CoreOs</category></item><item><title>CSAPP 读书笔记：程序的机器级表示</title><link>/posts/machine-level-representation-of-programs-note/</link><guid isPermaLink="true">/posts/machine-level-representation-of-programs-note/</guid><pubDate>Thu, 23 Sep 2021 09:19:42 +0100</pubDate><author>koktlgwr@gmail.com (koktlzz)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</copyright><description>在使用高级语言，如 C、Java 编程时，我们无法了解程序在机器级别的实现。而使用汇编语言编写程序时，程序员则只能引用低级指令。由高级语言编写的程序可以在多种不同的机器上编译运行，而汇编语言则与机器特性高度相关 &amp;hellip;</description><category domain="/series/csapp-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">CSAPP 读书笔记</category><category domain="/tags/os/">OS</category></item><item><title>CSAPP 读书笔记：信息的表示和处理</title><link>/posts/representing-and-manipulating-information-note/</link><guid isPermaLink="true">/posts/representing-and-manipulating-information-note/</guid><pubDate>Mon, 19 Jul 2021 09:19:42 +0100</pubDate><author>koktlgwr@gmail.com (koktlzz)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</copyright><description>大多数机器使用字节（8 位的块）作为存储器中的最小寻址单元，而非访问单独的位。内存中的每一个字节都对应一个唯一的数字，即它的地址，所有可能的地址集合构成了虚拟内存。它是由 DRAM、闪存（Flash Memory) 和磁盘存储共同实现的，而在程序看来则只是一个统一的字节数组 &amp;hellip;</description><category domain="/series/csapp-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">CSAPP 读书笔记</category><category domain="/tags/os/">OS</category></item><item><title>CSAPP 读书笔记：计算机系统之旅</title><link>/posts/a-tour-of-computer-systems-note/</link><guid isPermaLink="true">/posts/a-tour-of-computer-systems-note/</guid><pubDate>Wed, 26 May 2021 09:19:42 +0100</pubDate><author>koktlgwr@gmail.com (koktlzz)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</copyright><description>一堆 bit 可以表示系统中的所有信息，包括磁盘中的文件、内存中的程序和用户数据以及网络中传输的数据，区分它们的唯一方式便是我们查看这些数据对象时所处的上下文（Context）。例如，相同的一串 bit 在不同的 Context 中可能代表一个整数，也可能代表一个浮点数，甚至字符串 &amp;hellip;</description><category domain="/series/csapp-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">CSAPP 读书笔记</category><category domain="/tags/os/">OS</category></item><item><title>对 Openshift SDN 网络模型的一些探索</title><link>/posts/explorations-on-the-openshift-sdn-network-model/</link><guid isPermaLink="true">/posts/explorations-on-the-openshift-sdn-network-model/</guid><pubDate>Thu, 13 May 2021 09:19:42 +0100</pubDate><author>koktlgwr@gmail.com (koktlzz)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</copyright><description>在《Kubernetes Pod 是如何跨节点通信的？》中，我们简单地介绍了 Kubernetes 中的两种 SDN 网络模型：Underlay 和 Overlay。而 Openshift 中的 SDN 则是由 Overlay 网络 OVS（Open vSwitch）实现的，其使用的插件如下 &amp;hellip;</description><category domain="/tags/openshift/">Openshift</category><category domain="/tags/network/">Network</category><category domain="/tags/container/">Container</category><category domain="/tags/cni/">CNI</category><category domain="/tags/open-vswitch/">Open vSwitch</category></item><item><title>Kubernetes Pod 是如何跨节点通信的？</title><link>/posts/how-kubernetes-pods-communicate-across-nodes/</link><guid isPermaLink="true">/posts/how-kubernetes-pods-communicate-across-nodes/</guid><pubDate>Sun, 09 May 2021 09:19:42 +0100</pubDate><author>koktlgwr@gmail.com (koktlzz)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</copyright><description>《A Guide to the Kubernetes Networking Model》一文生动形象地介绍了 Kubernetes 中的网络模型，然而受篇幅所限，作者并没有对 Pod 跨节点通信时数据包在节点之间传递的细节进行过多讨论 &amp;hellip;</description><category domain="/tags/kubernetes/">Kubernetes</category><category domain="/tags/container/">Container</category><category domain="/tags/network/">Network</category><category domain="/tags/cni/">CNI</category><category domain="/tags/calico/">Calico</category></item><item><title>Kafka 是如何同步副本的？</title><link>/posts/how-does-kafka-synchronize-replicas/</link><guid isPermaLink="true">/posts/how-does-kafka-synchronize-replicas/</guid><pubDate>Fri, 26 Mar 2021 00:25:25 +0800</pubDate><author>koktlgwr@gmail.com (koktlzz)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</copyright><description>通常，Kafka 中的每个 Partiotion 中有多个副本 (Replica) 以实现高可用。想象一个场景，Consumer 正在消费 Leader 中 Offset = 10 的数据，而此时 Follower 中只同步到 Offset = 8。那么当 Leader 所在的 Broker 宕机后，当前 Follower 经选举成为新的 Leader，Consumer 再次消费时便会报错 &amp;hellip;</description><category domain="/tags/kafka/">Kafka</category></item></channel></rss>