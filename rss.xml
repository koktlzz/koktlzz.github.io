<?xml version="1.0" encoding="utf-8"?><rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Inspire Hub</title><link>/</link><description>MemE is a powerful and highly customizable GoHugo theme for personal blogs.</description><generator>Hugo 0.89.4 https://gohugo.io/</generator><language>en</language><managingEditor>koktlgwr@gmail.com (koktlzz)</managingEditor><webMaster>koktlgwr@gmail.com (koktlzz)</webMaster><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</copyright><lastBuildDate>Fri, 26 Nov 2021 09:59:20 +0000</lastBuildDate><atom:link rel="self" type="application/rss+xml" href="/rss.xml"/><item><title>【译】从零开始写一个时序数据库</title><link>/posts/writing-a-time-series-database-from-scratch/</link><guid isPermaLink="true">/posts/writing-a-time-series-database-from-scratch/</guid><pubDate>Sun, 21 Nov 2021 00:25:25 +0800</pubDate><author>koktlgwr@gmail.com (koktlzz)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</copyright><description>Prometheus 是一个包含了自定义时间序列数据库的监控系统，其查询语言、操作模型以及一些概念性决策使得它易于与 Kubernetes 集成。然而，Kubernetes 集群中的工作负载是动态变化的，有可能给它带来一定的压力&amp;hellip;</description><category domain="/tags/prometheus/">Prometheus</category><category domain="/tags/tsdb/">TSDB</category></item><item><title>通过安装 CoreOS 系统了解 Linux 启动流程</title><link>/posts/understand-linux-boot-process-by-installing-coreos/</link><guid isPermaLink="true">/posts/understand-linux-boot-process-by-installing-coreos/</guid><pubDate>Wed, 20 Oct 2021 00:25:25 +0800</pubDate><author>koktlgwr@gmail.com (koktlzz)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</copyright><description>OpenShift 4.X 版本要求安装在操作系统为 CoreOS 的机器上，因此官方文档给出了使用 PXE 或 IPXE 引导 CoreOS 系统的方法。我们可以参考其操作流程，将一台 CentOS 7.X 的机器改写为 CoreOS 系统，步骤如下 &amp;hellip;</description><category domain="/tags/os/">OS</category><category domain="/tags/linux/">Linux</category><category domain="/tags/coreos/">CoreOs</category></item><item><title>CSAPP 读书笔记：程序的机器级表示</title><link>/posts/machine-level-representation-of-programs-note/</link><guid isPermaLink="true">/posts/machine-level-representation-of-programs-note/</guid><pubDate>Thu, 23 Sep 2021 09:19:42 +0100</pubDate><author>koktlgwr@gmail.com (koktlzz)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</copyright><description>在使用高级语言，如 C、Java 编程时，我们无法了解程序具体的机器级实现。相比之下，使用汇编语言编写程序时，程序员必须指定程序使用的低级指令来执行计算。编译器提供的类型检查有助于检测许多程序错误，确保我们以一致的方式来引用和操作数据 &amp;hellip;</description><category domain="/tags/csapp/">CSAPP</category><category domain="/tags/os/">OS</category></item><item><title>CSAPP 读书笔记：信息的表示和处理</title><link>/posts/representing-and-manipulating-information-note/</link><guid isPermaLink="true">/posts/representing-and-manipulating-information-note/</guid><pubDate>Mon, 19 Jul 2021 09:19:42 +0100</pubDate><author>koktlgwr@gmail.com (koktlzz)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</copyright><description>大多数机器使用字节（8 位的块）作为存储器中的最小寻址单元，而非访问单独的位。内存中的每一个字节都对应一个唯一的数字，即它的地址，所有可能的地址集合构成了虚拟内存。它是由 DRAM、闪存（flash memory) 和磁盘存储共同实现的，而在程序看来则只是一个统一的字节数组 &amp;hellip;</description><category domain="/tags/csapp/">CSAPP</category><category domain="/tags/os/">OS</category></item><item><title>CSAPP 读书笔记：计算机系统之旅</title><link>/posts/a-tour-of-computer-systems-note/</link><guid isPermaLink="true">/posts/a-tour-of-computer-systems-note/</guid><pubDate>Wed, 26 May 2021 09:19:42 +0100</pubDate><author>koktlgwr@gmail.com (koktlzz)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</copyright><description>一堆 bit 可以表示系统中的所有信息，包括磁盘中的文件、内存中的程序和用户数据以及网络中传输的数据，区分它们的唯一方式便是我们查看这些数据对象时所处的上下文（Context）。例如，相同的一串 bit 在不同的 Context 中可能代表一个整数，也可能代表一个浮点数，甚至字符串 &amp;hellip;</description><category domain="/tags/csapp/">CSAPP</category><category domain="/tags/os/">OS</category></item><item><title>对 Openshift SDN 网络模型的一些探索</title><link>/posts/explorations-on-the-openshift-sdn-network-model/</link><guid isPermaLink="true">/posts/explorations-on-the-openshift-sdn-network-model/</guid><pubDate>Thu, 13 May 2021 09:19:42 +0100</pubDate><author>koktlgwr@gmail.com (koktlzz)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</copyright><description>在《Kubernetes Pod 是如何跨节点通信的？》中，我们简单地介绍了 Kubernetes 中的两种 SDN 网络模型：Underlay 和 Overlay。而 Openshift 中的 SDN 则是由 Overlay 网络 OVS（Open vSwitch）实现的，其使用的插件如下 &amp;hellip;</description><category domain="/tags/openshift/">Openshift</category><category domain="/tags/network/">Network</category><category domain="/tags/cni/">CNI</category><category domain="/tags/open-vswitch/">Open vSwitch</category></item><item><title>Kubernetes Pod 是如何跨节点通信的？</title><link>/posts/how-kubernetes-pods-communicate-across-nodes/</link><guid isPermaLink="true">/posts/how-kubernetes-pods-communicate-across-nodes/</guid><pubDate>Sun, 09 May 2021 09:19:42 +0100</pubDate><author>koktlgwr@gmail.com (koktlzz)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</copyright><description>《A Guide to the Kubernetes Networking Model》一文生动形象地介绍了 Kubernetes 中的网络模型，然而受篇幅所限，作者并没有对 Pod 跨节点通信时数据包在节点之间传递的细节进行过多讨论 &amp;hellip;</description><category domain="/tags/kubernetes/">Kubernetes</category><category domain="/tags/network/">Network</category><category domain="/tags/cni/">CNI</category></item><item><title>Kafka 是如何同步副本的？</title><link>/posts/how-does-kafka-synchronize-replicas/</link><guid isPermaLink="true">/posts/how-does-kafka-synchronize-replicas/</guid><pubDate>Fri, 26 Mar 2021 00:25:25 +0800</pubDate><author>koktlgwr@gmail.com (koktlzz)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</copyright><description>通常，Kafka 中的每个 Partiotion 中有多个副本 (Replica) 以实现高可用。想象一个场景，Consumer 正在消费 Leader 中 Offset=10 的数据，而此时 Follower 中只同步到 Offset=8。那么当 Leader 所在的 Broker 宕机后，当前 Follower 经选举成为新的 Leader，Consumer 再次消费时便会报错 &amp;hellip;</description><category domain="/tags/kafka/">Kafka</category></item></channel></rss>